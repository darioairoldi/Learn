# Prompts and Markdown Structure for a Documentation Site

## Overview

Building an AI-enhanced documentation site requires careful organization of automation tools, content templates, and contextual materials. This article provides a comprehensive guide to structuring your repository with prompt files for task automation, templates for consistent content creation, instruction files for AI guidance, and embedded metadata for tracking validations. By implementing this structure, you'll create a powerful workflow where GitHub Copilot can generate, review, and validate documentation according to your editorial standards, ensuring consistency and quality across your entire learning site.

## Table of Contents

- üìù [Prompt Files for Task Automation](#prompt-files-for-task-automation)
  - Content Generation Prompts
  - Quality Validation Prompts
  - Analysis and Discovery Prompts
- üìã [Template Files for Consistent Structure](#template-files-for-consistent-structure)
  - Article Templates
  - Workflow Templates
- üìö [Context and Instruction Files](#context-and-instruction-files)
  - Global Instructions
  - Scoped Instructions
  - Extended Context Materials
- üè∑Ô∏è [Article Metadata Management](#article-metadata-management)
  - Dual YAML Block Architecture
  - Embedded Metadata Benefits
- üéØ [Implementation Best Practices](#implementation-best-practices)
- üìñ [References](#references)

## üìù Prompt Files for Task Automation

Prompt files are the backbone of an AI-enhanced documentation workflow. Each prompt automates a specific task, making it easy to maintain quality and consistency across your documentation site. Store these files in `.github/prompts/` for automatic recognition by both VS Code and Visual Studio.

### Content Generation Prompts

For each automated activity you listed, create a dedicated `*.prompt.md` under `.github/prompts/` (this location is recognized by both VS Code and Visual Studio for workspace prompts). Typical prompts include:

1.  **Article Writing (`article-writing.prompt.md`)** ‚Äì Generate a draft article given a topic and outline. The prompt can retrieve related research with `#fetch` to enrich content.
2.  **Grammar Review (`grammar-review.prompt.md`)** ‚Äì Check and correct grammar and spelling in a selected file.
3.  **Understandability Review (`understandability-review.prompt.md`)** ‚Äì Evaluate how comprehensible the article is to your intended audience and suggest improvements.
4.  **Readability & Redundancy Review (`readability-review.prompt.md`)** ‚Äì Assess consistency, clarity, and redundancy, and propose edits to improve flow.
5.  **Gap Analysis (`gap-analysis.prompt.md`)** ‚Äì Identify missing concepts or perspectives by comparing the article to relevant sources (using `#fetch` or a URL list).
6.  **Logical Flow Analysis (`logic-analysis.prompt.md`)** ‚Äì Check whether ideas flow coherently and identify structural leaks or non-sequiturs.
7.  **Structure Validation (`structure-validation.prompt.md`)** ‚Äì Ensure required components are present (e.g. TOC, introduction, conclusion, references).
8.  **Facts Checking (`fact-checking.prompt.md`)** ‚Äì Verify accuracy against specified sources or automatically fetched authoritative references and suggest citations.
9.  **Series Validation (`series-validation.prompt.md`)** ‚Äì Review multiple articles/topics to ensure consistent scope, logical connections, and non-redundancy.
10. **Correlated Subjects Discovery (`correlated-topics.prompt.md`)** ‚Äì Suggest related topics or further reading based on the article‚Äôs subject.

Each of these prompts can leverage VS Code‚Äôs `${input:...}` variables or Visual Studio‚Äôs `#file` references to specify parameters like the target file or topic. In VS Code, prompts can also reference tools such as `#fetch` (to retrieve web content) or `#codebase` for searching your repository. In Visual Studio (starting with v17.10), prompt files in `.github/prompts` can be triggered via `#promptName`.

### 2. Useful Templates

To ensure uniformity and encourage structured content, maintain a `templates/` folder in your repo with Markdown templates such as:

*   **`article-template.md`** ‚Äì Defines the default article structure (title, intro, table of contents, body sections, conclusion and references).
*   **`issue-template.md`** ‚Äì Provides a template for reporting discrepancies or suggestions (steps to reproduce, expected vs. actual behavior, etc.).
*   **`recording-summary-template.md`** ‚Äì For drafting summaries of recorded sessions or interviews, including segments, key points, timestamp summaries, etc.
*   **`recording-analysis-template.md`** ‚Äì Guides deeper analysis of recordings (themes, unanswered questions, follow-up actions).

Prompts designed for drafting articles or analyzing recordings can reference these templates via relative Markdown links.

### 3. Other Context & Instruction Files

*   **Global instructions**: Create `.github/copilot-instructions.md` to codify your editorial standards. For instance:
    *   ‚ÄúAlways cross-verify facts with authoritative sources and cite them.‚Äù
    *   ‚ÄúFocus on readability: keep sentences concise and structure sections logically.‚Äù
    *   ‚ÄúFollow the article template; include a table of contents, introduction, conclusion and references.‚Äù
        These instructions apply automatically in both VS Code and Visual Studio (v17.10+), provided that you enable ‚ÄúUse Instruction Files‚Äù in VS Code settings or Visual Studio options.

*   **Scoped instructions**: Use `.github/instructions/` to store file- or language-specific guidelines. For example, a `docs.instructions.md` could enforce Markdown style rules across the `/docs` directory, while a separate `api.instructions.md` could set conditions when testing API examples.

*   **Extended context**: Optionally, maintain a `.copilot/context/` folder containing data schemas, glossaries, style guides, coding patterns, domain knowledge, or any supporting research. Copilot‚Äôs semantic search prioritizes content in this directory; including it helps the assistant produce higher-quality results.

### 4. Article Metadata Format

To track analyses and validations effectively, store metadata alongside each article. Two common patterns:

1.  **Embedded front matter**: Include YAML front matter at the top of each article file:
    ```markdown
    ---
    title: Effective Prompt Design for Learning Docs
    author: Dario Airoldi
    created: 2024-11-10
    last-updated: 2025-11-16
    tags: [prompt engineering, documentation]
    validations:
      grammar:
        last-run: 2025-11-15
        model: GPT-4
        outcome: "No major errors; updated with minor fixes."
      readability:
        last-run: 2025-09-20
        model: GPT-4
        outcome: "Grade level 9.0. Improved by simplifying some sentences."
      facts:
        last-run: 2025-10-01
        model: GPT-4
        sources:
          - "https://example.com/reputable_article"
        outcome: "All statements verified and up to date."
    ---
    ```
2.  **Separate metadata file**: Save a separate YAML or JSON file (e.g., `article-name.metadata.yml`) next to each article. This decouples metadata from content and avoids mixing data with reader-facing prose.  
    A typical `.metadata.yaml` file might include:
    *   Core fields: `title`, `author`, `created`, `last-updated`, `tags`.
    *   **Validations**: sections (e.g. `grammar`, `readability`, `logic`, `facts`) with attributes like `last-run`, `model`, `tool`, and `outcome`.
    *   **Cross-references**: links to related articles or correlated topics discovered.
    *   **Sources**: citations used in fact-checking.

Storing validation results (model, timestamp, outcome) allows future prompts to check whether a new run is needed (e.g., if an article has been updated or if a new model is available). When a prompt runs, it can read this metadata file (via `#file`) and decide whether to skip repeated work.

***

By combining well-structured prompts, templates, context files, and metadata, you‚Äôll create a powerful, AI-enhanced documentation workflow. Copilot can then generate, review, and validate articles according to your standards, saving time while ensuring consistency and reliability across your learning site.
