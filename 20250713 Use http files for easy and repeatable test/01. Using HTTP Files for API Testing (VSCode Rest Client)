# üåê Using HTTP Files for API Testing (VSCode Rest Client)

**HTTP files** are a great way to test your web API calls directly from your code editor, offering a lightweight alternative to Postman. They're especially helpful for documenting and version-controlling your API tests alongside your code.

## üìë Table of Contents

- [üöÄ Getting Started with HTTP Files](#-getting-started-with-http-files)
- [‚ö° Advanced Features](#-advanced-features)
  - [Variables and Environments](#variables-and-environments)
  - [Request Chaining and Multiple Requests in Files](#request-chaining-and-multiple-requests-in-files)
  - [File Uploads](#file-uploads)
  - [cURL Integration](#curl-integration)
- [‚ú® Benefits Over Postman](#-benefits-over-postman)
- [üîê Azure AD Authentication for Protected APIs](#-azure-ad-authentication-for-protected-apis)
  - [Method 1: Client Credentials Flow (Service-to-Service)](#method-1-client-credentials-flow-service-to-service)
  - [Method 2: Authorization Code Flow with PKCE (Interactive)](#method-2-authorization-code-flow-with-pkce-interactive)
  - [Method 3: Using REST Client's Built-in Azure AD Support](#method-3-using-rest-clients-built-in-azure-ad-support)
  - [Method 4: Environment-Specific Configuration](#method-4-environment-specific-configuration)
  - [Method 5: Token Refresh Pattern](#method-5-token-refresh-pattern)
  - [Security Best Practices](#security-best-practices-1)
  - [Common Token Response Structure](#common-token-response-structure)
- [üìö References](#-references)
- [üìé Appendixes](#-appendixes)
  - [Appendix A: REST Client Main Features](#appendix-a-rest-client-main-features)

## üöÄ Getting Started with `REST Client` .http Files

**1. Install the `REST Client` Extension in VS Code**<br>

  ![alt text](<images/01.001 package install.png>)
  First, install the "REST Client" extension by Huachao Mao:

  1. Open VS Code
  2. Go to Extensions (Ctrl+Shift+X)
  3. Search for <mark>`REST Client`</mark>
  4. Click "Install"

**2. Create an HTTP File**<br>
Create a new file with `.http` or `.rest` extension in your project:

**3. Write Your First HTTP Request**<br>
Here's a simple GET request:

```http
### Get all items
GET https://api.example.com/items
```

**4. Add Headers and Body**<br>
For a POST request with JSON body:

```http
### Create new item
POST https://api.example.com/items
Content-Type: application/json

{
  "name": "New Item",
  "description": "This is a test item"
}
```

**5. Execute Requests**:<br>
To execute a request:

- Click the "<mark>Send Request</mark>" link that appears above each request
- Or use the shortcut <mark>`Ctrl+Alt+R`</mark> (Windows/Linux) or `Cmd+Alt+R` (Mac)

## Variables and Environments

Variables allow you to reuse values across your HTTP requests, making your API tests more maintainable and flexible. REST Client supports multiple ways to define and use variables.

### How Variables Are Defined

Variables use the `{{variableName}}` syntax for referencing and different definition syntaxes depending on the type:

**Syntax for referencing variables:**
```http
GET {{baseUrl}}/api/{{version}}/users
Authorization: Bearer {{token}}
```

**Syntax for defining variables:**
- **File variables**: `@variableName = value`
- **Environment variables**: Defined in `.vscode/settings.json`
- **System variables**: Built-in, no definition needed (e.g., `{{$guid}}`)
- **.env variables**: Defined in `.env` file, accessed via `{{$dotenv KEY}}`

### Where Variables Can Be Defined

REST Client supports three primary locations for defining variables, each with different scopes and use cases:

#### 1. Same File Variables (File Scope)

Define variables directly in your `.http` file using `@variableName = value` syntax. These variables are available throughout the entire file.

**Syntax:**
```http
@variableName = value
```

**Example:**
```http
### Define file-level variables
@baseUrl = https://api.example.com
@apiVersion = v2
@contentType = application/json
@authToken = Bearer abc123xyz

### Use the variables in requests
GET {{baseUrl}}/{{apiVersion}}/users
Content-Type: {{contentType}}
Authorization: {{authToken}}

### Variables work in all requests in this file
POST {{baseUrl}}/{{apiVersion}}/items
Content-Type: {{contentType}}
Authorization: {{authToken}}

{
  "name": "Test Item"
}
```

**Characteristics:**
- ‚úÖ **Scope**: Available only within the same `.http` file where defined
- ‚úÖ **Location**: Define anywhere in the file (typically at the top)
- ‚úÖ **Variable references**: Can reference other variables and system variables
- ‚úÖ **Version control**: Can be committed (for non-sensitive values)
- ‚ùå **Cross-file**: Cannot be used in other `.http` files
- ‚ùå **Importing**: Cannot import variables from other `.http` files

**Advanced usage - Variables referencing other variables:**
```http
@protocol = https
@domain = api.example.com
@port = 8080
@baseUrl = {{protocol}}://{{domain}}:{{port}}
@timestamp = {{$datetime iso8601}}
@user = {{$processEnv USERNAME}}

GET {{baseUrl}}/api/logs?created={{timestamp}}&user={{user}}
```

#### 2. VS Code Settings File (Cross-File, Environment-Based)

Define environment-specific variables in `.vscode/settings.json` for use across all `.http` files in your workspace. This is the **recommended approach** for managing multiple environments.

**Location:** `.vscode/settings.json` in your workspace

**Syntax:**
```json
{
  "rest-client.environmentVariables": {
    "$shared": {
      "variableName": "value"
    },
    "environmentName": {
      "variableName": "value"
    }
  }
}
```

**Example:**
```json
{
  "rest-client.environmentVariables": {
    "$shared": {
      "apiVersion": "v2",
      "userAgent": "MyApp/1.0",
      "contentType": "application/json"
    },
    "development": {
      "baseUrl": "https://localhost:7001",
      "apiKey": "dev-api-key-here",
      "dbConnection": "Server=localhost;Database=DevDB"
    },
    "staging": {
      "baseUrl": "https://staging.api.example.com",
      "apiKey": "staging-api-key",
      "dbConnection": "Server=staging-db;Database=StagingDB"
    },
    "production": {
      "baseUrl": "https://api.example.com",
      "apiKey": "prod-api-key",
      "dbConnection": "Server=prod-db;Database=ProdDB"
    }
  }
}
```

**Using in `.http` files:**
```http
### These variables come from the active environment
GET {{baseUrl}}/api/{{apiVersion}}/users
Authorization: Bearer {{apiKey}}
User-Agent: {{userAgent}}
Content-Type: {{contentType}}
```

**Switching environments:**
- **Keyboard shortcut**: <mark>Ctrl+Alt+E</mark> (Cmd+Alt+E on macOS)
- **Command palette**: <mark>Ctrl+Shift+P</mark> ‚Üí "Rest Client: Switch Environment"
- **Status bar**: Click the environment name at the bottom of VS Code

**Characteristics:**
- ‚úÖ **Scope**: Available in all `.http` files in the workspace
- ‚úÖ **Environments**: Easy switching between dev/staging/prod
- ‚úÖ **$shared environment**: Variables available in all environments
- ‚úÖ **Reference shared**: Use `{{$shared variableName}}` to explicitly reference shared vars
- ‚ö†Ô∏è **Version control**: Typically per-developer (each developer has their own settings)
- ‚úÖ **Best for**: Team environments, configuration management

#### 3. .env Files (Standard Environment Files)

Use standard `.env` files for environment variables, accessed via the `{{$dotenv VARIABLE_NAME}}` system variable.

**Location:** `.env` file in the **same directory** as your `.http` file

**Syntax in .env file:**
```env
KEY=value
```

**Example `.env` file:**
```env
# .env - Add to .gitignore
BASE_URL=https://localhost:7001
API_KEY=your-secret-api-key-here
CLIENT_SECRET=abc123xyz789
DB_CONNECTION=Server=localhost;Database=DevDB
TENANT_ID=your-tenant-id
```

**Using in `.http` files:**
```http
### Access .env variables using $dotenv system variable
GET {{$dotenv BASE_URL}}/api/data
Authorization: Bearer {{$dotenv API_KEY}}
X-Tenant-ID: {{$dotenv TENANT_ID}}
```

**Important notes:**
- ‚ö†Ô∏è Each variable must be accessed individually with `{{$dotenv KEY}}`
- ‚ö†Ô∏è The `.env` file is **not automatically loaded** - you must explicitly reference each variable
- ‚ö†Ô∏è The `.env` file must be in the **same directory** as your `.http` file (no parent directory search)
- ‚ö†Ô∏è This is **not importing** - it's a runtime read operation

**Best practices:**
```gitignore
# .gitignore
.env
.env.local
.env.*.local
```

**Create a template:**
```env
# .env.example - Commit this as a template
BASE_URL=https://localhost:7001
API_KEY=your-api-key-here
CLIENT_SECRET=your-client-secret-here
DB_CONNECTION=your-connection-string-here
```

**Characteristics:**
- ‚úÖ **Standard format**: Compatible with Node.js, Python, and other tools
- ‚úÖ **Security**: Can be added to `.gitignore`
- ‚úÖ **Best for**: Local secrets, developer-specific configuration
- ‚ùå **No auto-loading**: Must use `{{$dotenv KEY}}` for each variable
- ‚ùå **Same directory only**: No cascading file lookups

### Variable Resolution Priority

When the same variable name is defined in multiple places, REST Client resolves them in this priority order (highest to lowest):

1. **Request Variables** (highest) - Variables captured from previous request responses using `# @name`
2. **File Variables** - Variables defined in the same `.http` file with `@variableName = value`
3. **Prompt Variables** - Interactive input variables defined with `# @prompt`
4. **Environment Variables** (lowest) - Variables from `.vscode/settings.json`

**Example demonstrating priority:**
```http
### In .vscode/settings.json:
# "development": { "token": "env-token" }

### In this .http file:
@token = file-level-token

# @name login
POST https://api.example.com/login
Content-Type: application/json
{ "username": "user", "password": "pass" }

### Priority demonstration:
# 1. Request variable (highest) - uses token from login response
GET https://api.example.com/data
Authorization: Bearer {{login.response.body.token}}

# 2. If login not executed, falls back to file variable
# Authorization: Bearer file-level-token

# 3. If no file variable, falls back to environment variable
# Authorization: Bearer env-token
```

### System Variables (Built-in, Predefined)

REST Client provides built-in system variables that generate dynamic values. These don't need to be defined - they're always available.

**Available system variables:**

| System Variable | Description | Example Output |
|----------------|-------------|----------------|
| `{{$guid}}` | RFC 4122 v4 UUID | `3e2b0e8f-8b5c-4f3a-9b2c-1d4e5f6a7b8c` |
| `{{$randomInt min max}}` | Random integer between min (inclusive) and max (exclusive) | `{{$randomInt 1 100}}` ‚Üí `42` |
| `{{$timestamp}}` | Current Unix timestamp in seconds | `1634567890` |
| `{{$timestamp offset unit}}` | Timestamp with offset | `{{$timestamp 3 h}}` ‚Üí timestamp 3 hours ahead |
| `{{$datetime format}}` | Current datetime in specified format | `{{$datetime iso8601}}` ‚Üí `2021-10-18T10:31:30.000Z` |
| `{{$datetime format offset unit}}` | Datetime with offset | `{{$datetime iso8601 -1 d}}` ‚Üí 1 day ago |
| `{{$localDatetime format}}` | Local timezone datetime | `{{$localDatetime iso8601}}` ‚Üí `2021-10-18T13:31:30.000+03:00` |
| `{{$processEnv VAR}}` | OS environment variable | `{{$processEnv USERNAME}}` ‚Üí `john.doe` |
| `{{$dotenv KEY}}` | Variable from .env file | `{{$dotenv API_KEY}}` ‚Üí value from .env |
| `{{$aadToken}}` | Azure AD authentication token | `eyJ0eXAiOiJKV1Q...` |

**Timestamp and datetime offset units:**

| Unit | Description | Example |
|------|-------------|---------|
| `y` | Year | `{{$timestamp 1 y}}` - 1 year ahead |
| `M` | Month | `{{$timestamp -2 M}}` - 2 months ago |
| `w` | Week | `{{$timestamp 1 w}}` - 1 week ahead |
| `d` | Day | `{{$timestamp -7 d}}` - 7 days ago |
| `h` | Hour | `{{$timestamp 3 h}}` - 3 hours ahead |
| `m` | Minute | `{{$timestamp -30 m}}` - 30 minutes ago |
| `s` | Second | `{{$timestamp 10 s}}` - 10 seconds ahead |
| `ms` | Millisecond | `{{$timestamp 500 ms}}` - 500ms ahead |

**Datetime formats:**

| Format | Description | Example Output |
|--------|-------------|----------------|
| `iso8601` | ISO 8601 format | `2021-10-18T10:31:30.000Z` |
| `rfc1123` | RFC 1123 format | `Mon, 18 Oct 2021 10:31:30 GMT` |
| `'YYYY-MM-DD'` | Custom format (quoted) | `2021-10-18` |
| `'DD/MM/YYYY HH:mm'` | Custom format | `18/10/2021 10:31` |

Custom datetime formats use [Day.js formatting tokens](https://day.js.org/docs/en/display/format).

**Examples:**

```http
### Using system variables for dynamic values
POST https://api.example.com/events
Content-Type: application/json
X-Request-ID: {{$guid}}
X-Timestamp: {{$timestamp}}
X-User: {{$processEnv USERNAME}}

{
  "eventId": "{{$guid}}",
  "createdAt": "{{$datetime iso8601}}",
  "createdBy": "{{$processEnv USERNAME}}",
  "randomPriority": {{$randomInt 1 10}},
  "scheduledFor": "{{$datetime iso8601 2 h}}"
}

### Date range queries
GET https://api.example.com/logs?start={{$datetime 'YYYY-MM-DD' -7 d}}&end={{$datetime 'YYYY-MM-DD'}}

### Using .env file variables
GET {{$dotenv BASE_URL}}/api/data
Authorization: Bearer {{$dotenv API_KEY}}
X-Environment: {{$dotenv ENVIRONMENT}}

### Using OS environment variables (useful in CI/CD)
GET https://api.example.com/deploy
Authorization: Bearer {{$processEnv CI_API_TOKEN}}
X-Build-Number: {{$processEnv BUILD_NUMBER}}
```

### Interactive Variables (Prompt Variables)

Prompt variables allow you to input values interactively when sending a request, useful for values that change with each execution.

**Syntax:**
```http
# @prompt variableName
# @prompt variableName Description text shown in prompt
```

**Example:**
```http
# @prompt username
# @prompt password
# @prompt apiKey Your API key from the developer portal
# @prompt otp Your one-time password from email

POST https://api.example.com/login
Content-Type: application/json
X-API-Key: {{apiKey}}

{
  "username": "{{username}}",
  "password": "{{password}}",
  "otp": "{{otp}}"
}
```

**Characteristics:**
- ‚úÖ Input is **hidden** (password-style) if variable name contains: `password`, `passwd`, `pass`, `secret`, `token`, `key` (case-insensitive)
- ‚úÖ Prompts appear when the request is sent
- ‚úÖ Values are **not stored** - you'll be prompted each time
- ‚úÖ Overrides file and environment variables with the same name
- ‚úÖ **Best for**: OTPs, temporary tokens, user-specific test data

### Comparison of Variable Types

| Variable Type | Definition Location | Scope | Priority | Version Control | Best For |
|--------------|-------------------|-------|----------|-----------------|----------|
| **File Variables** | Same `.http` file | Single file | 2 | ‚úÖ Can commit (non-sensitive) | File-specific constants |
| **Environment Variables** | `.vscode/settings.json` | All files in workspace | 4 (lowest) | ‚ö†Ô∏è Per-developer | Multi-environment configs |
| **.env Variables** | `.env` file (same dir) | Same directory | N/A (system var) | ‚ùå Add to .gitignore | Local secrets |
| **OS Environment** | Operating system | System-wide | N/A (system var) | N/A | CI/CD, system secrets |
| **System Variables** | Built-in | Everywhere | N/A | ‚úÖ Always available | Dynamic values |
| **Prompt Variables** | Same `.http` file | Single file | 3 | ‚úÖ Can commit structure | Interactive input |
| **Request Variables** | Same `.http` file | Single file | 1 (highest) | ‚úÖ Can commit | Response chaining |

### What REST Client Does NOT Support

‚ùå **No file imports for variables**: You cannot import variable definitions from separate `.http` files using `< ./variables.http` syntax  
‚ùå **No automatic .env loading**: `.env` files are not automatically loaded - you must explicitly use `{{$dotenv varName}}` for each variable  
‚ùå **No cascading file lookups**: `.env` files must be in the same directory as your `.http` file (no parent directory search)  
‚ùå **No variable inheritance between `.http` files**: Each `.http` file has its own variable scope; file variables defined in one `.http` file cannot be used in another

> **Important**: The `< ./file.path` syntax only works for **request body content**, not for variable definitions:
> - ‚úÖ `< ./body.json` - Loads the file content as the request body
> - ‚úÖ `< ./data.xml` - Loads the file content as the request body  
> - ‚ùå `< ./variables.http` - Does NOT import `@variable = value` definitions
> 
> This limitation is documented in [GitHub Issue #845](https://github.com/Huachao/vscode-restclient/issues/845).

### Security Best Practices

**DO commit:**
- ‚úÖ `.http` files with non-sensitive file variables
- ‚úÖ `.vscode/settings.json` with placeholder values
- ‚úÖ `.env.example` templates
- ‚úÖ Documentation of required variables

**DON'T commit:**
- ‚ùå `.env` files with actual secrets
- ‚ùå `.vscode/settings.json` with real API keys or passwords
- ‚ùå Any files containing production credentials

**Guidelines:**
- ‚úÖ Use environment variables (settings.json or .env) for secrets, not file variables
- ‚úÖ Use `$shared` environment for non-sensitive values shared across environments
- ‚úÖ Use `{{$processEnv}}` for CI/CD and system-level secrets
- ‚úÖ Document required variables in your README
- ‚ùå Never hardcode API keys, passwords, or tokens in `.http` files

## Request Chaining and Multiple Requests in Files

REST Client supports powerful features for organizing multiple requests in a single file and chaining requests together where one request uses data from another's response.

### Multiple Requests in One File

You can organize multiple related requests in a single `.http` file by separating them with <mark>`###`</mark> (three or more consecutive `#` symbols).

**Syntax:**
```http
### Request 1 description
REQUEST_1

###

### Request 2 description
REQUEST_2

###

### Request 3 description
REQUEST_3
```

**Example:**

The **best practice** for managing multiple environments is to use VS Code's built-in environment variable system:

**In `.vscode/settings.json`:**

```json
{
  "rest-client.environmentVariables": {
    "$shared": {
      "apiVersion": "v2",
      "userAgent": "MyApp/1.0"
    },
    "development": {
      "baseUrl": "https://localhost:7001",
      "apiKey": "dev-api-key-here",
      "clientSecret": "dev-secret-key"
    },
    "production": {
      "baseUrl": "https://api.production.com", 
      "apiKey": "prod-api-key-here",
      "clientSecret": "prod-secret-key"
    }
  }
}
```

**Benefits:**
- ‚úÖ Easy environment switching without editing HTTP files
- ‚úÖ `$shared` environment provides variables available in all environments
- ‚úÖ Can reference shared variables with `{{$shared variableName}}`
- ‚úÖ Sensitive values can be kept out of version control

**Environment selection** happens via:
- **Shortcut**: <mark>Ctrl+Alt+E</mark> (Cmd+Alt+E on macOS)
- **Command Palette**: <mark>Ctrl+Shift+P</mark> ‚Üí "<mark>Rest Client: Switch Environment</mark>"
- **Status Bar**: Click the environment name in the bottom status bar

| Step | Screenshot |
|------|------------|
| Ctrl+Shift+P | ![alt text](<images/001.01 VisualStudioCode command.png>) |
| Rest Client: Switch Environment | ![alt text](<images/001.02 Switch environment.png>) |

**In your HTTP files:**

```http
### Use environment variables (switch environments in VS Code status bar)
GET {{baseUrl}}/api/{{apiVersion}}/data
Authorization: Bearer {{apiKey}}
User-Agent: {{userAgent}}
```

```http
@baseUrl = https://api.example.com
@apiVersion = v2

### Get all users
GET {{baseUrl}}/api/{{apiVersion}}/users

###

### Get specific user
GET {{baseUrl}}/api/{{apiVersion}}/users/123

###

### Create new user
POST {{baseUrl}}/api/{{apiVersion}}/users
Content-Type: application/json

{
  "name": "John Doe",
  "email": "john@example.com"
}

###

### Update user
PUT {{baseUrl}}/api/{{apiVersion}}/users/123
Content-Type: application/json

{
  "name": "John Updated",
  "email": "john.updated@example.com"
}

###

### Delete user
DELETE {{baseUrl}}/api/{{apiVersion}}/users/123
```

**Executing requests:**
- **Single request**: Click "Send Request" above any specific request or use <mark>Ctrl+Alt+R</mark>
- **Request selection**: Place cursor anywhere within a request block (between `###` delimiters) and execute
- **Send multiple**: Execute requests sequentially by clicking on each one

### Request Chaining (Using Response Data)

Request chaining allows you to capture data from one request's response and use it in subsequent requests. This is perfect for workflows like login ‚Üí use token ‚Üí perform operations.

**Syntax:**
```http
# @name requestName
REQUEST_DETAILS
```

**Reference syntax:**
- `{{requestName.response.body.*}}` - Full response body
- `{{requestName.response.body.$.jsonPath}}` - JSON property via JSONPath
- `{{requestName.response.body.//xpath}}` - XML attribute via XPath  
- `{{requestName.response.headers.HeaderName}}` - Response header (case-insensitive)
- `{{requestName.request.body.*}}` - Full request body
- `{{requestName.request.headers.HeaderName}}` - Request header

#### Basic Request Chaining Example

```http
@baseUrl = https://api.example.com

### Step 1: Login and capture the token
# @name login
POST {{baseUrl}}/auth/login
Content-Type: application/json

{
  "username": "testuser",
  "password": "testpass"
}

###

### Step 2: Use the token from login response
GET {{baseUrl}}/api/profile
Authorization: Bearer {{login.response.body.token}}

###

### Step 3: Create item using the token
# @name createItem
POST {{baseUrl}}/api/items
Authorization: Bearer {{login.response.body.token}}
Content-Type: application/json

{
  "name": "New Item",
  "description": "Created via API"
}

###

### Step 4: Get the created item using its ID
GET {{baseUrl}}/api/items/{{createItem.response.body.id}}
Authorization: Bearer {{login.response.body.token}}

###

### Step 5: Update the item
PUT {{baseUrl}}/api/items/{{createItem.response.body.id}}
Authorization: Bearer {{login.response.body.token}}
Content-Type: application/json

{
  "name": "Updated Item",
  "description": "Modified"
}
```

**How it works:**
1. Execute the `login` request first (manually click "Send Request")
2. The response is stored with the name `login`
3. Subsequent requests can reference `{{login.response.body.token}}`
4. Execute `createItem` to capture its response
5. Later requests can reference `{{createItem.response.body.id}}`

#### Using JSONPath for Complex Responses

For nested JSON structures, use JSONPath to extract specific values:

```http
### Get user with nested data
# @name getUser
GET https://api.example.com/users/123

# Response example:
# {
#   "data": {
#     "user": {
#       "id": 123,
#       "name": "John Doe",
#       "email": "john@example.com",
#       "profile": {
#         "avatar": "https://example.com/avatar.jpg",
#         "preferences": {
#           "theme": "dark"
#         }
#       }
#     },
#     "permissions": ["read", "write"]
#   },
#   "meta": {
#     "timestamp": "2021-10-18T10:31:30Z"
#   }
# }

###

### Extract nested properties using JSONPath
GET https://api.example.com/posts?author={{getUser.response.body.$.data.user.id}}
X-User-Name: {{getUser.response.body.$.data.user.name}}
X-User-Theme: {{getUser.response.body.$.data.user.profile.preferences.theme}}

###

### Get user's posts
# @name getUserPosts
GET https://api.example.com/users/{{getUser.response.body.$.data.user.id}}/posts

# Response example:
# {
#   "posts": [
#     {"id": 1, "title": "First Post"},
#     {"id": 2, "title": "Second Post"}
#   ]
# }

###

### Extract array elements
GET https://api.example.com/posts/{{getUserPosts.response.body.$.posts[0].id}}

###

### Use response headers
GET https://api.example.com/data
X-Rate-Limit: {{getUser.response.headers.X-RateLimit-Remaining}}
X-Request-ID: {{getUser.response.headers.X-Request-ID}}
```

**JSONPath examples:**
- `$.data.user.id` - Navigate nested objects
- `$.posts[0]` - First element of array
- `$.posts[*].id` - All IDs from array (returns array)
- `$..email` - Recursive search for email property

#### Using XPath for XML Responses

For XML responses, use XPath syntax:

```http
### Get XML data
# @name getXmlData
GET https://api.example.com/data.xml
Accept: application/xml

# Response example:
# <response>
#   <user id="123" name="John Doe">
#     <email>john@example.com</email>
#     <role>admin</role>
#   </user>
#   <metadata>
#     <timestamp>2021-10-18T10:31:30Z</timestamp>
#   </metadata>
# </response>

###

### Extract using XPath
GET https://api.example.com/users/{{getXmlData.response.body.//user/@id}}/profile
X-User-Role: {{getXmlData.response.body.//role}}
X-Timestamp: {{getXmlData.response.body.//timestamp}}
```

#### Capturing Response Headers

```http
### API call that returns custom headers
# @name apiCall
GET https://api.example.com/data
Authorization: Bearer your-token

# Response headers example:
# X-Request-ID: abc-123-def
# X-RateLimit-Remaining: 99
# X-Custom-Token: xyz789

###

### Use captured headers
GET https://api.example.com/other-endpoint
X-Original-Request-ID: {{apiCall.response.headers.X-Request-ID}}
X-Rate-Status: {{apiCall.response.headers.X-RateLimit-Remaining}}
Authorization: Bearer {{apiCall.response.headers.X-Custom-Token}}
```

**Note:** Header names are **case-insensitive** when referencing.

#### Complete Workflow Example

```http
@baseUrl = https://api.example.com

### 1. Authenticate and get token
# @name auth
POST {{baseUrl}}/oauth/token
Content-Type: application/x-www-form-urlencoded

grant_type=client_credentials
&client_id=my-client-id
&client_secret=my-client-secret

###

### 2. Create a resource
# @name createResource
POST {{baseUrl}}/api/resources
Authorization: Bearer {{auth.response.body.access_token}}
Content-Type: application/json

{
  "name": "Test Resource",
  "type": "document"
}

###

### 3. Upload file to the resource
# @name uploadFile
POST {{baseUrl}}/api/resources/{{createResource.response.body.id}}/files
Authorization: Bearer {{auth.response.body.access_token}}
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="file"; filename="document.pdf"
Content-Type: application/pdf

< ./document.pdf
------WebKitFormBoundary--

###

### 4. Verify upload
GET {{baseUrl}}/api/resources/{{createResource.response.body.id}}/files/{{uploadFile.response.body.fileId}}
Authorization: Bearer {{auth.response.body.access_token}}

###

### 5. Update resource metadata
PUT {{baseUrl}}/api/resources/{{createResource.response.body.id}}
Authorization: Bearer {{auth.response.body.access_token}}
Content-Type: application/json

{
  "name": "Updated Resource",
  "fileCount": {{uploadFile.response.body.totalFiles}},
  "lastModified": "{{$datetime iso8601}}"
}

###

### 6. Cleanup - Delete the resource
DELETE {{baseUrl}}/api/resources/{{createResource.response.body.id}}
Authorization: Bearer {{auth.response.body.access_token}}
```

### Important Notes About Request Chaining

‚ö†Ô∏è **Manual execution required**: You must manually execute the named request (e.g., `login`) before its response can be referenced in other requests.

‚ö†Ô∏è **Error handling**: If a JSONPath/XPath cannot be resolved, the plain text of the variable reference will be sent instead. Check the VS Code diagnostics panel for warnings.

‚úÖ **Hover for values**: Hover over request variable references in VS Code to see the resolved value (after the named request has been executed).

‚úÖ **IntelliSense support**: VS Code provides auto-completion for request variable names after typing `{{`.

‚úÖ **Highest priority**: Request variables have the highest priority in variable resolution, overriding file and environment variables with the same name.

### Organizing Multiple Request Files

While variables cannot be shared between `.http` files, you can organize your API tests effectively:

**Option 1: Feature-based organization**
```
project/
‚îú‚îÄ‚îÄ .vscode/
‚îÇ   ‚îî‚îÄ‚îÄ settings.json          # Shared environment variables
‚îú‚îÄ‚îÄ api/
‚îÇ   ‚îú‚îÄ‚îÄ auth.http             # Authentication flows
‚îÇ   ‚îú‚îÄ‚îÄ users.http            # User management
‚îÇ   ‚îú‚îÄ‚îÄ products.http         # Product operations
‚îÇ   ‚îî‚îÄ‚îÄ orders.http           # Order processing
‚îî‚îÄ‚îÄ .env                       # Local environment variables
```

**Option 2: Environment-based organization**
```
project/
‚îú‚îÄ‚îÄ .vscode/
‚îÇ   ‚îî‚îÄ‚îÄ settings.json          # All environment configs
‚îú‚îÄ‚îÄ tests/
‚îÇ   ‚îú‚îÄ‚îÄ common.http           # Requests used in all envs
‚îÇ   ‚îú‚îÄ‚îÄ development.http      # Dev-specific tests
‚îÇ   ‚îú‚îÄ‚îÄ staging.http          # Staging tests
‚îÇ   ‚îî‚îÄ‚îÄ production.http       # Prod smoke tests
‚îî‚îÄ‚îÄ .env                       # Local overrides
```

**Sharing configuration across files:**
- ‚úÖ Use `.vscode/settings.json` for variables needed in multiple files
- ‚úÖ Use consistent naming conventions across files
- ‚úÖ Document required variables in a README
- ‚ùå Cannot import or reference variables from other `.http` files

#### Method 2: File Variables (Inline in Same File)

Define variables directly in your `.http` file using the `@variable = value` syntax:



### File Uploads

```http
### Upload file
POST {{baseUrl}}/upload
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary7MA4YWxkTrZu0gW

------WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name="file"; filename="test.txt"
Content-Type: text/plain

< ./test.txt
------WebKitFormBoundary7MA4YWxkTrZu0gW--
```

### cURL Integration

The REST Client extension provides seamless integration with cURL, allowing you to import cURL commands or export your HTTP requests as cURL commands. This bidirectional conversion makes it easy to work with both formats.

#### Converting cURL to HTTP Files

You can paste cURL commands directly into your HTTP files, and the REST Client will understand and execute them:

```http
### Direct cURL command in HTTP file
curl -X POST https://api.example.com/items \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer {{token}}" \
  -d '{"name": "Test Item", "description": "Created from cURL"}'
```

**Alternative syntax** - Convert cURL to standard HTTP format:

```http
### Converted from cURL
POST https://api.example.com/items
Content-Type: application/json
Authorization: Bearer {{token}}

{
  "name": "Test Item",
  "description": "Created from cURL"
}
```

#### Exporting HTTP Requests as cURL

Right-click on any HTTP request in your file and select **"Copy Request as cURL"** to get the equivalent cURL command. This is useful for:

- Sharing requests with team members who prefer command line
- Running requests in CI/CD pipelines
- Debugging requests in terminal environments
- Documentation that requires cURL examples

**Example export result:**

```bash
curl --request POST \
  --url https://api.example.com/items \
  --header 'Content-Type: application/json' \
  --header 'Authorization: Bearer your-token-here' \
  --data '{
  "name": "Test Item",
  "description": "Created from HTTP file"
}'
```

#### Using Variables with cURL

Variables defined in your HTTP files work seamlessly with both HTTP syntax and cURL commands:

```http
@baseUrl = https://api.example.com
@authToken = Bearer abc123

### Using variables in cURL command
curl -X GET "{{baseUrl}}/items" \
  -H "Authorization: {{authToken}}"

### Same request in HTTP syntax
GET {{baseUrl}}/items
Authorization: {{authToken}}
```

#### Advanced cURL Features Support

The REST Client supports most cURL features including:

**File uploads:**
```http
curl -X POST "{{baseUrl}}/upload" \
  -F "file=@./document.pdf" \
  -F "description=Important document"
```

**Custom headers and authentication:**
```http
curl -X GET "{{baseUrl}}/secure-data" \
  -H "X-API-Key: {{apiKey}}" \
  -H "User-Agent: MyApp/1.0" \
  --basic -u "{{username}}:{{password}}"
```

**Following redirects and handling cookies:**
```http
curl -X POST "{{baseUrl}}/login" \
  -L \
  -c cookies.txt \
  -d "username={{user}}&password={{pass}}"
```

#### Supported cURL Options

The REST Client supports these commonly used cURL options:

| cURL Option | Description | HTTP File Equivalent |
|-------------|-------------|---------------------|
| `-X, --request` | HTTP method | `GET`, `POST`, `PUT`, etc. |
| `-H, --header` | Custom headers | Header lines below method |
| `-d, --data` | Request body data | Body section after empty line |
| `-F, --form` | Form data | `Content-Type: multipart/form-data` |
| `-u, --user` | Basic authentication | `Authorization: Basic` header |
| `-b, --cookie` | Send cookies | `Cookie:` header |
| `-c, --cookie-jar` | Save cookies | Automatic cookie handling |
| `-L, --location` | Follow redirects | Automatic redirect following |
| `-k, --insecure` | Skip SSL verification | REST Client settings |
| `-v, --verbose` | Verbose output | Response details panel |

#### Benefits of cURL Integration

1. **Flexibility**: Use whichever syntax you prefer - HTTP or cURL
2. **Team Compatibility**: Easily share between HTTP file users and cURL users
3. **CI/CD Integration**: Export requests for use in automated pipelines
4. **Legacy Support**: Import existing cURL-based documentation and scripts
5. **Learning Bridge**: Helps transition between command-line and GUI-based API testing

#### Best Practices for cURL Integration

- **Use variables**: Keep cURL commands maintainable with variable substitution
- **Document both formats**: Provide both HTTP and cURL examples in team documentation
- **Consistent formatting**: Use line continuation (`\`) for readable multi-line cURL commands
- **Environment awareness**: Ensure variables work correctly when exporting to cURL
- **Security**: Be cautious when sharing exported cURL commands that might contain sensitive data


## Benefits Over Postman

1. **Lightweight**: No need for a separate application
2. **Version Control**: Store API tests alongside your code
3. **Easy Sharing**: Share requests as simple text files
4. **Environment Integration**: Works directly in your development environment
5. **Text-based**: Easy to review changes in pull requests

## üîê Azure AD Authentication for Protected APIs

When your API is protected by Azure AD authentication, you need to obtain an access token before making requests. Here are several approaches using HTTP files:

### Method 1: Client Credentials Flow (Service-to-Service)

For service-to-service authentication using client credentials:

```http
### Variables for Azure AD
@tenantId = b92a****-****-****-****-************
@clientId = 7cb9****-****-****-****-************
@clientSecret = your-client-secret-here
@scope = api://{{clientId}}/.default
@baseUrl = https://your-api-domain.com

### Get Azure AD Token (Client Credentials)
# @name getToken
POST https://login.microsoftonline.com/{{tenantId}}/oauth2/v2.0/token
Content-Type: application/x-www-form-urlencoded

grant_type=client_credentials
&client_id={{clientId}}
&client_secret={{clientSecret}}
&scope={{scope}}

### Use the token to call protected API
GET {{baseUrl}}/api/protected-endpoint
Authorization: Bearer {{getToken.response.body.access_token}}
```

### Method 2: Authorization Code Flow with PKCE (Interactive)

For user authentication scenarios where you need to authenticate as a specific user rather than as an application.

**What is PKCE?**

- **PKCE** (Proof Key for Code Exchange, pronounced "pixie") is a security extension for OAuth 2.0
- Protects against authorization code interception attacks
- Essential for public clients (SPAs, mobile apps) that can't securely store secrets
- Uses a dynamically generated code verifier/challenge pair for enhanced security

**Why "Interactive"?**

- Requires manual user interaction (opening browser, logging in, copying authorization code)
- Cannot be fully automated like client credentials flow
- Suitable for testing user-specific API endpoints that require delegated permissions

```http
### Step 1: Generate PKCE parameters (manual)
# Generate a code verifier (random string 43-128 chars): 
# Example: dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk
@codeVerifier = dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk
# Code challenge (SHA256 base64url of verifier): 
# Example: E9Melhoa2OwvFrEMTJguCHaoeK1t8URWbuGJSstw-cM
@codeChallenge = E9Melhoa2OwvFrEMTJguCHaoeK1t8URWbuGJSstw-cM

### Step 2: Generate Authorization URL (paste in browser)
# Manual step: Open this URL in browser, log in, and copy the authorization code from redirect
# https://login.microsoftonline.com/{{tenantId}}/oauth2/v2.0/authorize?client_id={{clientId}}&response_type=code&redirect_uri=http://localhost:8080/signin-oidc&response_mode=query&scope={{scope}}&state=12345&code_challenge={{codeChallenge}}&code_challenge_method=S256

### Step 3: Exchange authorization code for token
# @name getTokenFromCode
POST https://login.microsoftonline.com/{{tenantId}}/oauth2/v2.0/token
Content-Type: application/x-www-form-urlencoded

grant_type=authorization_code
&client_id={{clientId}}
&code=PASTE_AUTHORIZATION_CODE_HERE
&redirect_uri=http://localhost:8080/signin-oidc
&scope={{scope}}
&code_verifier={{codeVerifier}}

### Use the token to call protected API
GET {{baseUrl}}/api/protected-endpoint
Authorization: Bearer {{getTokenFromCode.response.body.access_token}}
```

**Security Benefits of PKCE:**

- **No client secret required**: Safer for public clients
- **Dynamic verification**: Each flow uses unique verifier/challenge pairs  
- **Interception protection**: Even if authorization code is stolen, it's useless without the code verifier
- **Recommended practice**: Microsoft recommends PKCE for all OAuth flows, even confidential clients

### Method 3: Using REST Client's Built-in Azure AD Support

The REST Client extension has built-in support for Azure AD:

```http
### Using system variable for Azure AD token
@tenantId = b92a****-****-****-****-************
@clientId = 7cb9****-****-****-****-************

### Call protected API with automatic token
GET {{baseUrl}}/api/protected-endpoint
Authorization: Bearer {{$aadToken tenantId clientId}}
```

### Method 4: Environment-Specific Configuration

Create environment-specific configurations in VS Code settings:

**In `.vscode/settings.json`:**

```json
{
  "rest-client.environmentVariables": {
    "development": {
      "baseUrl": "https://localhost:7001",
      "tenantId": "b92a****-****-****-****-************",
      "clientId": "7cb9****-****-****-****-************",
      "clientSecret": "dev-client-secret"
    },
    "production": {
      "baseUrl": "https://api.production.com",
      "tenantId": "b92a****-****-****-****-************",
      "clientId": "7cb9****-****-****-****-************",
      "clientSecret": "prod-client-secret"
    }
  }
}
```

**Then use in your HTTP file:**

```http
### Get token for current environment
# @name getEnvToken
POST https://login.microsoftonline.com/{{tenantId}}/oauth2/v2.0/token
Content-Type: application/x-www-form-urlencoded

grant_type=client_credentials
&client_id={{clientId}}
&client_secret={{clientSecret}}
&scope=api://{{clientId}}/.default

### Call API with environment-specific token
GET {{baseUrl}}/api/data
Authorization: Bearer {{getEnvToken.response.body.access_token}}
```

### Method 5: Token Refresh Pattern

Handle token expiration with refresh tokens:

```http
### Initial authentication
# @name initialAuth
POST https://login.microsoftonline.com/{{tenantId}}/oauth2/v2.0/token
Content-Type: application/x-www-form-urlencoded

grant_type=authorization_code
&client_id={{clientId}}
&code=AUTHORIZATION_CODE_HERE
&redirect_uri=http://localhost:8080/signin-oidc
&scope={{scope}}

### Refresh token when needed
# @name refreshAuth
POST https://login.microsoftonline.com/{{tenantId}}/oauth2/v2.0/token
Content-Type: application/x-www-form-urlencoded

grant_type=refresh_token
&client_id={{clientId}}
&refresh_token={{initialAuth.response.body.refresh_token}}
&scope={{scope}}

### Use current valid token
GET {{baseUrl}}/api/secure-data
Authorization: Bearer {{refreshAuth.response.body.access_token}}
```

### Security Best Practices

1. **Never commit secrets**: Use environment variables or VS Code settings for sensitive data
2. **Token expiration**: Check `expires_in` field and refresh tokens appropriately
3. **Scope principle**: Request only the minimum required scopes
4. **HTTPS only**: Always use HTTPS for token requests
5. **Secure storage**: Store tokens securely and clear them when done

### Common Token Response Structure

Azure AD token responses typically include:

```json
{
  "access_token": "eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIs...",
  "token_type": "Bearer",
  "expires_in": 3599,
  "refresh_token": "0.ARcA6KAC2wDFZEOPiD...",
  "scope": "access_as_user"
}
```

You can reference these values in subsequent requests:

- `{{tokenRequest.response.body.access_token}}`
- `{{tokenRequest.response.body.expires_in}}`
- `{{tokenRequest.response.body.refresh_token}}`

## üìö References

1. [REST Client Extension Documentation](https://marketplace.visualstudio.com/items?itemName=humao.rest-client)  
   Official documentation from the extension author that provides detailed instructions on how to use the REST Client extension, including all available features and syntax options. Essential reading for understanding the full capabilities of the extension.

2. [VS Code REST Client GitHub Repository](https://github.com/Huachao/vscode-restclient)  
   The source repository contains examples, issue tracking, and the latest development updates for the extension. Useful for understanding the implementation details, finding solutions to common problems, and tracking feature requests.

3. [GitHub Issue #845: Support for including variables from separate files](https://github.com/Huachao/vscode-restclient/issues/845)  
   This open issue discusses the requested feature for importing variables from external files using `< ./file.http` syntax. Important for understanding current limitations and why file imports are not supported in the REST Client extension.

4. [Microsoft .http Files Documentation](https://learn.microsoft.com/en-us/aspnet/core/test/http-files?view=aspnetcore-9.0)  
   Microsoft's official documentation for .http files in Visual Studio and Visual Studio Code. Provides an alternative perspective on HTTP file usage, particularly useful for ASP.NET Core developers who want to understand Microsoft's implementation and recommendations.

5. [HTTP/1.1 Specification (RFC 7230-7235)](https://datatracker.ietf.org/doc/html/rfc7230)  
   The official HTTP protocol specification that defines the syntax and semantics of HTTP/1.1 messages. Understanding this specification helps write more accurate and standard-compliant HTTP requests and troubleshoot protocol-level issues.

6. [OAuth 2.0 Authorization Framework (RFC 6749)](https://datatracker.ietf.org/doc/html/rfc6749)  
   The official OAuth 2.0 specification that defines the authorization framework used in the Azure AD authentication examples. Essential for understanding the security flows demonstrated in this guide.

7. [OAuth 2.0 for Public Clients (RFC 7636) - PKCE](https://datatracker.ietf.org/doc/html/rfc7636)  
   The PKCE (Proof Key for Code Exchange) specification that extends OAuth 2.0 for enhanced security in public clients. Relevant for understanding the PKCE authentication flow examples provided in the Azure AD section.

8. [REST Client vs. Postman: A Comparative Analysis](https://blog.bitsrc.io/vs-code-extensions-for-testing-api-calls-e981ba65eeb4)  
   An in-depth comparison between REST Client and other API testing tools like Postman, highlighting the strengths and limitations of each approach. Helps developers choose the right tool for their workflow.

9. [Advanced HTTP Request Testing Patterns](https://medium.com/@walmyrlimaesilv/vs-code-how-to-make-http-rest-api-requests-inside-visual-studio-code-a325a26aaed6)  
   This guide covers advanced patterns for organizing and automating API tests using HTTP files, including environment management and test sequencing. Provides practical examples for complex testing scenarios.

10. [Environment Variables in REST Client](https://github.com/Huachao/vscode-restclient/blob/master/README.md#environment-variables)  
    A specific guide on how to use environment variables in REST Client, which is crucial for managing different environments (development, testing, production) in your API tests. Direct reference to the official implementation details.

11. [cURL Manual and Documentation](https://curl.se/docs/manual.html)  
    Comprehensive documentation for cURL command-line tool. Relevant for understanding the cURL integration features demonstrated in this guide and for users transitioning between HTTP files and command-line tools.

12. [Azure Active Directory v2.0 Protocols](https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-protocols)  
    Microsoft's documentation on Azure AD authentication protocols and endpoints. Essential reference for implementing the Azure AD authentication examples shown in this guide, including client credentials and PKCE flows.

## üìé Appendixes

### Appendix A: REST Client Main Features

| Feature Category | Feature | Purpose | How to Use |
|------------------|---------|---------|------------|
| **Request Execution** | Send/Cancel/Rerun HTTP request | Execute HTTP requests directly in editor and view responses | Click "Send Request" link above request or use Ctrl+Alt+R |
| **Request Execution** | View response in separate pane | Display formatted response with syntax highlighting | Response automatically appears in split pane after execution |
| **GraphQL Support** | Send GraphQL queries | Execute GraphQL operations with variable support | Write GraphQL query in request body with variables section |
| **cURL Integration** | Send cURL commands | Convert and execute cURL commands directly | Paste cURL command in .http file or copy request as cURL |
| **History Management** | Auto save request history | Keep track of all executed requests | Access via command palette "Rest Client: Request History" |
| **Multi-Request Files** | Compose multiple requests | Organize related API calls in single file | Separate requests with `###` delimiter |
| **Response Handling** | View image responses | Display images directly in response pane | Automatic for image content types |
| **Response Handling** | Save responses to disk | Export response data for further analysis | Right-click response pane and select save options |
| **Response Formatting** | Fold/unfold response body | Collapse/expand response sections | Click fold/unfold icons in response pane |
| **Response Formatting** | Customize response font | Adjust readability of response display | Configure in VS Code settings under Rest Client |
| **Response Filtering** | Preview specific response parts | Show only headers, body, or full response | Use response tabs (Headers/Body/Full) |
| **Authentication** | Basic Auth support | Simple username/password authentication | Add `Authorization: Basic base64(user:pass)` header |
| **Authentication** | Digest Auth support | More secure challenge-response authentication | Handled automatically when server requests digest auth |
| **Authentication** | SSL Client Certificates | Certificate-based authentication | Configure in settings with certificate paths |
| **Authentication** | Azure AD integration | Microsoft identity platform authentication | Use `{{$aadToken}}` system variable |
| **Authentication** | AWS Signature v4 | AWS service authentication | Configure AWS credentials and use signature headers |
| **Variables** | Environment variables | Manage different deployment environments | Define in `.vscode/settings.json` or environment files |
| **Variables** | Custom variables | Reusable values throughout requests | Define with `@variableName = value` syntax |
| **Variables** | System variables | Built-in dynamic values | Use `{{$guid}}`, `{{$timestamp}}`, etc. |
| **Variables** | Prompt variables | Interactive input during execution | Define with `@variable = {{$prompt variableName}}` |
| **Variables** | Auto-completion | IntelliSense for variables | Start typing `{{` to see available variables |
| **Variables** | Variable diagnostics | Error detection for undefined variables | Red underlines for missing variables |
| **Variables** | Go to definition | Navigate to variable declarations | Ctrl+click on variable usage |
| **System Variables** | GUID generation | Generate unique identifiers | `{{$guid}}` |
| **System Variables** | Random integers | Generate random numbers in range | `{{$randomInt min max}}` |
| **System Variables** | Timestamps | Current timestamp in various formats | `{{$timestamp}}`, `{{$datetime}}` |
| **System Variables** | Environment access | Access system environment variables | `{{$processEnv variableName}}` |
| **System Variables** | Dotenv support | Load variables from .env files | `{{$dotenv variableName}}` |
| **Environment Management** | Environment switching | Switch between dev/test/prod configs | Use environment selector in status bar |
| **Environment Management** | Shared environments | Common variables across environments | Define in shared environment section |
| **Code Generation** | Generate code snippets | Convert requests to various languages | Right-click request and select "Generate Code Snippet" |
| **Session Management** | Cookie persistence | Maintain session across requests | Automatic cookie handling between requests |
| **Network** | Proxy support | Route requests through proxy servers | Configure proxy settings in VS Code |
| **SOAP Support** | SOAP request support | Send SOAP web service requests | Use SOAP envelope templates and snippets |
| **Language Support** | HTTP syntax highlighting | Color-coded request and response syntax | Automatic for .http and .rest files |
| **Language Support** | Auto-completion | IntelliSense for HTTP methods, headers | Start typing to see suggestions |
| **Language Support** | Comment support | Document requests with comments | Lines starting with `#` or `//` |
| **Language Support** | JSON/XML formatting | Auto-indent and format request bodies | Automatic formatting for structured data |
| **Language Support** | Code snippets | Quick templates for common requests | Type snippet name and press Tab |
| **Navigation** | Symbol navigation | Jump to variable definitions | Use Go to Definition (F12) |
| **Navigation** | CodeLens integration | Actionable links above requests | Click "Send Request" link |
| **Editor Features** | Request folding | Collapse/expand request blocks | Click fold icons or use Ctrl+Shift+[ |
| **Markdown Integration** | Fenced code blocks | HTTP requests in markdown files | Use ```http code blocks