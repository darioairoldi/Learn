---
title: "How to Create MCP Servers for GitHub Copilot"
author: "Dario Airoldi"
date: "2026-01-20"
categories: [tech, prompt-engineering, github-copilot, mcp]
description: "Learn how to build custom Model Context Protocol (MCP) servers that extend GitHub Copilot with new tools, resources, and integrations using TypeScript, C#, or Python."
---

# How to Create MCP Servers for GitHub Copilot

The <mark>**Model Context Protocol (MCP)**</mark> enables you to extend GitHub Copilot with <mark>custom tools, resources, and integrations</mark> that go far beyond what's possible with prompts, agents, or skills alone.  
While the previous articles in this series covered **consuming** Copilot customizations, this article focuses on **creating** your own MCP serversâ€”building the server-side components that provide new capabilities to Copilot Chat.

This article covers MCP server architecture, implementation patterns in TypeScript, C#, and Python, and best practices for debugging and deployment.

## Table of Contents

- [ğŸ¯ Understanding MCP servers](#-understanding-mcp-servers)
- [ğŸ—ï¸ MCP server architecture](#ï¸-mcp-server-architecture)
- [ğŸ”§ Building tools](#-building-tools)
- [ğŸ“¦ Building resources](#-building-resources)
- [ğŸ’» Implementation: TypeScript](#-implementation-typescript)
- [ğŸ’» Implementation: C# (.NET)](#-implementation-c-net)
- [ğŸ’» Implementation: Python](#-implementation-python)
- [âš™ï¸ Configuration and registration](#ï¸-configuration-and-registration)
- [ğŸ§ª Testing and debugging](#-testing-and-debugging)
- [ğŸš€ Deployment patterns](#-deployment-patterns)
- [âš ï¸ Common pitfalls](#ï¸-common-pitfalls)
- [ğŸ’¡ Decision framework](#-decision-framework)
- [ğŸ¯ Conclusion](#-conclusion)
- [ğŸ“š References](#-references)

# ğŸ¯ Understanding MCP servers

## What is the Model Context Protocol?

<mark>**MCP (Model Context Protocol)**</mark> is an open standard that defines how AI assistants communicate with external tools and data sources. Think of it as a <mark>**universal adapter**</mark>â€”rather than building custom integrations for each AI assistant, you build one MCP server that works with any MCP-compatible client.

### Key concepts

| Concept | Description |
|---------|-------------|
| **<mark>MCP Server</mark>** | A process that provides tools, resources, and prompts to AI clients |
| **<mark>MCP Client</mark>** | An AI assistant (like <mark>Copilot</mark>) that connects to servers to access capabilities |
| **<mark>Tools</mark>** | <mark>Functions</mark> the AI can call to perform actions (query databases, call APIs, etc.) |
| **<mark>Resources</mark>** | <mark>Data sources</mark> the AI can read (files, configurations, live data) |
| **<mark>Prompts</mark>** | Reusable prompt templates exposed by the server |
| **<mark>Transport</mark>** | Communication channel (stdio, SSE/HTTP) between client and server |

### MCP vs other customization types

| Feature | MCP Servers | Skills | Agents | Prompts |
|---------|-------------|--------|--------|---------|
| **<mark>Purpose</mark>** | Add <mark>tools</mark> and <mark>data sources</mark> | Bundle workflows with resources | Define AI personas | Define reusable tasks |
| **<mark>Scope</mark>** | Unlimited (any integration) | File-based workflows | Chat session behavior | Single task execution |
| **<mark>Language</mark>** | Any (<mark>TypeScript</mark>, <mark>C#</mark>, <mark>Python</mark>, etc.) | Markdown only | Markdown only | Markdown only |
| **<mark>Complexity</mark>** | High (full programming) | Medium (folder structure) | Low (single file) | Low (single file) |
| **<mark>Capabilities</mark>** | Call APIs, query DBs, execute code | Read files, run scripts | Control tools, handoff | Variable substitution |
| **<mark>Cross-platform</mark>** | âœ… Any MCP client | âœ… VS Code, CLI, coding agent | âŒ VS Code only | âŒ VS Code only |

### When to build an MCP server

**âœ… Build an MCP server when you need to:**

- <mark>**Query external systems**</mark> â€” Databases, APIs, internal services
- <mark>**Perform complex computations**</mark> â€” Data processing, analysis, transformations
- <mark>**Access live data**</mark> â€” Real-time metrics, monitoring, dashboards
- <mark>**Enforce business logic**</mark> â€” Validation rules, compliance checks
- <mark>**Integrate proprietary tools**</mark> â€” Internal tooling, legacy systems
- <mark>**Share capabilities across projects**</mark> â€” Reusable tooling for teams

**âŒ Don't build an MCP server when:**

- A prompt file can accomplish the task
- You only need to define coding standards (use instruction files)
- You only need to bundle scripts with instructions (use skills)
- The existing built-in tools or community servers meet your needs

# ğŸ—ï¸ MCP server architecture

## Server lifecycle

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  1. INITIALIZATION                                              â”‚
â”‚  â”œâ”€â”€ Client discovers server (from mcp.json configuration)     â”‚
â”‚  â”œâ”€â”€ Client spawns server process                               â”‚
â”‚  â””â”€â”€ Server sends capabilities (tools, resources, prompts)      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
                 â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  2. CAPABILITY NEGOTIATION                                      â”‚
â”‚  â”œâ”€â”€ Client: "What can you do?"                                 â”‚
â”‚  â”œâ”€â”€ Server: Lists tools with JSON Schema definitions           â”‚
â”‚  â””â”€â”€ Server: Lists resources and prompt templates               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
                 â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  3. RUNTIME OPERATION                                           â”‚
â”‚  â”œâ”€â”€ Client sends tool invocation requests                      â”‚
â”‚  â”œâ”€â”€ Server executes tool logic                                 â”‚
â”‚  â”œâ”€â”€ Server returns structured results                          â”‚
â”‚  â””â”€â”€ (Repeat for each tool call)                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
                 â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  4. SHUTDOWN                                                    â”‚
â”‚  â””â”€â”€ Client terminates server process                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Transport options

MCP supports two primary transport mechanisms:

| Transport | Use Case | Pros | Cons |
|-----------|----------|------|------|
| **stdio** | Local servers | Simple, secure, fast | Single client only |
| **SSE/HTTP** | Remote servers | Multiple clients, network accessible | Requires authentication |

<mark>**For GitHub Copilot integration, stdio is the default and recommended transport**</mark>. The client spawns your server as a subprocess and communicates via stdin/stdout.

## Message format

MCP uses JSON-RPC 2.0 for all communication:

```json
// Tool invocation request (client â†’ server)
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "tools/call",
  "params": {
    "name": "query_database",
    "arguments": {
      "table": "users",
      "filter": "active = true"
    }
  }
}

// Tool result response (server â†’ client)
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "content": [
      {
        "type": "text",
        "text": "Found 42 active users..."
      }
    ]
  }
}
```

# ğŸ”§ Building tools

Tools are the primary way MCP servers provide functionality to AI clients. Each tool has:

1. **Name** â€” Unique identifier (e.g., `query_database`)
2. **Description** â€” What the tool does (helps AI decide when to use it)
3. **Input Schema** â€” JSON Schema defining required and optional parameters
4. **Handler** â€” Function that executes when the tool is called

## Tool definition anatomy

```typescript
// TypeScript example - tool definition
{
  name: "validate_yaml",
  description: "Validates a YAML string and returns any syntax errors",
  inputSchema: {
    type: "object",
    properties: {
      content: {
        type: "string",
        description: "The YAML content to validate"
      },
      strict: {
        type: "boolean",
        description: "Enable strict validation mode",
        default: false
      }
    },
    required: ["content"]
  }
}
```

## Tool design best practices

### 1. Write <mark>descriptive descriptions</mark>

The AI uses your description to decide when to call your tool. Be specific about:
- What the tool does
- When to use it (and when not to)
- What inputs it expects
- What outputs it returns

```typescript
// âŒ Vague description
description: "Validates content"

// âœ… Specific description
description: "Validates YAML syntax and structure. Use this when checking " +
             "configuration files, CI/CD workflows, or any YAML content for " +
             "syntax errors. Returns detailed error messages with line numbers."
```

### 2. Design <mark>focused</mark>, <mark>single-purpose tools</mark>

Each tool should do one thing well. If you're tempted to add an `action` parameter, split into multiple tools instead.

```typescript
// âŒ Multi-purpose tool
{
  name: "file_operations",
  inputSchema: {
    properties: {
      action: { enum: ["read", "write", "delete", "list"] },
      path: { type: "string" }
    }
  }
}

// âœ… Focused tools
{ name: "read_file", ... }
{ name: "write_file", ... }
{ name: "delete_file", ... }
{ name: "list_directory", ... }
```

### 3. Use proper <mark>JSON Schema for validation</mark>

Leverage JSON Schema features to ensure valid inputs:

```typescript
inputSchema: {
  type: "object",
  properties: {
    email: {
      type: "string",
      format: "email",
      description: "User's email address"
    },
    age: {
      type: "integer",
      minimum: 0,
      maximum: 150
    },
    role: {
      type: "string",
      enum: ["admin", "user", "guest"]
    }
  },
  required: ["email"],
  additionalProperties: false
}
```

### 4. Return <mark>structured, actionable results</mark>

```typescript
// âŒ Unstructured result
return { content: [{ type: "text", text: "Error occurred" }] };

// âœ… Structured, actionable result
return {
  content: [{
    type: "text",
    text: JSON.stringify({
      success: false,
      error: {
        code: "VALIDATION_FAILED",
        message: "Invalid YAML syntax",
        line: 42,
        column: 15,
        suggestion: "Check for missing colon after key name"
      }
    }, null, 2)
  }]
};
```

# ğŸ“¦ Building resources

Resources provide read-only data that the AI can access. Unlike tools (which perform actions), resources expose information.

## Resource types

| Type | URI Pattern | Example |
|------|-------------|---------|
| **Static** | Fixed URI | `config://settings` |
| **Template** | Parameterized URI | `file://{path}` |
| **Dynamic** | Generated at runtime | `metrics://cpu-usage` |

## Resource definition

```typescript
{
  uri: "config://validation-rules",
  name: "Validation Rules",
  description: "Current validation configuration and thresholds",
  mimeType: "application/json"
}
```

# ğŸ’» Implementation: <mark>TypeScript</mark>

TypeScript/Node.js is the most common language for MCP servers, with excellent SDK support.

## Setup

```bash
# Create new project
mkdir my-mcp-server && cd my-mcp-server
npm init -y

# Install dependencies
npm install @modelcontextprotocol/sdk
npm install -D typescript @types/node

# Initialize TypeScript
npx tsc --init
```

## Basic server structure

```typescript
// src/index.ts
import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import {
  CallToolRequestSchema,
  ListToolsRequestSchema,
} from "@modelcontextprotocol/sdk/types.js";

// Create server instance
const server = new Server(
  {
    name: "my-mcp-server",
    version: "1.0.0",
  },
  {
    capabilities: {
      tools: {},
    },
  }
);

// Define available tools
server.setRequestHandler(ListToolsRequestSchema, async () => {
  return {
    tools: [
      {
        name: "greet",
        description: "Generates a greeting message for the given name",
        inputSchema: {
          type: "object",
          properties: {
            name: {
              type: "string",
              description: "Name of the person to greet",
            },
          },
          required: ["name"],
        },
      },
    ],
  };
});

// Handle tool calls
server.setRequestHandler(CallToolRequestSchema, async (request) => {
  const { name, arguments: args } = request.params;

  if (name === "greet") {
    const personName = args?.name as string;
    return {
      content: [
        {
          type: "text",
          text: `Hello, ${personName}! Welcome to MCP.`,
        },
      ],
    };
  }

  throw new Error(`Unknown tool: ${name}`);
});

// Start server with stdio transport
async function main() {
  const transport = new StdioServerTransport();
  await server.connect(transport);
  console.error("MCP server running on stdio");
}

main().catch(console.error);
```

## Build and run

```json
// package.json
{
  "name": "my-mcp-server",
  "version": "1.0.0",
  "type": "module",
  "main": "dist/index.js",
  "scripts": {
    "build": "tsc",
    "start": "node dist/index.js"
  }
}
```

```json
// tsconfig.json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "NodeNext",
    "moduleResolution": "NodeNext",
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true
  },
  "include": ["src/**/*"]
}
```

# ğŸ’» Implementation: <mark>C#</mark> (<mark>.NET</mark>)

C# provides strong typing and <mark>excellent performance</mark> for MCP servers.

## Setup

```bash
# Create new console project
dotnet new console -n MyMcpServer
cd MyMcpServer

# Add MCP SDK (community package)
dotnet add package ModelContextProtocol
```

## Basic server structure

```csharp
// Program.cs
using ModelContextProtocol;
using ModelContextProtocol.Server;
using System.Text.Json;

var builder = McpServerBuilder.Create(args);

builder.WithServerInfo("my-mcp-server", "1.0.0");

// Register tools
builder.WithTool(
    name: "greet",
    description: "Generates a greeting message for the given name",
    inputSchema: new
    {
        type = "object",
        properties = new
        {
            name = new
            {
                type = "string",
                description = "Name of the person to greet"
            }
        },
        required = new[] { "name" }
    },
    handler: async (args, cancellationToken) =>
    {
        var name = args.GetProperty("name").GetString();
        return new ToolResult
        {
            Content = new[]
            {
                new TextContent { Text = $"Hello, {name}! Welcome to MCP." }
            }
        };
    }
);

var server = builder.Build();
await server.RunAsync();
```

## Alternative: <mark>Attribute-based tools</mark>

```csharp
// Tools/GreetingTools.cs
using ModelContextProtocol;

public class GreetingTools
{
    [McpTool("greet", "Generates a greeting message for the given name")]
    public string Greet(
        [McpParameter("Name of the person to greet")] string name)
    {
        return $"Hello, {name}! Welcome to MCP.";
    }

    [McpTool("farewell", "Generates a farewell message")]
    public string Farewell(
        [McpParameter("Name of the person")] string name,
        [McpParameter("Optional custom message", Required = false)] string? message = null)
    {
        return message ?? $"Goodbye, {name}! See you soon.";
    }
}

// Program.cs
var builder = McpServerBuilder.Create(args);
builder.WithServerInfo("my-mcp-server", "1.0.0");
builder.WithToolsFromType<GreetingTools>();
var server = builder.Build();
await server.RunAsync();
```

# ğŸ’» Implementation: <mark>Python</mark>

Python offers quick prototyping and access to rich AI/ML libraries.

## Setup

```bash
# Create virtual environment
python -m venv venv
source venv/bin/activate  # or venv\Scripts\activate on Windows

# Install MCP SDK
pip install mcp
```

## Basic server structure

```python
# server.py
import asyncio
from mcp.server import Server
from mcp.server.stdio import stdio_server
from mcp.types import Tool, TextContent

# Create server instance
server = Server("my-mcp-server")

@server.list_tools()
async def list_tools() -> list[Tool]:
    """Return list of available tools."""
    return [
        Tool(
            name="greet",
            description="Generates a greeting message for the given name",
            inputSchema={
                "type": "object",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "Name of the person to greet"
                    }
                },
                "required": ["name"]
            }
        )
    ]

@server.call_tool()
async def call_tool(name: str, arguments: dict) -> list[TextContent]:
    """Handle tool invocations."""
    if name == "greet":
        person_name = arguments.get("name", "World")
        return [
            TextContent(
                type="text",
                text=f"Hello, {person_name}! Welcome to MCP."
            )
        ]
    
    raise ValueError(f"Unknown tool: {name}")

async def main():
    """Run the server with stdio transport."""
    async with stdio_server() as (read_stream, write_stream):
        await server.run(read_stream, write_stream)

if __name__ == "__main__":
    asyncio.run(main())
```

## Entry point script

```python
# __main__.py
from .server import main
import asyncio

asyncio.run(main())
```

# âš™ï¸ Configuration and registration

## VS Code configuration

MCP servers are registered in VS Code's `settings.json` or workspace `.vscode/mcp.json`:

```json
// .vscode/mcp.json (workspace-level, recommended)
{
  "servers": {
    "my-server": {
      "type": "stdio",
      "command": "node",
      "args": ["${workspaceFolder}/mcp-servers/my-server/dist/index.js"]
    }
  }
}
```

```json
// settings.json (user-level)
{
  "github.copilot.chat.mcp.servers": {
    "my-server": {
      "type": "stdio",
      "command": "node",
      "args": ["/path/to/my-server/dist/index.js"]
    }
  }
}
```

## Configuration options

| Option | Description | Example |
|--------|-------------|---------|
| `type` | Transport type | `"stdio"` or `"sse"` |
| `command` | Executable to run | `"node"`, `"python"`, `"dotnet"` |
| `args` | Command arguments | `["dist/index.js"]` |
| `env` | Environment variables | `{ "API_KEY": "..." }` |
| `cwd` | Working directory | `"${workspaceFolder}"` |

## Environment variables

<mark>**Never hardcode secrets in your server code**</mark>. Use environment variables:

```json
// .vscode/mcp.json
{
  "servers": {
    "my-server": {
      "type": "stdio",
      "command": "node",
      "args": ["dist/index.js"],
      "env": {
        "DATABASE_URL": "${env:DATABASE_URL}",
        "API_KEY": "${env:MY_API_KEY}"
      }
    }
  }
}
```

# ğŸ§ª Testing and debugging

## MCP Inspector

The <mark>**MCP Inspector**</mark> is the primary debugging tool for MCP servers:

```bash
# Install globally
npm install -g @modelcontextprotocol/inspector

# Run your server through the inspector
mcp-inspector node dist/index.js
```

The inspector provides:
- Live message inspection (requests/responses)
- Tool testing interface
- Resource browser
- Protocol validation

## Logging strategies

Since MCP uses stdio for communication, <mark>**never write to stdout for debugging**</mark>. Use stderr instead:

```typescript
// TypeScript
console.error("Debug: Processing request...");

// Python
import sys
print("Debug: Processing request...", file=sys.stderr)

// C#
Console.Error.WriteLine("Debug: Processing request...");
```

## Unit testing tools

```typescript
// TypeScript example with Jest
describe("greet tool", () => {
  it("returns greeting with name", async () => {
    const result = await handleToolCall("greet", { name: "Alice" });
    
    expect(result.content[0].text).toContain("Hello, Alice");
  });

  it("handles missing name gracefully", async () => {
    await expect(handleToolCall("greet", {}))
      .rejects.toThrow("name is required");
  });
});
```

## Integration testing

```typescript
// Test full server lifecycle
describe("MCP Server", () => {
  let server: Server;
  let transport: TestTransport;

  beforeEach(async () => {
    transport = new TestTransport();
    server = createServer();
    await server.connect(transport);
  });

  it("lists tools correctly", async () => {
    const response = await transport.sendRequest({
      method: "tools/list",
      params: {}
    });
    
    expect(response.tools).toHaveLength(1);
    expect(response.tools[0].name).toBe("greet");
  });
});
```

# ğŸš€ Deployment patterns

## <mark>Local development</mark>

```
.vscode/
â”œâ”€â”€ mcp.json              # Server configuration
â””â”€â”€ settings.json         # Enable MCP

mcp-servers/
â””â”€â”€ my-server/
    â”œâ”€â”€ src/
    â”‚   â””â”€â”€ index.ts
    â”œâ”€â”€ dist/             # Compiled output
    â”œâ”€â”€ package.json
    â””â”€â”€ tsconfig.json
```

## <mark>Workspace distribution</mark>

Share servers with your team by including them in the repository:

```
.copilot/
â””â”€â”€ mcp-servers/
    â””â”€â”€ my-server/
        â”œâ”€â”€ dist/         # Pre-compiled binaries
        â””â”€â”€ package.json

.vscode/
â””â”€â”€ mcp.json              # Points to .copilot/mcp-servers/
```

## <mark>Publishing to MCP Registry</mark>

For public distribution, submit your server to the [MCP Registry](https://github.com/modelcontextprotocol/registry):

1. Ensure your server follows the [MCP specification](https://spec.modelcontextprotocol.io/)
2. Add comprehensive documentation
3. Include example configurations
4. Submit a pull request to the registry repository

# âš ï¸ Common pitfalls

## 1. Writing to stdout

<mark>**CRITICAL:**</mark> MCP uses stdout for protocol communication. Any debug output to stdout corrupts the protocol.

```typescript
// âŒ Breaks MCP protocol
console.log("Debug message");

// âœ… Use stderr for debugging
console.error("Debug message");
```

## 2. Synchronous blocking

Long-running operations block the entire server. Always use async patterns:

```typescript
// âŒ Blocks server
function processData(data: string): string {
  // Heavy synchronous processing
  return heavyComputation(data);
}

// âœ… Non-blocking
async function processData(data: string): Promise<string> {
  return await heavyComputationAsync(data);
}
```

## 3. Missing error handling

Unhandled errors crash the server. Wrap tool handlers in try-catch:

```typescript
server.setRequestHandler(CallToolRequestSchema, async (request) => {
  try {
    const result = await handleTool(request.params);
    return result;
  } catch (error) {
    return {
      content: [{
        type: "text",
        text: `Error: ${error.message}`
      }],
      isError: true
    };
  }
});
```

## 4. Vague tool descriptions

The AI relies on descriptions to decide when to use tools. Be specific:

```typescript
// âŒ AI doesn't know when to use this
description: "Processes data"

// âœ… Clear use case
description: "Validates JSON configuration files against a predefined schema. " +
             "Use when checking config.json, settings.json, or similar files. " +
             "Returns detailed validation errors with line numbers."
```

## 5. Overly complex input schemas

Keep inputs simple. If you need many parameters, consider splitting into multiple tools:

```typescript
// âŒ Too many parameters
inputSchema: {
  properties: {
    source: { type: "string" },
    destination: { type: "string" },
    format: { type: "string" },
    compression: { type: "boolean" },
    encryption: { type: "boolean" },
    encryptionKey: { type: "string" },
    // ... many more
  }
}

// âœ… Focused tool with sensible defaults
inputSchema: {
  properties: {
    source: { type: "string" },
    destination: { type: "string" }
  },
  required: ["source", "destination"]
}
```

# ğŸ’¡ Decision framework

Use this flowchart to decide if you need an MCP server:

```
Need to extend Copilot capabilities?
â”‚
â”œâ”€ Just coding standards/rules?
â”‚  â””â”€ Use instruction files (.instructions.md)
â”‚
â”œâ”€ Reusable task with user input?
â”‚  â””â”€ Use prompt files (.prompt.md)
â”‚
â”œâ”€ Persistent AI persona with tool restrictions?
â”‚  â””â”€ Use agent files (.agent.md)
â”‚
â”œâ”€ Cross-platform workflow with scripts/templates?
â”‚  â””â”€ Use skill files (SKILL.md)
â”‚
â”œâ”€ Need to call external APIs or databases?
â”‚  â””â”€ Build an MCP server âœ…
â”‚
â”œâ”€ Need real-time data access?
â”‚  â””â”€ Build an MCP server âœ…
â”‚
â”œâ”€ Need complex business logic?
â”‚  â””â”€ Build an MCP server âœ…
â”‚
â””â”€ Need to integrate proprietary systems?
   â””â”€ Build an MCP server âœ…
```

# ğŸ¯ Conclusion

Building MCP servers unlocks the full potential of GitHub Copilot by enabling:

- <mark>**Custom tool integrations**</mark> â€” Connect to any API, database, or service
- <mark>**Real-time data access**</mark> â€” Provide live metrics, logs, and status information
- <mark>**Business logic enforcement**</mark> â€” Implement validation, compliance, and domain rules
- <mark>**Cross-platform compatibility**</mark> â€” Work with any MCP-compatible AI assistant

**Key takeaways:**

1. **Start simple** â€” Build one tool, test it thoroughly, then expand
2. **Write clear descriptions** â€” The AI uses them to decide when to call your tools
3. **Use stderr for debugging** â€” Never write to stdout
4. **Handle errors gracefully** â€” Return structured error messages
5. **Test with MCP Inspector** â€” Verify protocol compliance before deployment

MCP servers are the most powerful way to extend Copilot, but they're also the most complex. Use the decision framework above to ensure you're choosing the right customization type for your needs.

# ğŸ“š References

**[Model Context Protocol Specification](https://spec.modelcontextprotocol.io/)** ğŸ“˜ [Official]  
The official MCP specification defining protocol messages, transports, and capabilities. Essential reading for understanding the protocol internals.

**[MCP TypeScript SDK](https://github.com/modelcontextprotocol/typescript-sdk)** ğŸ“˜ [Official]  
Official TypeScript/Node.js SDK for building MCP servers and clients. Includes examples and type definitions.

**[MCP Python SDK](https://github.com/modelcontextprotocol/python-sdk)** ğŸ“˜ [Official]  
Official Python SDK for building MCP servers. Provides async-first API design.

**[MCP Inspector](https://github.com/modelcontextprotocol/inspector)** ğŸ“˜ [Official]  
Debugging tool for MCP servers. Essential for development and troubleshooting.

**[MCP Server Registry](https://github.com/modelcontextprotocol/registry)** ğŸ“˜ [Official]  
Community registry of published MCP servers. Browse for inspiration or submit your own.

**[VS Code MCP Documentation](https://code.visualstudio.com/docs/copilot/chat/mcp-servers)** ğŸ“˜ [Official]  
VS Code-specific documentation for configuring and using MCP servers with GitHub Copilot.

---

## Related articles in this series

- [01. How GitHub Copilot uses markdown and prompt folders](01.%20how_github_copilot_uses_markdown_and_prompt_folders.md) â€” Overview of all customization types
- [03. How to structure content for prompt files](03.%20how_to_structure_content_for_copilot_prompt_files.md) â€” Referencing MCP tools in prompts
- [04. How to structure content for agent files](04.%20how_to_structure_content_for_copilot_agent_files.md) â€” Configuring MCP tools for agents
- [06. How to structure content for skill files](06.%20how_to_structure_content_for_copilot_skills.md) â€” Cross-platform workflows

<!--
validations:
  grammar:
    status: "not_run"
    last_run: null
  readability:
    status: "not_run"
    last_run: null
  structure:
    status: "not_run"
    last_run: null
  fact_check:
    status: "not_run"
    last_run: null
  logic:
    status: "not_run"
    last_run: null

article_metadata:
  filename: "07. how_to_create_mcp_servers_for_copilot.md"
  word_count: ~2800
  created: "2026-01-20"
  series: "Prompt Engineering for GitHub Copilot"
  series_order: 7
-->
