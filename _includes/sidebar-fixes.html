<!-- Sidebar styling and fixes -->
<style>
/* Home link special styling - make it white and prominent */
.sidebar .nav-link[href="index.qmd"],
.sidebar .sidebar-item-text[href="index.qmd"],
.sidebar a[href="index.qmd"],
.sidebar-navigation .sidebar-item-text[href="index.qmd"],
#quarto-sidebar .sidebar-item-text[href="index.qmd"] {
  font-weight: 600 !important;
  font-size: 1.1rem !important;
  color: white !important;
  background: linear-gradient(135deg, #2780e3 0%, #1967d2 100%) !important;
  border: 2px solid #2780e3 !important;
  margin-bottom: 1rem !important;
  padding: 0.8rem 1rem !important;
  border-radius: 12px !important;
  box-shadow: 0 3px 8px rgba(39, 128, 227, 0.3) !important;
  transition: all 0.3s ease !important;
  display: block !important;
}

.sidebar .nav-link[href="index.qmd"]:hover,
.sidebar .sidebar-item-text[href="index.qmd"]:hover,
.sidebar a[href="index.qmd"]:hover,
.sidebar-navigation .sidebar-item-text[href="index.qmd"]:hover,
#quarto-sidebar .sidebar-item-text[href="index.qmd"]:hover {
  background: linear-gradient(135deg, #1967d2 0%, #1557b0 100%) !important;
  transform: translateX(3px) translateY(-1px) !important;
  box-shadow: 0 6px 16px rgba(39, 128, 227, 0.4) !important;
  border-color: #1967d2 !important;
  color: white !important;
}

/* Ensure sidebar icons work with emoji fallback */
.sidebar-navigation .sidebar-item-text {
    display: inline-flex;
    align-items: center;
}

/* FIXED: Left sidebar hierarchical indentation and spacing */
/* Reset all sidebar items to consistent baseline */
#quarto-sidebar .sidebar-item {
  margin-bottom: 0.1rem;
}

/* Base styling for all sidebar item texts */
#quarto-sidebar .sidebar-item-text {
  display: flex;
  align-items: center;
  gap: 0 !important; /* Remove the 0.5rem gap */
  line-height: 1.3;
  border-radius: 4px;
  transition: all 0.2s ease;
}

/* Level 0 (Root level): "Home", "Events", "Tools", etc. */
#quarto-sidebar > .sidebar-navigation > .sidebar-item > .sidebar-item-text {
  font-weight: 600 !important;
  font-size: 0.95rem !important;
  padding: 0.4rem 0.75rem !important;
  color: #2d3748 !important;
}

/* Level 1 (First nested): "Build Conference 2025", "Development Tools", etc. */
#quarto-sidebar .sidebar-item .sidebar-item > .sidebar-item-text {
  font-weight: 500 !important;
  font-size: 0.9rem !important;
  padding: 0.3rem 0.75rem !important;
  padding-left: 1.5rem !important; /* Indent from level 0 */
  color: #4a5568 !important;
}

/* Level 2 (Second nested): "Git Command Line", "HTTP Files Testing", etc. */
#quarto-sidebar .sidebar-item .sidebar-item .sidebar-item > .sidebar-item-text {
  font-weight: 400 !important;
  font-size: 0.85rem !important;
  padding: 0.25rem 0.75rem !important;
  padding-left: 2.25rem !important; /* Further indent from level 1 */
  color: #718096 !important;
}

/* Level 3 (Third nested): Deep nested items */
#quarto-sidebar .sidebar-item .sidebar-item .sidebar-item .sidebar-item > .sidebar-item-text {
  font-weight: 400 !important;
  font-size: 0.8rem !important;
  padding: 0.2rem 0.75rem !important;
  padding-left: 3rem !important; /* Further indent from level 2 */
  color: #a0aec0 !important;
}

/* Hover effects for better UX */
#quarto-sidebar .sidebar-item-text:hover {
  background-color: rgba(237, 242, 247, 0.8) !important;
}

/* Active state styling - hierarchical specificity */
#quarto-sidebar .sidebar-item-text.active {
  background-color: rgba(39, 128, 227, 0.1) !important;
  color: #2780e3 !important;
  border-left: 3px solid #2780e3 !important;
}

/* Override any conflicting container-based rules */
#quarto-sidebar .sidebar-item-container .sidebar-item-text,
#quarto-sidebar .sidebar-section .sidebar-item-text {
  /* Reset any container-specific padding - let hierarchy rules take precedence */
  padding: inherit !important;
}

/* Ensure icons align properly at all levels */
#quarto-sidebar .sidebar-item-text i,
#quarto-sidebar .sidebar-item-text .bi {
  flex-shrink: 0;
  width: 1em;
  text-align: center;
  margin-right: 0.5rem !important;
}
</style>

<script>
// IMMEDIATE TEST - This should show up right away
console.log('ğŸš€ SIDEBAR SCRIPT WITH HIERARCHICAL PERSISTENCE LOADING...');
console.log('Current time:', new Date().toLocaleTimeString());

// Clear localStorage for testing (uncomment to reset)
// localStorage.removeItem('learningHubSidebarState');
// console.log('ğŸ§¹ Cleared existing localStorage for fresh start');

// Debug current localStorage content
const existingState = localStorage.getItem('learningHubSidebarState');
if (existingState) {
    console.log('ğŸ“‚ Existing localStorage state found:', JSON.parse(existingState));
} else {
    console.log('ğŸ“‚ No existing localStorage state found');
}

// Storage key for sidebar state
const SIDEBAR_STATE_KEY = 'learningHubSidebarState';

// Function to build hierarchical path for unique identification
function buildHierarchicalPath(element) {
    const path = [];
    let current = element;
    
    console.log('ğŸ” Building hierarchical path for element:', element.outerHTML.substring(0, 100));
    
    // Walk up the DOM tree to build the path
    while (current && !current.matches('#quarto-sidebar')) {
        console.log('  ğŸ”„ Current element:', current.tagName, current.className);
        
        if (current.matches('.sidebar-item')) {
            // Look for the text element in this sidebar item - it's nested inside sidebar-item-container
            const textElement = current.querySelector('.sidebar-item-text');
            console.log('  ğŸ“ Text element found:', !!textElement);
            
            if (textElement) {
                const text = textElement.textContent?.trim();
                console.log('  ğŸ“„ Text content:', text);
                if (text) {
                    path.unshift(text); // Add to the beginning of the array
                    console.log('  â• Added to path:', text, '| Current path:', path);
                }
            }
        }
        current = current.parentElement;
    }
    
    const finalPath = path.join(' > ') || 'unknown';
    console.log('ğŸ¯ Final hierarchical path:', finalPath);
    return finalPath;
}

// Test if we can find the sidebar immediately
setTimeout(() => {
    const sidebar = document.getElementById('quarto-sidebar');
    console.log('ğŸ¯ Sidebar element found?', !!sidebar);
    if (sidebar) {
        console.log('ğŸ“ Sidebar HTML length:', sidebar.innerHTML.length);
        console.log('ğŸ” Sidebar children count:', sidebar.children.length);
    }
}, 100);

// Function to get all collapsible sections in the sidebar
function getCollapsibleSections() {
    const sidebar = document.getElementById('quarto-sidebar');
    if (!sidebar) return [];
    
    const sections = [];
    
    // Find all sidebar items that have chevron icons (indicating they're collapsible)
    const chevrons = sidebar.querySelectorAll('.bi-chevron-right, .bi-chevron-down');
    
    chevrons.forEach(chevron => {
        console.log('ğŸ” Processing chevron:', chevron.outerHTML.substring(0, 100));
        
        const sidebarItem = chevron.closest('.sidebar-item');
        console.log('  ğŸ“¦ Sidebar item found:', !!sidebarItem);
        if (sidebarItem) {
            console.log('  ğŸ“¦ Sidebar item HTML:', sidebarItem.outerHTML.substring(0, 200));
        }
        
        const sidebarText = sidebarItem?.querySelector('.sidebar-item-text');
        console.log('  ğŸ“ Sidebar text found:', !!sidebarText);
        if (sidebarText) {
            console.log('  ğŸ“ Sidebar text content:', sidebarText.textContent?.trim());
        }
        
        if (sidebarText && sidebarItem) {
            const text = sidebarText.textContent?.trim();
            
            // Build hierarchical path to avoid collisions
            const hierarchicalPath = buildHierarchicalPath(sidebarItem);
            
            // Focus on actual content visibility rather than chevron classes
            // since Quarto seems to use chevron-right for both states
            
            // Look for immediate child sidebar items
            const immediateChildren = Array.from(sidebarItem.children).filter(child => 
                child.classList && (child.classList.contains('sidebar-item') || child.classList.contains('sidebar-section'))
            );
            
            // Look for nested content within this item
            const nestedItems = sidebarItem.querySelectorAll(':scope > .sidebar-item, :scope > .sidebar-section, :scope .sidebar-item-container > .sidebar-item');
            
            // Check if nested content is actually visible
            const hasVisibleNestedContent = Array.from(nestedItems).some(item => {
                const computedStyle = window.getComputedStyle(item);
                const isVisible = computedStyle.display !== 'none' && 
                                computedStyle.visibility !== 'hidden' &&
                                item.offsetHeight > 0 &&
                                item.offsetWidth > 0;
                return isVisible;
            });
            
            // Alternative: Check if the parent has Bootstrap collapse classes
            const parentCollapse = sidebarItem.querySelector('.collapse');
            const hasShowClass = parentCollapse ? parentCollapse.classList.contains('show') : false;
            
            // Alternative: Check aria-expanded attribute on the button/link
            const button = sidebarItem.querySelector('[aria-expanded]');
            const ariaExpanded = button ? button.getAttribute('aria-expanded') === 'true' : null;
            
            // Final determination: Multiple indicators with priority
            let isExpanded;
            if (ariaExpanded !== null) {
                // Trust aria-expanded if available
                isExpanded = ariaExpanded;
            } else if (hasShowClass) {
                // Trust Bootstrap's show class
                isExpanded = true;
            } else {
                // Fallback to visual inspection
                isExpanded = hasVisibleNestedContent;
            }
            
            console.log(`ğŸ” Analyzing "${hierarchicalPath}":`, {
                text: text,
                path: hierarchicalPath,
                chevronClass: chevron.className,
                immediateChildrenCount: immediateChildren.length,
                nestedItemsCount: nestedItems.length,
                hasVisibleNestedContent,
                hasShowClass,
                ariaExpanded,
                finalIsExpanded: isExpanded
            });
            
            // Use hierarchical path as the unique identifier
            const safeId = hierarchicalPath
                .replace(/[^a-zA-Z0-9\s>/]/g, '') // Keep path separators
                .replace(/\s+/g, '_')
                .replace(/>/g, '__') // Convert > to __ for safe storage
                .substring(0, 100) // Longer limit for paths
                .toLowerCase();
            
            sections.push({
                element: sidebarItem,
                text: text,
                hierarchicalPath: hierarchicalPath,
                chevron: chevron,
                isExpanded: isExpanded,
                id: safeId
            });
        }
    });
    
    console.log(`ğŸ“‹ Found ${sections.length} collapsible sections:`);
    sections.forEach((section, i) => {
        console.log(`  ${i+1}. "${section.hierarchicalPath}" (${section.isExpanded ? 'expanded' : 'collapsed'}) - chevron: ${section.chevron.className}`);
    });
    
    return sections;
}

// Save sidebar state to localStorage using hierarchical structure
function saveSidebarState() {
    try {
        const sections = getCollapsibleSections();
        const hierarchicalState = {};
        
        sections.forEach(section => {
            // Build the path array from hierarchicalPath
            const pathParts = section.hierarchicalPath.split(' > ').map(part => 
                part.replace(/[^a-zA-Z0-9\s]/g, '').replace(/\s+/g, '_').toLowerCase()
            );
            
            // Navigate/create the nested structure
            let current = hierarchicalState;
            pathParts.forEach((part, index) => {
                if (!current[part]) {
                    current[part] = {
                        text: section.hierarchicalPath.split(' > ')[index],
                        isExpanded: false,
                        children: {}
                    };
                }
                
                // If this is the final part, update with actual state
                if (index === pathParts.length - 1) {
                    current[part].isExpanded = section.isExpanded;
                } else {
                    current = current[part].children;
                }
            });
        });
        
        localStorage.setItem(SIDEBAR_STATE_KEY, JSON.stringify(hierarchicalState));
        console.log(`ğŸ’¾ Hierarchical sidebar state saved:`, hierarchicalState);
        
    } catch (error) {
        console.error('âŒ Failed to save sidebar state:', error);
    }
}

// Restore sidebar state from localStorage using hierarchical structure
function restoreSidebarState() {
    try {
        const savedState = localStorage.getItem(SIDEBAR_STATE_KEY);
        if (!savedState) {
            console.log('ğŸ“‚ No saved sidebar state found');
            return;
        }
        
        const hierarchicalState = JSON.parse(savedState);
        console.log('ğŸ”„ Restoring hierarchical sidebar state:', hierarchicalState);
        
        const sections = getCollapsibleSections();
        
        // Helper function to find state in nested structure
        function findStateInHierarchy(pathParts, state) {
            let current = state;
            for (const part of pathParts) {
                const safePart = part.replace(/[^a-zA-Z0-9\s]/g, '').replace(/\s+/g, '_').toLowerCase();
                if (current[safePart]) {
                    current = current[safePart];
                    if (pathParts.indexOf(part) < pathParts.length - 1) {
                        current = current.children || {};
                    }
                } else {
                    return null; // Path not found
                }
            }
            return current;
        }
        
        sections.forEach(section => {
            const pathParts = section.hierarchicalPath.split(' > ');
            const savedSection = findStateInHierarchy(pathParts, hierarchicalState);
            
            if (savedSection) {
                const shouldBeExpanded = savedSection.isExpanded;
                const isCurrentlyExpanded = section.isExpanded;
                
                console.log(`ğŸ”„ Processing "${section.hierarchicalPath}": saved=${shouldBeExpanded ? 'expanded' : 'collapsed'}, current=${isCurrentlyExpanded ? 'expanded' : 'collapsed'}`);
                
                // If state doesn't match, click the chevron to toggle it
                if (shouldBeExpanded !== isCurrentlyExpanded) {
                    setTimeout(() => {
                        console.log(`ğŸ‘† Clicking chevron to restore "${section.hierarchicalPath}" to ${shouldBeExpanded ? 'expanded' : 'collapsed'}`);
                        section.chevron.click();
                    }, 100);
                } else {
                    console.log(`âœ… "${section.hierarchicalPath}" already in correct state`);
                }
            } else {
                console.log(`âš ï¸ No saved state found for "${section.hierarchicalPath}"`);
            }
        });
        
    } catch (error) {
        console.error('âŒ Failed to restore sidebar state:', error);
    }
}

// Enhanced click detection with state saving
document.addEventListener('click', function(event) {
    // Log all clicks for debugging
    console.log('ğŸ–±ï¸ CLICK:', {
        tag: event.target.tagName,
        classes: event.target.className,
        text: event.target.textContent?.substring(0, 20),
        inSidebar: !!event.target.closest('#quarto-sidebar')
    });
    
    // If it's in the sidebar, check if it's a chevron click
    if (event.target.closest('#quarto-sidebar')) {
        console.log('ğŸ¯ SIDEBAR CLICK DETECTED');
        console.log('Element clicked:', event.target.outerHTML.substring(0, 150));
        
        // Check if this is a chevron click (collapse/expand action)
        if (event.target.classList.contains('bi-chevron-right') || 
            event.target.classList.contains('bi-chevron-down') ||
            event.target.closest('.bi-chevron-right') ||
            event.target.closest('.bi-chevron-down')) {
            
            console.log('ğŸ”„ CHEVRON CLICK DETECTED - This will change sidebar state!');
            
            // Wait for the DOM to update after the click, then save state
            setTimeout(() => {
                console.log('ğŸ’¾ Saving sidebar state after chevron click...');
                saveSidebarState();
            }, 300);
            
        } else {
            console.log('ğŸ“„ Regular sidebar click (not a chevron) - no state change');
        }
    }
});

// Initialize everything when page loads
setTimeout(() => {
    console.log('ğŸ”§ Initializing sidebar persistence with hierarchical storage...');
    
    // First, restore any saved state
    setTimeout(() => {
        console.log('ğŸ”„ Starting sidebar state restoration...');
        restoreSidebarState();
    }, 500);
    
    // Save initial state after restoration
    setTimeout(() => {
        console.log('ğŸ’¾ Saving initial sidebar state after restoration...');
        saveSidebarState();
    }, 1500);
    
}, 1000);

// Save state when page unloads
window.addEventListener('beforeunload', function() {
    console.log('ğŸ“¤ Page unloading - saving final sidebar state');
    saveSidebarState();
});

console.log('âœ… Sidebar persistence system initialized');
console.log('ğŸ SCRIPT SETUP COMPLETE');
</script>
        // Fix sidebar Home link styling
        const sidebarHomeLinks = document.querySelectorAll(
            '.sidebar a[href*="index"], #quarto-sidebar a[href*="index"], .sidebar-item-text[href*="index"]'
        );
        sidebarHomeLinks.forEach(link => {
            if (link.textContent.trim().toLowerCase().includes('home')) {
                console.log('Applying white styling to Home link in sidebar');
                link.style.setProperty('color', 'white', 'important');
                link.style.setProperty('background', 'linear-gradient(135deg, #2780e3 0%, #1967d2 100%)', 'important');
                link.style.setProperty('border', '2px solid #2780e3', 'important');
                link.style.setProperty('border-radius', '12px', 'important');
                link.style.setProperty('padding', '0.8rem 1rem', 'important');
                link.style.setProperty('font-weight', '600', 'important');
                link.style.setProperty('box-shadow', '0 3px 8px rgba(39, 128, 227, 0.3)', 'important');
                link.style.setProperty('margin-bottom', '1rem', 'important');
                link.classList.add('home-link-styled');
                
                // Add home icon if missing
                if (!link.querySelector('.bi-house-fill')) {
                    const homeIcon = document.createElement('i');
                    homeIcon.className = 'bi bi-house-fill';
                    homeIcon.style.marginRight = '0.75rem';
                    homeIcon.style.color = 'white';
                    link.prepend(homeIcon);
                }
            }
        });

        // Initialize persistent sidebar state
        initPersistentSidebar();
    }, 1000);
});

// Persistent Sidebar State Management
function initPersistentSidebar() {
    console.log('Initializing persistent sidebar state...');
    
    // Storage key for sidebar state
    const SIDEBAR_STATE_KEY = 'learningHubSidebarState';
    
    // Get all collapsible sidebar items using Quarto's actual structure
    function getSidebarItems() {
        // Look for actual Bootstrap collapse elements in the sidebar
        const collapseElements = document.querySelectorAll('#quarto-sidebar .collapse');
        const collapsibleItems = [];
        
        collapseElements.forEach(collapse => {
            // Find the associated toggle element (usually the previous sibling or parent)
            const toggle = document.querySelector(`[data-bs-target="#${collapse.id}"], [href="#${collapse.id}"]`) ||
                          collapse.previousElementSibling ||
                          collapse.parentElement?.querySelector('.sidebar-item-text');
            
            if (toggle) {
                collapsibleItems.push({
                    toggle: toggle,
                    collapse: collapse,
                    id: collapse.id
                });
            }
        });
        
        console.log(`Found ${collapsibleItems.length} collapsible sidebar items:`, 
                   collapsibleItems.map(item => ({
                       id: item.id,
                       text: item.toggle.textContent?.trim().substring(0, 30)
                   })));
        
        return collapsibleItems;
    }
    
    // Generate unique identifier for each sidebar item
    function getItemId(item) {
        // If it's a new structure item with id
        if (item.id) {
            return item.id;
        }
        
        // Fallback for old structure
        const textElement = item.toggle || item.querySelector('.sidebar-item-text');
        if (textElement) {
            const text = textElement.textContent.trim().substring(0, 50);
            const href = textElement.getAttribute('href') || '';
            return btoa(text + href).replace(/[^a-zA-Z0-9]/g, '');
        }
        return null;
    }
    
    // Save current sidebar state to localStorage
    function saveSidebarState() {
        const state = {};
        const sidebarItems = getSidebarItems();
        
        console.log(`ğŸ’¾ Saving sidebar state for ${sidebarItems.length} collapsible items...`);
        
        sidebarItems.forEach((item, index) => {
            const id = getItemId(item);
            if (id) {
                // Check if the collapse element is currently hidden/shown
                const isCollapsed = item.collapse ? 
                    !item.collapse.classList.contains('show') :
                    (item.classList.contains('collapsed') || 
                     item.getAttribute('aria-expanded') === 'false');
                
                const text = item.toggle ? 
                    item.toggle.textContent?.trim().substring(0, 30) :
                    (item.querySelector('.sidebar-item-text')?.textContent?.trim().substring(0, 30) || 'Unknown');
                
                state[id] = {
                    collapsed: isCollapsed,
                    text: text
                };
                
                console.log(`  ğŸ“ Item ${index + 1}: "${text}" - ${isCollapsed ? 'ğŸ”¼ collapsed' : 'ğŸ”½ expanded'}`);
            }
        });
        
        try {
            localStorage.setItem(SIDEBAR_STATE_KEY, JSON.stringify(state));
            console.log(`âœ… Sidebar state saved successfully: ${Object.keys(state).length} items stored`);
        } catch (error) {
            console.error('âŒ Failed to save sidebar state:', error);
        }
    }
    
    // Add event listeners to track sidebar changes using Quarto's actual navigation system
    function attachSidebarListeners() {
        console.log('Attaching sidebar listeners using Quarto navigation system...');
        
        // Wait for Quarto's sidebar to be fully initialized
        setTimeout(() => {
            console.log('ğŸ” DEBUGGING SIDEBAR STRUCTURE...');
            
            // Analyze the sidebar structure
            const sidebar = document.getElementById('quarto-sidebar');
            if (!sidebar) {
                console.warn('âŒ Quarto sidebar not found');
                return;
            }
            
            // Look for all potential collapsible elements
            console.log('ğŸ“‹ Analyzing sidebar structure:');
            
            // Check for Bootstrap collapse elements
            const collapseElements = sidebar.querySelectorAll('.collapse');
            console.log(`  ğŸ”¹ Found ${collapseElements.length} .collapse elements`);
            collapseElements.forEach((el, i) => {
                console.log(`    ${i+1}. ID: ${el.id}, Classes: ${el.className}`);
            });
            
            // Check for data-bs-toggle elements
            const toggleElements = sidebar.querySelectorAll('[data-bs-toggle]');
            console.log(`  ğŸ”¹ Found ${toggleElements.length} [data-bs-toggle] elements`);
            toggleElements.forEach((el, i) => {
                console.log(`    ${i+1}. Tag: ${el.tagName}, Toggle: ${el.getAttribute('data-bs-toggle')}, Target: ${el.getAttribute('data-bs-target')}`);
            });
            
            // Check for aria-expanded elements
            const ariaElements = sidebar.querySelectorAll('[aria-expanded]');
            console.log(`  ğŸ”¹ Found ${ariaElements.length} [aria-expanded] elements`);
            ariaElements.forEach((el, i) => {
                console.log(`    ${i+1}. Tag: ${el.tagName}, Expanded: ${el.getAttribute('aria-expanded')}, Text: "${el.textContent?.trim().substring(0, 20)}"`);
            });
            
            // Check for sidebar-item-text elements
            const sidebarTexts = sidebar.querySelectorAll('.sidebar-item-text');
            console.log(`  ğŸ”¹ Found ${sidebarTexts.length} .sidebar-item-text elements`);
            sidebarTexts.forEach((el, i) => {
                const hasHref = !!el.href;
                const hasAriaExpanded = el.hasAttribute('aria-expanded');
                const text = el.textContent?.trim().substring(0, 25);
                console.log(`    ${i+1}. "${text}" - href: ${hasHref}, aria-expanded: ${hasAriaExpanded ? el.getAttribute('aria-expanded') : 'none'}`);
            });
            
            // Listen for ALL possible events that could indicate sidebar changes
            console.log('ğŸ¯ Setting up COMPREHENSIVE event listeners...');
            
            // Bootstrap collapse events
            ['show.bs.collapse', 'shown.bs.collapse', 'hide.bs.collapse', 'hidden.bs.collapse'].forEach(eventType => {
                sidebar.addEventListener(eventType, function(event) {
                    console.log(`ğŸŒŸ Bootstrap Event: ${eventType}`, {
                        target: event.target.tagName + (event.target.id ? '#' + event.target.id : ''),
                        targetClasses: event.target.className
                    });
                    const sectionText = event.target.previousElementSibling?.textContent?.trim();
                    if (sectionText) console.log(`  ğŸ“ Section: "${sectionText}"`);
                    setTimeout(saveSidebarState, 350);
                });
            });
            
            // Generic DOM events that might be used
            ['click', 'change', 'toggle'].forEach(eventType => {
                sidebar.addEventListener(eventType, function(event) {
                    console.log(`ï¿½ Generic Event: ${eventType}`, {
                        target: event.target.tagName + (event.target.className ? '.' + event.target.className.split(' ')[0] : ''),
                        text: event.target.textContent?.trim().substring(0, 20)
                    });
                });
            });
            
            // MutationObserver to watch for DOM changes in sidebar
            const observer = new MutationObserver(function(mutations) {
                mutations.forEach(function(mutation) {
                    if (mutation.type === 'attributes') {
                        const target = mutation.target;
                        if (target.closest('#quarto-sidebar')) {
                            console.log('ï¿½ Sidebar DOM Attribute Changed:', {
                                element: target.tagName + (target.className ? '.' + target.className.split(' ')[0] : ''),
                                attribute: mutation.attributeName,
                                oldValue: mutation.oldValue,
                                newValue: target.getAttribute(mutation.attributeName),
                                text: target.textContent?.trim().substring(0, 20)
                            });
                            
                            // If aria-expanded changed, save state
                            if (mutation.attributeName === 'aria-expanded' || 
                                mutation.attributeName === 'class' ||
                                mutation.attributeName === 'style') {
                                setTimeout(saveSidebarState, 100);
                            }
                        }
                    }
                    
                    if (mutation.type === 'childList') {
                        mutation.addedNodes.forEach(node => {
                            if (node.nodeType === Node.ELEMENT_NODE && node.closest('#quarto-sidebar')) {
                                console.log('â• Sidebar DOM Node Added:', node.tagName);
                            }
                        });
                        
                        mutation.removedNodes.forEach(node => {
                            if (node.nodeType === Node.ELEMENT_NODE && node.closest('#quarto-sidebar')) {
                                console.log('â– Sidebar DOM Node Removed:', node.tagName);
                            }
                        });
                    }
                });
            });
            
            observer.observe(sidebar, {
                attributes: true,
                attributeOldValue: true,
                childList: true,
                subtree: true
            });
            
            console.log('âœ… Comprehensive sidebar monitoring active');
            
        }, 1000);
        
        // Reduced frequency backup save
        setInterval(() => {
            console.log('ğŸ• Periodic sidebar state backup');
            saveSidebarState();
        }, 60000); // Every minute
    }, 1500);

    // Save state when page is about to be unloaded
    window.addEventListener('beforeunload', saveSidebarState);
    window.addEventListener('pagehide', saveSidebarState);
}, 1000);

console.log('ğŸ SIDEBAR-FIXES.HTML SCRIPT LOADED COMPLETELY');
</script>