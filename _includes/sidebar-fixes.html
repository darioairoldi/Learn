<!-- Sidebar styling and fixes -->
<style>
/* ANTI-FLICKER SYSTEM - Aggressive initial hiding */
/* Hide ALL collapse content by default until JavaScript is ready */
#quarto-sidebar .collapse {
  display: none !important;
  height: 0 !important;
  opacity: 0 !important;
  overflow: hidden !important;
  transition: none !important;
}

/* Force all chevrons to start pointing right */
#quarto-sidebar .sidebar-item-text .bi-chevron-down {
  transform: rotate(-90deg) !important;
}

#quarto-sidebar .sidebar-item-text .bi::before {
  content: "\f285" !important; /* chevron-right */
}

/* Only show content when JavaScript explicitly marks sections as ready */
#quarto-sidebar.sidebar-ready .collapse.show {
  display: block !important;
  height: auto !important;
  opacity: 1 !important;
  overflow: visible !important;
  transition: all 0.3s ease !important;
}

/* Enable smooth transitions only after initial setup */
#quarto-sidebar.sidebar-ready .collapse {
  transition: all 0.3s ease !important;
}

/* Home link special styling - make it white and prominent but allow collapse */
.sidebar .nav-link[href="index.qmd"],
.sidebar .sidebar-item-text[href="index.qmd"],
.sidebar a[href="index.qmd"],
.sidebar-navigation .sidebar-item-text[href="index.qmd"],
#quarto-sidebar .sidebar-item-text[href="index.qmd"] {
  font-weight: 600 !important;
  font-size: 1.1rem !important;
  color: white !important;
  background: linear-gradient(135deg, #2780e3 0%, #1967d2 100%) !important;
  border: 2px solid #2780e3 !important;
  margin-bottom: 1rem !important;
  padding: 0.8rem 1rem !important;
  border-radius: 12px !important;
  box-shadow: 0 3px 8px rgba(39, 128, 227, 0.3) !important;
  transition: all 0.3s ease !important;
  /* Remove display: block to allow collapsible functionality */
}

.sidebar .nav-link[href="index.qmd"]:hover,
.sidebar .sidebar-item-text[href="index.qmd"]:hover,
.sidebar a[href="index.qmd"]:hover,
.sidebar-navigation .sidebar-item-text[href="index.qmd"]:hover,
#quarto-sidebar .sidebar-item-text[href="index.qmd"]:hover {
  background: linear-gradient(135deg, #1967d2 0%, #1557b0 100%) !important;
  transform: translateX(3px) translateY(-1px) !important;
  box-shadow: 0 6px 16px rgba(39, 128, 227, 0.4) !important;
  border-color: #1967d2 !important;
  color: white !important;
}

/* Ensure Home section chevron is visible and styled properly */
#quarto-sidebar .sidebar-item:has(.sidebar-item-text[href="index.qmd"]) .bi-chevron-right,
#quarto-sidebar .sidebar-item:has(.sidebar-item-text[href="index.qmd"]) .bi-chevron-down {
  color: white !important;
  opacity: 1 !important;
  display: inline-block !important;
  pointer-events: auto !important; /* Ensure chevron is clickable */
  cursor: pointer !important;
}

/* Ensure Home section children are properly styled and accessible */
#quarto-sidebar .sidebar-item:has(.sidebar-item-text[href="index.qmd"]) .sidebar-item .sidebar-item-text {
  /* Reset the special Home styling for child items */
  background: none !important;
  border: none !important;
  box-shadow: none !important;
  color: #4a5568 !important;
  font-weight: 500 !important;
  font-size: 0.9rem !important;
  padding: 0.3rem 0.75rem !important;
  padding-left: 1.5rem !important; /* Indent child items */
  border-radius: 4px !important;
  margin-bottom: 0.25rem !important;
  transform: none !important;
}

/* Home section children hover effect */
#quarto-sidebar .sidebar-item:has(.sidebar-item-text[href="index.qmd"]) .sidebar-item .sidebar-item-text:hover {
  background-color: rgba(237, 242, 247, 0.8) !important;
  color: #2d3748 !important;
  transform: none !important;
  box-shadow: none !important;
}

/* Ensure Home section can expand/collapse properly */
#quarto-sidebar .sidebar-item:has(.sidebar-item-text[href="index.qmd"]) .collapse {
  background: transparent !important;
}

/* Ensure icons work with emoji fallback */
.sidebar-navigation .sidebar-item-text {
    display: inline-flex;
    align-items: center;
}

/* FIXED: Left sidebar hierarchical indentation and spacing */
/* Reset all sidebar items to consistent baseline with proper spacing */
#quarto-sidebar .sidebar-item {
  margin-bottom: 0.4rem; /* Increased from 0.1rem for better separation */
}

/* Add extra spacing for top-level menu items */
#quarto-sidebar > .sidebar-navigation > .sidebar-item {
  margin-bottom: 0.6rem; /* More space between main sections */
}

/* Reduce spacing for nested items to maintain hierarchy */
#quarto-sidebar .sidebar-item .sidebar-item {
  margin-bottom: 0.25rem; /* Moderate spacing for first level nesting */
}

#quarto-sidebar .sidebar-item .sidebar-item .sidebar-item {
  margin-bottom: 0.15rem; /* Minimal spacing for deep nesting */
}

/* Base styling for all sidebar item texts */
#quarto-sidebar .sidebar-item-text {
  display: flex;
  align-items: center;
  gap: 0 !important; /* Remove the 0.5rem gap */
  line-height: 1.3;
  border-radius: 4px;
  transition: all 0.2s ease;
}

/* Level 0 (Root level): "Home", "Events", "Tools", etc. */
#quarto-sidebar > .sidebar-navigation > .sidebar-item > .sidebar-item-text {
  font-weight: 600 !important;
  font-size: 0.95rem !important;
  padding: 0.4rem 0.75rem !important;
  color: #2d3748 !important;
}

/* Level 1 (First nested): "Build Conference 2025", "Development Tools", etc. */
#quarto-sidebar .sidebar-item .sidebar-item > .sidebar-item-text {
  font-weight: 500 !important;
  font-size: 0.9rem !important;
  padding: 0.3rem 0.75rem !important;
  padding-left: 1.5rem !important; /* Indent from level 0 */
  color: #4a5568 !important;
}

/* Level 2 (Second nested): "Git Command Line", "HTTP Files Testing", etc. */
#quarto-sidebar .sidebar-item .sidebar-item .sidebar-item > .sidebar-item-text {
  font-weight: 400 !important;
  font-size: 0.85rem !important;
  padding: 0.25rem 0.75rem !important;
  padding-left: 2.25rem !important; /* Further indent from level 1 */
  color: #718096 !important;
}

/* Level 3 (Third nested): Deep nested items */
#quarto-sidebar .sidebar-item .sidebar-item .sidebar-item .sidebar-item > .sidebar-item-text {
  font-weight: 400 !important;
  font-size: 0.8rem !important;
  padding: 0.2rem 0.75rem !important;
  padding-left: 3rem !important; /* Further indent from level 2 */
  color: #a0aec0 !important;
}

/* Hover effects for better UX */
#quarto-sidebar .sidebar-item-text:hover {
  background-color: rgba(237, 242, 247, 0.8) !important;
}

/* Active state styling - hierarchical specificity */
#quarto-sidebar .sidebar-item-text.active {
  background-color: rgba(39, 128, 227, 0.1) !important;
  color: #2780e3 !important;
  border-left: 3px solid #2780e3 !important;
  padding-left: 0.75rem !important; /* Add space between border and text */
}

/* Ensure icons align properly at all levels */
#quarto-sidebar .sidebar-item-text i,
#quarto-sidebar .sidebar-item-text .bi {
  flex-shrink: 0;
  width: 1em;
  text-align: center;
  margin-right: 0.5rem !important;
}

/* Add padding to sidebar links for better spacing */
.sidebar-link,
#quarto-sidebar .nav-link,
#quarto-sidebar .sidebar-item-text {
  padding: 0.25rem 0 !important;
}

/* Collapse search component to minimize space */
.sidebar-search,
#quarto-search,
.mt-2.flex-shrink-0.align-items-center {
  max-height: 0 !important;
  overflow: hidden !important;
  opacity: 0 !important;
  margin: 0 !important;
  padding: 0 !important;
  border: none !important;
  transition: all 0.3s ease !important;
}

/* Fix sidebar alignment and remove unnecessary margins */
#quarto-sidebar {
  padding-top: 0 !important;
  margin-top: 0 !important;
}

/* Remove any unwanted spacing at the top of sidebar content */
#quarto-sidebar .sidebar-menu-container,
#quarto-sidebar .sidebar-navigation {
  margin-top: 0 !important;
  padding-top: 0 !important;
}

/* Make left sidebar align like right sidebar without breaking content */
#quarto-sidebar {
  position: sticky !important;
  top: 0 !important;
  align-self: flex-start !important;
  max-height: 100vh !important;
  overflow-y: auto !important;
}

/* Simulate the margin-sidebar wrapper div behavior */
#quarto-sidebar {
  /* Add the same margin-top that .sidebar.margin-sidebar has */
  margin-top: 1rem !important;
  margin-bottom: 1rem !important;
  padding: 0 !important;
  
  /* Wrapper div properties */
  display: block !important;
  width: auto !important;
  min-height: 0 !important;
  flex-shrink: 0 !important;
  box-sizing: border-box !important;
}

/* Ensure right sidebar has consistent behavior */
.quarto-margin-sidebar {
  margin-top: 1rem !important;
  padding-top: 0 !important;
}
</style>

<script>
// IMMEDIATE TEST - This should show up right away
console.log('üöÄ SIDEBAR SCRIPT WITH HIERARCHICAL PERSISTENCE LOADING...');
console.log('Current time:', new Date().toLocaleTimeString());

// Clear localStorage for testing (uncomment to reset)
// localStorage.removeItem('learningHubSidebarState');
// console.log('üßπ Cleared existing localStorage for fresh start');

// Debug current localStorage content
const existingState = localStorage.getItem('learningHubSidebarState');
if (existingState) {
    console.log('üìÇ Existing localStorage state found:', JSON.parse(existingState));
} else {
    console.log('üìÇ No existing localStorage state found');
}

// Storage key for sidebar state
const SIDEBAR_STATE_KEY = 'learningHubSidebarState';

// Global flags for preventing conflicts
window.sidebarRestoreInProgress = false;
window.sidebarManualClick = false;

// Function to build hierarchical path for unique identification
function buildHierarchicalPath(element) {
    const path = [];
    let current = element;
    
    // Walk up the DOM tree to build the path
    while (current && !current.matches('#quarto-sidebar')) {
        if (current.matches('.sidebar-item')) {
            const textElement = current.querySelector('.sidebar-item-text');
            if (textElement) {
                const text = textElement.textContent?.trim();
                if (text) {
                    path.unshift(text); // Add to the beginning of the array
                }
            }
        }
        current = current.parentElement;
    }
    
    const finalPath = path.join(' > ') || 'unknown';
    return finalPath;
}

// Test if we can find the sidebar immediately
setTimeout(() => {
    const sidebar = document.getElementById('quarto-sidebar');
    console.log('üéØ Sidebar element found?', !!sidebar);
    if (sidebar) {
        console.log('üìè Sidebar HTML length:', sidebar.innerHTML.length);
        console.log('üîç Sidebar children count:', sidebar.children.length);
    }
}, 100);

// Function to get all collapsible sections in the sidebar
function getCollapsibleSections() {
    const sidebar = document.getElementById('quarto-sidebar');
    if (!sidebar) return [];
    
    const sections = [];
    const chevrons = sidebar.querySelectorAll('.bi-chevron-right, .bi-chevron-down');
    
    console.log(`üîç Found ${chevrons.length} chevron icons`);
    
    chevrons.forEach((chevron, index) => {
        const sidebarItem = chevron.closest('.sidebar-item');
        const sidebarText = sidebarItem?.querySelector('.sidebar-item-text');
        
        console.log(`Chevron ${index + 1}:`, {
            text: sidebarText?.textContent?.trim(),
            hasDataBsToggle: !!chevron.closest('[data-bs-toggle]'),
            hasDataBsTarget: !!chevron.closest('[data-bs-target]'),
            hasAriaExpanded: !!chevron.closest('[aria-expanded]'),
            chevronClasses: chevron.className,
            hasCollapseElement: !!sidebarItem?.querySelector('.collapse'),
            collapseHasShowClass: !!sidebarItem?.querySelector('.collapse.show')
        });
        
        if (sidebarText && sidebarItem) {
            const text = sidebarText.textContent?.trim();
            const hierarchicalPath = buildHierarchicalPath(sidebarItem);
            
            // Check visibility of nested content
            const immediateChildren = Array.from(sidebarItem.children).filter(child => 
                child.classList && (child.classList.contains('sidebar-item') || child.classList.contains('sidebar-section'))
            );
            
            const nestedItems = sidebarItem.querySelectorAll(':scope > .sidebar-item, :scope > .sidebar-section, :scope .sidebar-item-container > .sidebar-item');
            
            const hasVisibleNestedContent = Array.from(nestedItems).some(item => {
                const computedStyle = window.getComputedStyle(item);
                return computedStyle.display !== 'none' && 
                       computedStyle.visibility !== 'hidden' &&
                       item.offsetHeight > 0 &&
                       item.offsetWidth > 0;
            });
            
            // Check Bootstrap collapse classes
            const parentCollapse = sidebarItem.querySelector('.collapse');
            const hasShowClass = parentCollapse ? parentCollapse.classList.contains('show') : false;
            
            // Check aria-expanded attribute
            const button = sidebarItem.querySelector('[aria-expanded]');
            const ariaExpanded = button ? button.getAttribute('aria-expanded') === 'true' : null;
            
            // Determine expanded state with priority - Bootstrap .show class is most reliable
            let isExpanded;
            if (hasShowClass) {
                // Bootstrap collapse has .show class - definitely expanded
                isExpanded = true;
            } else if (parentCollapse && !hasShowClass) {
                // Bootstrap collapse exists but no .show class - definitely collapsed
                isExpanded = false;
            } else if (ariaExpanded !== null) {
                // Fall back to aria-expanded if no Bootstrap collapse
                isExpanded = ariaExpanded;
            } else {
                // Final fallback to visible content check
                isExpanded = hasVisibleNestedContent;
            }
            
            // Add extra debugging for specific sections that might be problematic
            if (text === 'Events' || text === 'Tools' || text === 'Azure Topics') {
                console.log('üîç Expansion detection for', text, ':', {
                    hasShowClass: hasShowClass,
                    hasParentCollapse: !!parentCollapse,
                    ariaExpanded: ariaExpanded,
                    hasVisibleNestedContent: hasVisibleNestedContent,
                    finalDecision: isExpanded,
                    collapseClasses: parentCollapse?.className
                });
            }
            
            const safeId = hierarchicalPath
                .replace(/[^a-zA-Z0-9\s>/]/g, '')
                .replace(/\s+/g, '_')
                .replace(/>/g, '__')
                .substring(0, 100)
                .toLowerCase();
            
            sections.push({
                element: sidebarItem,
                text: text,
                hierarchicalPath: hierarchicalPath,
                chevron: chevron,
                isExpanded: isExpanded,
                id: safeId
            });
        }
    });
    
    console.log(`üìã Found ${sections.length} collapsible sections`);
    return sections;
}

// Save sidebar state to localStorage using hierarchical structure
function saveSidebarState() {
    console.log('üíæüîç saveSidebarState() called');
    
    // Skip saving if restoration is in progress
    if (window.sidebarRestoreInProgress) {
        console.log('üö´ Skipping save - restoration in progress');
        return;
    }
    
    try {
        const sections = getCollapsibleSections();
        const hierarchicalState = {};
        
        // First, preserve any existing Home state if it was manually set
        const existingSavedState = localStorage.getItem(SIDEBAR_STATE_KEY);
        let preserveHomeState = false;
        let preservedHomeState = null;
        
        if (existingSavedState) {
            try {
                const existing = JSON.parse(existingSavedState);
                if (existing.home && existing.home.hasOwnProperty('isExpanded')) {
                    // Check if the Home state was recently modified (within last 5 seconds)
                    const now = Date.now();
                    const lastHomeUpdate = existing.home.lastUpdate || 0;
                    const timeSince = now - lastHomeUpdate;
                    console.log('üíæüîç Home state check:', {
                        hasHome: !!existing.home,
                        isExpanded: existing.home.isExpanded,
                        lastUpdate: lastHomeUpdate,
                        timeSince: timeSince,
                        shouldPreserve: timeSince < 5000
                    });
                    if (timeSince < 5000) {
                        preserveHomeState = true;
                        preservedHomeState = existing.home;
                        console.log('üíæ Preserving recently updated Home state:', preservedHomeState.isExpanded);
                    } else {
                        console.log('üíæ Home state too old, not preserving (age:', timeSince, 'ms)');
                    }
                }
            } catch (e) {
                console.error('üíæ‚ùå Error parsing existing state:', e);
            }
        }
        
        sections.forEach(section => {
            console.log('üíæüîç Processing section:', section.text, 'isExpanded:', section.isExpanded);
            
            // Add extra debugging for Tools section
            if (section.text === 'Tools') {
                const parentCollapse = section.element.querySelector('.collapse');
                const button = section.element.querySelector('[aria-expanded]');
                const chevron = section.element.querySelector('.bi-chevron-right, .bi-chevron-down');
                console.log('üîß Tools section debug:', {
                    hasCollapseElement: !!parentCollapse,
                    hasShowClass: parentCollapse?.classList.contains('show'),
                    ariaExpanded: button?.getAttribute('aria-expanded'),
                    detectedExpanded: section.isExpanded,
                    collapseDisplay: parentCollapse?.style.display,
                    collapseHeight: parentCollapse?.style.height,
                    collapseOffsetHeight: parentCollapse?.offsetHeight,
                    chevronClasses: chevron?.className,
                    collapseInnerHTML: parentCollapse?.innerHTML.substring(0, 200) + '...',
                    collapseId: parentCollapse?.id
                });
                
                // Check if there are actually visible children
                const visibleChildren = Array.from(section.element.children).filter(child => {
                    const style = window.getComputedStyle(child);
                    return style.display !== 'none' && style.visibility !== 'hidden' && child.offsetHeight > 0;
                });
                console.log('üîß Tools visible children count:', visibleChildren.length);
                console.log('üîß Tools visible children:', visibleChildren.map(child => child.tagName + '.' + child.className));
            }
            
            // Special handling for Home section
            if (section.text === 'Home' && preserveHomeState) {
                // Skip normal processing for Home if we're preserving its state
                const safeName = 'home';
                hierarchicalState[safeName] = preservedHomeState;
                console.log('üíæ Preserved Home state instead of detecting:', preservedHomeState.isExpanded);
                return;
            } else if (section.text === 'Home') {
                console.log('üíæ Processing Home normally (not preserving)');
            }
            
            // Build the path array from hierarchicalPath
            const pathParts = section.hierarchicalPath.split(' > ').map(part => 
                part.replace(/[^a-zA-Z0-9\s]/g, '').replace(/\s+/g, '_').toLowerCase()
            );
            
            // Navigate/create the nested structure
            let current = hierarchicalState;
            pathParts.forEach((part, index) => {
                if (!current[part]) {
                    current[part] = {
                        text: section.hierarchicalPath.split(' > ')[index],
                        isExpanded: false,
                        children: {}
                    };
                }
                
                // If this is the final part, update with actual state
                if (index === pathParts.length - 1) {
                    current[part].isExpanded = section.isExpanded;
                    if (section.text === 'Home') {
                        console.log('üíæ Set Home isExpanded to:', section.isExpanded, '(from section detection)');
                    }
                } else {
                    current = current[part].children;
                }
            });
        });
        
        localStorage.setItem(SIDEBAR_STATE_KEY, JSON.stringify(hierarchicalState));
        console.log(`üíæ Saved state for ${sections.length} sections`);
        
    } catch (error) {
        console.error('‚ùå Failed to save sidebar state:', error);
    }
}

// PHASE 1: Pre-render collapse - Silent reset to collapsed state
function preRenderCollapseAll() {
    console.log('üîÑ PHASE 1: Pre-render collapse (silent)...');
    
    try {
        const sidebar = document.getElementById('quarto-sidebar');
        if (!sidebar) {
            console.warn('‚ùå Sidebar not found for pre-render collapse');
            return;
        }
        
        // NOTE: No need to add initial-collapse class - CSS handles it by default
        console.log('‚úÖ Sidebar will start collapsed via default CSS');
        
        // Force disable all transitions during pre-render
        const style = document.createElement('style');
        style.id = 'pre-render-no-transitions';
        style.textContent = `
            #quarto-sidebar * {
                transition: none !important;
                animation: none !important;
            }
        `;
        document.head.appendChild(style);
        
        // Find all collapsible elements and force them closed
        const collapseElements = sidebar.querySelectorAll('.collapse');
        const chevrons = sidebar.querySelectorAll('[data-bs-toggle="collapse"]');
        
        let collapsedCount = 0;
        
        // Force all sections collapsed using Bootstrap's proper method
        collapseElements.forEach((element) => {
            // Remove visual state
            element.classList.remove('show');
            element.style.display = 'none';
            element.style.height = '0';
            
            // Set proper Bootstrap state attributes
            element.setAttribute('aria-expanded', 'false');
            element.classList.add('collapse');
            
            // Important: Initialize Bootstrap's internal state by creating a Collapse instance
            // This ensures Bootstrap's JavaScript knows the element is collapsed
            if (window.bootstrap?.Collapse && element.id) {
                try {
                    // Create or get existing Bootstrap Collapse instance
                    let collapseInstance = window.bootstrap.Collapse.getInstance(element);
                    if (!collapseInstance) {
                        // Find the trigger element
                        const trigger = sidebar.querySelector(`[data-bs-target="#${element.id}"]`);
                        if (trigger) {
                            collapseInstance = new window.bootstrap.Collapse(element, {
                                toggle: false // Don't toggle, just initialize
                            });
                        }
                    }
                    
                    // Mark internal state as collapsed (if instance exists)
                    if (collapseInstance) {
                        collapseInstance._isTransitioning = false;
                        // Force internal state to collapsed
                        element.classList.remove('show');
                        element.setAttribute('aria-expanded', 'false');
                    }
                } catch (error) {
                    console.warn('‚ö†Ô∏è Error initializing Bootstrap collapse for', element.id, ':', error);
                }
            }
            
            collapsedCount++;
        });
        
        // Force all chevrons and triggers to collapsed state
        chevrons.forEach((chevron) => {
            chevron.setAttribute('aria-expanded', 'false');
            chevron.classList.remove('collapsed');
            chevron.classList.add('collapsed'); // Add Bootstrap's collapsed class
            
            const icon = chevron.querySelector('.bi');
            if (icon) {
                // Remove any existing chevron classes and set to right
                icon.classList.remove('bi-chevron-down', 'bi-chevron-up', 'bi-chevron-left');
                icon.classList.add('bi-chevron-right');
            }
        });
        
        console.log(`‚úÖ Pre-render: Force collapsed ${collapsedCount} sections silently`);
        
        // Remove the no-transition style after a brief moment
        setTimeout(() => {
            const noTransitionStyle = document.getElementById('pre-render-no-transitions');
            if (noTransitionStyle) {
                document.head.removeChild(noTransitionStyle);
            }
        }, 100);
        
    } catch (error) {
        console.error('‚ùå Error in pre-render collapse:', error);
    }
}

// PHASE 2: Progressive restore - Visible smooth expansion with animations
// Detect if this is a page transition (vs initial page load)
function detectPageTransition() {
    // Check if we've been on this domain before (indicates page transition)
    // Use both sessionStorage and a more sophisticated detection
    const hasVisitedBefore = sessionStorage.getItem('has_visited_site');
    const currentTime = Date.now();
    const currentUrl = window.location.href;
    const pendingNavigation = sessionStorage.getItem('pending_navigation');
    
    if (!hasVisitedBefore) {
        // First visit to the site
        sessionStorage.setItem('has_visited_site', currentTime.toString());
        sessionStorage.setItem('last_page_load', currentTime.toString());
        sessionStorage.setItem('last_url', currentUrl);
        return false;
    } else {
        // Check how recently the last page load occurred and if URL changed
        const lastPageLoad = parseInt(sessionStorage.getItem('last_page_load') || '0');
        const lastUrl = sessionStorage.getItem('last_url') || '';
        const timeSinceLastLoad = currentTime - lastPageLoad;
        const pendingNavTime = parseInt(pendingNavigation || '0');
        
        // Update tracking info
        sessionStorage.setItem('last_page_load', currentTime.toString());
        sessionStorage.setItem('last_url', currentUrl);
        
        // Clear pending navigation flag after using it
        if (pendingNavigation) {
            sessionStorage.removeItem('pending_navigation');
        }
        
        // More sophisticated detection: check for pending navigation or recent load with URL change
        const isTransition = (timeSinceLastLoad < 30000 && lastUrl !== currentUrl) || 
                           (pendingNavTime > 0 && (currentTime - pendingNavTime) < 5000);
        
        console.log(`üîç Page transition detection: ${isTransition ? 'TRANSITION' : 'INITIAL LOAD'}`);
        console.log(`   Time since last load: ${timeSinceLastLoad}ms`);
        console.log(`   URL changed: ${lastUrl !== currentUrl}`);
        console.log(`   Pending navigation: ${!!pendingNavigation} (${pendingNavTime > 0 ? currentTime - pendingNavTime + 'ms ago' : 'none'})`);
        console.log(`   Last URL: ${lastUrl}`);
        console.log(`   Current URL: ${currentUrl}`);
        
        return isTransition;
    }
}

// Fast expansion for page transitions (minimal animation)
function expandSectionFast(section, sectionName) {
    console.log(`‚ö° Fast expanding: ${sectionName}`);
    console.log(`‚ö° Section details:`, {
        text: section.text,
        hierarchicalPath: section.hierarchicalPath,
        hasElement: !!section.element,
        hasChevron: !!section.chevron,
        hasCollapseTarget: !!section.collapseTarget,
        isExpanded: section.isExpanded
    });
    
    try {
        // Special handling for Home section
        if (sectionName === 'Home') {
            const homeItem = section.element;
            let targetElement = homeItem?.querySelector('.collapse');
            
            if (!targetElement) {
                const nextSibling = homeItem?.nextElementSibling;
                if (nextSibling?.classList.contains('collapse')) {
                    targetElement = nextSibling;
                }
            }
            
            if (targetElement) {
                targetElement.style.display = 'block';
                targetElement.style.height = 'auto';
                targetElement.classList.add('show');
                
                // Update chevron quickly
                if (section.chevron) {
                    const chevronIcon = section.chevron.querySelector('.bi');
                    if (chevronIcon) {
                        chevronIcon.classList.remove('bi-chevron-right');
                        chevronIcon.classList.add('bi-chevron-down');
                    }
                }
                console.log('‚ö° Fast expanded Home section');
            }
            return;
        }
        
        // For other sections, try multiple approaches for reliability
        console.log(`‚ö° Expanding section: ${sectionName}`);
        
        // Method 1: Use the collapseTarget from section data
        if (section.collapseTarget) {
            console.log(`‚ö° Method 1: Using collapseTarget`);
            section.collapseTarget.style.display = 'block';
            section.collapseTarget.style.height = 'auto';
            section.collapseTarget.classList.add('show');
            
            // Update chevron
            if (section.chevron) {
                const chevronIcon = section.chevron.querySelector('.bi');
                if (chevronIcon) {
                    chevronIcon.classList.remove('bi-chevron-right');
                    chevronIcon.classList.add('bi-chevron-down');
                }
                // Update aria-expanded
                section.chevron.setAttribute('aria-expanded', 'true');
            }
            console.log(`‚ö° Fast expanded: ${sectionName} via collapseTarget`);
            return;
        }
        
        // Method 2: Find collapse element within the section element
        if (section.element) {
            console.log(`‚ö° Method 2: Finding collapse within section element`);
            const collapseElement = section.element.querySelector('.collapse');
            if (collapseElement) {
                collapseElement.style.display = 'block';
                collapseElement.style.height = 'auto';
                collapseElement.classList.add('show');
                
                // Update chevron
                if (section.chevron) {
                    const chevronIcon = section.chevron.querySelector('.bi');
                    if (chevronIcon) {
                        chevronIcon.classList.remove('bi-chevron-right');
                        chevronIcon.classList.add('bi-chevron-down');
                    }
                    section.chevron.setAttribute('aria-expanded', 'true');
                }
                console.log(`‚ö° Fast expanded: ${sectionName} via element search`);
                return;
            }
        }
        
        // Method 3: Try clicking the chevron as fallback (but with minimal delay)
        if (section.chevron && !section.isExpanded) {
            console.log(`‚ö° Method 3: Clicking chevron as fallback`);
            setTimeout(() => {
                section.chevron.click();
                console.log(`‚ö° Clicked chevron for: ${sectionName}`);
            }, 5); // Very short delay
        } else {
            console.warn(`‚ö†Ô∏è Cannot fast expand ${sectionName}: chevron=${!!section.chevron}, isExpanded=${section.isExpanded}`);
        }
        
    } catch (error) {
        console.error(`‚ùå Error fast expanding ${sectionName}:`, error);
    }
}

function progressivelyRestoreSidebarState() {
    console.log('üéØ PHASE 2: Progressive restore (visible)...');
    
    // Check if this is a page transition vs initial load
    const isPageTransition = detectPageTransition();
    console.log(`üîç Detected ${isPageTransition ? 'page transition' : 'initial page load'}`);
    
    // Add temporary visual indicator for page transitions
    if (isPageTransition) {
        const indicator = document.createElement('div');
        indicator.id = 'sidebar-transition-indicator';
        indicator.innerHTML = '‚ö° Restoring menu...';
        indicator.style.cssText = `
            position: fixed;
            top: 10px;
            right: 10px;
            background: #2780e3;
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            z-index: 9999;
            transition: all 0.3s ease;
        `;
        document.body.appendChild(indicator);
        
        // Remove indicator after restoration
        setTimeout(() => {
            if (document.getElementById('sidebar-transition-indicator')) {
                indicator.style.opacity = '0';
                setTimeout(() => indicator.remove(), 300);
            }
        }, 800);
    }
    
    // Set restoration flag to prevent saves during restoration
    window.sidebarRestoreInProgress = true;
    console.log('üö´ Disabled saves during restoration');
    
    // Use different safety timeout based on transition type
    const SAFETY_TIMEOUT = isPageTransition ? 1000 : 2000; // 1s for transitions, 2s for initial loads
    setTimeout(() => {
        if (window.sidebarRestoreInProgress) {
            console.warn('‚ö†Ô∏è Restoration taking too long - force enabling manual interactions');
            window.sidebarRestoreInProgress = false;
            
            // Ensure sidebar is marked as ready
            const sidebar = document.getElementById('quarto-sidebar');
            if (sidebar && !sidebar.classList.contains('sidebar-ready')) {
                sidebar.classList.add('sidebar-ready');
                console.log('‚úÖ Force-added sidebar-ready class');
            }
        }
    }, SAFETY_TIMEOUT);
    
    const savedState = localStorage.getItem(SIDEBAR_STATE_KEY);
    if (!savedState) {
        console.log('üìÇ No saved state - keeping all sections collapsed');
        
        // Mark sidebar as ready and enable normal behavior
        const sidebar = document.getElementById('quarto-sidebar');
        if (sidebar) {
            sidebar.classList.add('sidebar-ready');
            console.log('‚úÖ Added sidebar-ready class - normal behavior enabled');
        }
        
        enableSmoothTransitions();
        window.sidebarRestoreInProgress = false;
        return;
    }
    
    try {
        const hierarchicalState = JSON.parse(savedState);
        console.log('üéØ Found saved state, starting progressive restoration...');
        console.log('üîç Saved state contents:', hierarchicalState);
        
        // Enable smooth transitions for the restoration process
        enableSmoothTransitions();
        
        const sections = getCollapsibleSections();
        console.log(`üîç Found ${sections.length} collapsible sections:`, sections.map(s => s.text));
        
        let expandDelay = 0;
        // Use faster timing for page transitions, normal timing for initial loads
        const EXPAND_DELAY_INCREMENT = isPageTransition ? 5 : 25; // 5ms for transitions, 25ms for initial loads
        let restoredCount = 0;
        
        // Helper function to find state in nested structure
        function findStateInHierarchy(pathParts, state) {
            let current = state;
            for (const part of pathParts) {
                const safePart = part.replace(/[^a-zA-Z0-9\s]/g, '').replace(/\s+/g, '_').toLowerCase();
                if (current[safePart]) {
                    current = current[safePart];
                    if (pathParts.indexOf(part) < pathParts.length - 1) {
                        current = current.children || {};
                    }
                } else {
                    return null;
                }
            }
            return current;
        }
        
        // Process each section for progressive expansion
        const processedSections = new Set(); // Track processed sections to avoid duplicates
        sections.forEach((section, index) => {
            console.log(`üîç Processing section ${index + 1}: "${section.text}"`);
            console.log(`   Path: "${section.hierarchicalPath}"`);
            console.log(`   Element: ${!!section.element}`);
            console.log(`   Chevron: ${!!section.chevron}`);
            console.log(`   CollapseTarget: ${!!section.collapseTarget}`);
            
            // Skip duplicates by checking if we've already processed this text
            const sectionKey = section.text.trim().toLowerCase();
            if (processedSections.has(sectionKey)) {
                console.log(`‚è≠Ô∏è Skipping duplicate section: "${section.text}"`);
                return;
            }
            processedSections.add(sectionKey);
            
            // Special handling for Home section
            if (section.text === 'Home') {
                const homeState = hierarchicalState['home'];
                console.log(`üè† Home section state:`, homeState);
                if (homeState && homeState.isExpanded) {
                    console.log(`üè† Home should be expanded, scheduling restoration`);
                    setTimeout(() => {
                        if (isPageTransition) {
                            expandSectionFast(section, 'Home');
                        } else {
                            expandSectionSmoothly(section, 'Home');
                        }
                        restoredCount++;
                        console.log(`‚ö° Restored ${restoredCount}: Home (${isPageTransition ? 'fast' : 'smooth'})`);
                    }, expandDelay);
                    expandDelay += EXPAND_DELAY_INCREMENT;
                }
                return;
            }
            
            // Normal processing for other sections
            const pathParts = section.hierarchicalPath.split(' > ');
            console.log(`üîç Looking for path parts:`, pathParts);
            const savedSection = findStateInHierarchy(pathParts, hierarchicalState);
            console.log(`üîç Found saved section:`, savedSection);
            
            if (savedSection && savedSection.isExpanded) {
                console.log(`‚úÖ Section "${section.text}" should be expanded, scheduling restoration`);
                setTimeout(() => {
                    if (isPageTransition) {
                        expandSectionFast(section, section.text);
                    } else {
                        expandSectionSmoothly(section, section.text);
                    }
                    restoredCount++;
                    console.log(`‚ö° Restored ${restoredCount}: ${section.text} (${isPageTransition ? 'fast' : 'smooth'})`);
                }, expandDelay);
                expandDelay += EXPAND_DELAY_INCREMENT;
            } else {
                console.log(`‚ùå Section "${section.text}" should NOT be expanded (savedSection=${!!savedSection}, isExpanded=${savedSection?.isExpanded})`);
            }
        });
        
        // Final completion with dynamic timing based on transition type
        const COMPLETION_DELAY = isPageTransition ? 50 : 100; // Much faster for page transitions
        setTimeout(() => {
            console.log(`‚ú® ${isPageTransition ? 'Fast' : 'Progressive'} restoration complete! Restored ${restoredCount} sections`);
            
            // Mark sidebar as ready to enable normal Bootstrap behavior
            const sidebar = document.getElementById('quarto-sidebar');
            if (sidebar) {
                sidebar.classList.add('sidebar-ready');
                console.log('‚úÖ Added sidebar-ready class - Bootstrap behavior enabled');
            }
            
            // Re-enable saves after restoration is complete
            window.sidebarRestoreInProgress = false;
            console.log('‚úÖ Re-enabled saves after restoration');
        }, expandDelay + COMPLETION_DELAY);
        
    } catch (error) {
        console.error('‚ùå Error in progressive restore:', error);
        
        // Mark sidebar as ready even on error to prevent permanent hiding
        const sidebar = document.getElementById('quarto-sidebar');
        if (sidebar) {
            sidebar.classList.add('sidebar-ready');
            console.log('‚úÖ Added sidebar-ready class after error');
        }
        
        // Re-enable saves even on error
        window.sidebarRestoreInProgress = false;
        console.log('‚úÖ Re-enabled saves after error');
        
        enableSmoothTransitions();
    }
}

// Helper function for smooth section expansion
function expandSectionSmoothly(section, sectionName) {
    console.log(`üîÑ Smoothly expanding: ${sectionName}`);
    
    try {
        // Special handling for Home section
        if (sectionName === 'Home') {
            console.log('üè† Expanding Home section...');
            const homeItem = section.element;
            let targetElement = homeItem?.querySelector('.collapse');
            
            if (!targetElement) {
                const nextSibling = homeItem?.nextElementSibling;
                if (nextSibling?.classList.contains('collapse')) {
                    targetElement = nextSibling;
                }
            }
            
            if (targetElement) {
                console.log('üè† Found Home target element, expanding...');
                targetElement.style.display = 'block';
                targetElement.style.height = 'auto';
                targetElement.classList.add('show');
                
                // Update chevron
                if (section.chevron) {
                    section.chevron.setAttribute('aria-expanded', 'true');
                    const chevronIcon = section.chevron.querySelector('.bi');
                    if (chevronIcon) {
                        chevronIcon.classList.remove('bi-chevron-right');
                        chevronIcon.classList.add('bi-chevron-down');
                    }
                }
                
                console.log('‚úÖ Expanded Home section smoothly');
            } else {
                console.log('‚ùå Could not find Home collapse target');
            }
            return;
        }
        
        // For other sections, try using the click method instead of manual DOM manipulation
        console.log(`üîÑ Expanding ${sectionName} using click method...`);
        if (section.chevron && !section.isExpanded) {
            setTimeout(() => {
                section.chevron.click();
                console.log(`‚úÖ Clicked chevron for: ${sectionName}`);
            }, 50);
        } else {
            console.log(`‚ö†Ô∏è Cannot expand ${sectionName}: chevron=${!!section.chevron}, isExpanded=${section.isExpanded}`);
        }
        
    } catch (error) {
        console.error(`‚ùå Error expanding ${sectionName}:`, error);
    }
}

// Enable smooth transitions for the restoration animations
function enableSmoothTransitions() {
    console.log('ÔøΩ Enabling smooth transitions for progressive restore...');
    
    const style = document.createElement('style');
    style.id = 'enable-sidebar-transitions';
    style.textContent = `
        #quarto-sidebar .collapse {
            transition: height 0.35s ease, opacity 0.25s ease !important;
        }
        
        #quarto-sidebar .sidebar-item-text .bi {
            transition: transform 0.2s ease !important;
        }
        
        /* Smooth expand animation */
        #quarto-sidebar .collapse.show {
            animation: smoothExpand 0.35s ease-out;
        }
        
        @keyframes smoothExpand {
            from {
                opacity: 0;
                height: 0;
            }
            to {
                opacity: 1;
                height: auto;
            }
        }
    `;
    
    document.head.appendChild(style);
}

// Enhanced click detection with state saving
document.addEventListener('click', function(event) {
    // If it's in the sidebar, check if it's a chevron click
    if (event.target.closest('#quarto-sidebar')) {
        
        // Skip if restoration is in progress
        if (window.sidebarRestoreInProgress) {
            console.log('üö´ Skipping manual click handling - restoration in progress');
            return;
        }
        
        // Check if this is a chevron click (collapse/expand action)
        const isChevronClick = event.target.classList.contains('bi-chevron-right') || 
                              event.target.classList.contains('bi-chevron-down') ||
                              event.target.closest('.bi-chevron-right') ||
                              event.target.closest('.bi-chevron-down');
        
        // Check if this is any Bootstrap collapse trigger
        const isBootstrapTrigger = event.target.closest('[data-bs-toggle="collapse"]');
        
        if (isChevronClick || isBootstrapTrigger) {
            console.log('üîÑ Manual sidebar collapse trigger clicked');
            
            // Log what was actually clicked for debugging
            const clickedSidebarItem = event.target.closest('.sidebar-item');
            const clickedText = clickedSidebarItem?.querySelector('.sidebar-item-text')?.textContent?.trim();
            console.log('üéØ Clicked on sidebar item:', clickedText);
            
            // Debug the current state of the clicked section BEFORE Bootstrap processes it
            if (clickedSidebarItem) {
                const collapseElement = clickedSidebarItem.querySelector('.collapse');
                const button = clickedSidebarItem.querySelector('[aria-expanded]');
                const chevron = clickedSidebarItem.querySelector('.bi-chevron-right, .bi-chevron-down');
                console.log('üîç Pre-click state of', clickedText, ':', {
                    hasCollapseElement: !!collapseElement,
                    collapseHasShowClass: collapseElement?.classList.contains('show'),
                    ariaExpanded: button?.getAttribute('aria-expanded'),
                    chevronDirection: chevron?.classList.contains('bi-chevron-down') ? 'down' : 'right',
                    collapseClasses: collapseElement?.className
                });
            }
            
            // For Home section ONLY, let Bootstrap handle it naturally
            // Be much more specific about Home detection
            let homeItem = null;
            
            // Method 1: Try to find by exact index.qmd href
            homeItem = event.target.closest('.sidebar-item:has(.sidebar-item-text[href="index.qmd"])');
            
            // Method 2: Try to find by exact text "Home" and verify it's actually the Home section
            if (!homeItem) {
                const homeLinks = Array.from(document.querySelectorAll('.sidebar-item-text') || []);
                const homeLink = homeLinks.find(link => {
                    const text = link.textContent?.trim();
                    const href = link.getAttribute('href');
                    return text === 'Home' && (href === 'index.qmd' || href === './index.qmd' || href === '/index.qmd');
                });
                homeItem = homeLink?.closest('.sidebar-item');
            }
            
            // Method 3: Only as last resort, and only if clicked text is actually "Home"
            if (!homeItem && clickedText === 'Home') {
                homeItem = event.target.closest('.sidebar-item:has(.sidebar-item-text[href*="index"])');
            }
            
            console.log('üè† Home detection result:', {
                foundHomeItem: !!homeItem,
                clickedText: clickedText,
                isActuallyHome: clickedText === 'Home'
            });
            
            if (homeItem && clickedText === 'Home') {
                console.log('üè† Home section collapse trigger clicked - letting Bootstrap handle it');
                
                // Don't interfere with Bootstrap, just log and save state after
                setTimeout(() => {
                    const collapseElement = homeItem.querySelector('.collapse');
                    const chevron = homeItem.querySelector('.bi-chevron-right, .bi-chevron-down');
                    console.log('üè† After Bootstrap handling:', {
                        isExpanded: collapseElement?.classList.contains('show'),
                        chevronClass: chevron?.className
                    });
                }, 100);
            } else {
                console.log('üìÅ Non-Home section clicked:', clickedText, '- handling normally');
                
                // Add detailed debugging for the clicked section immediately after click
                if (clickedText === 'Tools') {
                    setTimeout(() => {
                        console.log('üîß POST-CLICK Tools analysis:');
                        const toolsItem = clickedSidebarItem;
                        const collapseElement = toolsItem?.querySelector('.collapse');
                        const chevron = toolsItem?.querySelector('.bi-chevron-right, .bi-chevron-down');
                        const button = toolsItem?.querySelector('[aria-expanded]');
                        
                        console.log('üîß Tools DOM state after click:', {
                            collapseExists: !!collapseElement,
                            collapseId: collapseElement?.id,
                            collapseClasses: collapseElement?.className,
                            collapseStyle: collapseElement?.style.cssText,
                            collapseDisplay: window.getComputedStyle(collapseElement || {}).display,
                            collapseHeight: window.getComputedStyle(collapseElement || {}).height,
                            collapseOffsetHeight: collapseElement?.offsetHeight,
                            hasShowClass: collapseElement?.classList.contains('show'),
                            ariaExpanded: button?.getAttribute('aria-expanded'),
                            chevronDirection: chevron?.classList.contains('bi-chevron-down') ? 'down' : 'right'
                        });
                        
                        // Check if Bootstrap instance exists and what it thinks
                        if (collapseElement && window.bootstrap?.Collapse) {
                            const instance = window.bootstrap.Collapse.getInstance(collapseElement);
                            console.log('üîß Bootstrap Collapse instance:', {
                                exists: !!instance,
                                isTransitioning: instance?._isTransitioning,
                                element: instance?._element === collapseElement
                            });
                        }
                    }, 150);
                }
            }
            
            // Mark this as a manual click to prevent double-saving from Bootstrap events
            window.sidebarManualClick = true;
            
            // Wait for Bootstrap to update the DOM, then save state
            setTimeout(() => {
                saveSidebarState();
                window.sidebarManualClick = false;
            }, 300);
        }
    }
});

// Also listen for Bootstrap collapse events specifically
document.addEventListener('shown.bs.collapse', function(event) {
    if (event.target.closest('#quarto-sidebar')) {
        console.log('üìÇ Bootstrap collapse shown event');
        
        // CRITICAL FIX: Clear the inline styles that are blocking the display
        const collapseElement = event.target;
        if (collapseElement && collapseElement.classList.contains('collapse')) {
            console.log('üîß Clearing blocking inline styles for:', collapseElement.id);
            collapseElement.style.display = '';    // Remove display: none
            collapseElement.style.height = '';     // Remove height: 0px
            collapseElement.style.visibility = ''; // Remove any visibility blocks
            console.log('‚úÖ Cleared inline styles - element should now be visible');
        }
        
        // Skip if this was triggered by a manual click (already saved)
        if (window.sidebarManualClick) {
            console.log('üö´ Skipping Bootstrap event save - manual click already handled');
            return;
        }
        
        // Skip if restoration is in progress
        if (window.sidebarRestoreInProgress) {
            console.log('üö´ Skipping Bootstrap event save - restoration in progress');
            return;
        }
        
        saveSidebarState();
    }
});

document.addEventListener('hidden.bs.collapse', function(event) {
    if (event.target.closest('#quarto-sidebar')) {
        console.log('üìÅ Bootstrap collapse hidden event');
        
        // Skip if this was triggered by a manual click (already saved)
        if (window.sidebarManualClick) {
            console.log('üö´ Skipping Bootstrap event save - manual click already handled');
            return;
        }
        
        // Skip if restoration is in progress
        if (window.sidebarRestoreInProgress) {
            console.log('üö´ Skipping Bootstrap event save - restoration in progress');
            return;
        }
        
        saveSidebarState();
    }
});

// Listen for navigation links being clicked to save state before page unload
document.addEventListener('click', function(event) {
    try {
        // Check if this is a navigation link (not a sidebar collapse toggle)
        const clickedLink = event.target.closest('a[href]:not([data-bs-toggle]):not([data-bs-target])');
        
        if (clickedLink && !clickedLink.closest('#quarto-sidebar')) {
            // This is a regular navigation link (not in sidebar), save state preemptively
            const href = clickedLink.getAttribute('href');
            
            // Only for internal navigation (not external links)
            if (href && !href.startsWith('http') && !href.startsWith('#')) {
                console.log('üîó Navigation link clicked, saving state preemptively:', href);
                saveSidebarState();
                
                // Also mark this as a potential page transition
                sessionStorage.setItem('pending_navigation', Date.now().toString());
            }
        }
        
        // Also handle sidebar navigation links
        if (clickedLink && clickedLink.closest('#quarto-sidebar') && !clickedLink.closest('[data-bs-toggle]')) {
            const href = clickedLink.getAttribute('href');
            if (href && !href.startsWith('#') && href !== 'javascript:void(0)') {
                console.log('üìÇ Sidebar navigation link clicked, saving state:', href);
                saveSidebarState();
                sessionStorage.setItem('pending_navigation', Date.now().toString());
            }
        }
    } catch (error) {
        console.error('‚ùå Error in navigation click handler:', error);
    }
});

// Also save state when page is about to unload
window.addEventListener('beforeunload', function() {
    try {
        console.log('üîÑ Page unloading, saving final state');
        saveSidebarState();
    } catch (error) {
        console.error('‚ùå Error saving state on unload:', error);
    }
});

// DEBUGGING HELPER - Add to window for easy testing
window.debugSidebar = function() {
    console.log('üîç SIDEBAR DEBUG REPORT');
    console.log('='.repeat(50));
    
    // 1. Check localStorage
    const savedState = localStorage.getItem(SIDEBAR_STATE_KEY);
    console.log('üíæ localStorage state:', savedState);
    if (savedState) {
        try {
            const parsed = JSON.parse(savedState);
            console.log('üíæ Parsed state:', parsed);
        } catch (e) {
            console.error('‚ùå Error parsing localStorage:', e);
        }
    }
    
    // 2. Check sessionStorage
    console.log('üóÇÔ∏è sessionStorage:');
    console.log('   has_visited_site:', sessionStorage.getItem('has_visited_site'));
    console.log('   last_page_load:', sessionStorage.getItem('last_page_load'));
    console.log('   last_url:', sessionStorage.getItem('last_url'));
    console.log('   pending_navigation:', sessionStorage.getItem('pending_navigation'));
    
    // 3. Check current sidebar state
    const sections = getCollapsibleSections();
    console.log('üîç Current sidebar sections:');
    sections.forEach((section, i) => {
        console.log(`   ${i+1}. "${section.text}" - expanded: ${section.isExpanded}`);
    });
    
    // 4. Check page transition detection
    const isTransition = detectPageTransition();
    console.log('üîÑ Page transition detection:', isTransition);
    
    console.log('='.repeat(50));
    return {savedState, sections, isTransition};
};

// Initialize everything when page loads
setTimeout(() => {
    console.log('üîß Initializing sidebar persistence...');
    
    // DEBUG: Check what's in localStorage first
    console.log('üîç Checking localStorage contents...');
    const savedState = localStorage.getItem(SIDEBAR_STATE_KEY);
    if (savedState) {
        try {
            const parsed = JSON.parse(savedState);
            console.log('üíæ Current localStorage state:', parsed);
            console.log('üè† Home state in localStorage:', parsed.home);
        } catch (error) {
            console.error('‚ùå Error parsing localStorage:', error);
        }
    } else {
        console.log('üìÇ No localStorage state found');
    }
    
    // DEBUG: Check Home section structure - moved earlier
    console.log('üîç Starting Home section analysis...');
    const sidebar = document.getElementById('quarto-sidebar');
    
    // Try multiple ways to find Home item
    let homeItem = sidebar?.querySelector('.sidebar-item:has(.sidebar-item-text[href="index.qmd"])');
    if (!homeItem) {
        // Try looking for Home by text content
        const homeLinks = Array.from(sidebar?.querySelectorAll('.sidebar-item-text') || []);
        const homeLink = homeLinks.find(link => link.textContent.trim() === 'Home');
        homeItem = homeLink?.closest('.sidebar-item');
    }
    if (!homeItem) {
        // Try looking for localhost URL
        homeItem = sidebar?.querySelector('.sidebar-item:has(.sidebar-item-text[href*="localhost"])');
    }
    
    const homeChevron = homeItem?.querySelector('.bi-chevron-right, .bi-chevron-down');
    const collapseTarget = homeItem?.querySelector('.collapse');
    
    console.log('üè† Home section debug:', {
        sidebar: !!sidebar,
        homeItem: !!homeItem,
        homeChevron: !!homeChevron,
        collapseTarget: !!collapseTarget,
        chevronDataBsTarget: homeChevron?.closest('[data-bs-target]')?.getAttribute('data-bs-target'),
        collapseId: collapseTarget?.id,
        collapseClasses: collapseTarget?.className,
        homeItemOuterHTML: homeItem?.outerHTML.substring(0, 200) + '...'
    });
    
    // IMMEDIATE HOME FIX: Try direct approach
    if (homeChevron && !homeChevron.hasAttribute('data-home-fixed')) {
        console.log('üîß Adding direct Home chevron handler');
        homeChevron.setAttribute('data-home-fixed', 'true');
        
        // Remove any existing listeners first
        const newChevron = homeChevron.cloneNode(true);
        homeChevron.parentNode.replaceChild(newChevron, homeChevron);
        
        newChevron.addEventListener('click', function(e) {
            try {
                console.log('üè† HOME CHEVRON CLICKED!');
                console.log('üîç Starting debug sequence...');
                
                console.log('üîç Event target:', e.target);
                console.log('üîç Event target classes:', e.target.className);
                console.log('üîç Event target parent:', e.target.parentElement);
                
                e.preventDefault();
                e.stopPropagation();
                
                console.log('üîç Prevented default and stopped propagation');
                
                const trigger = e.target.closest('[data-bs-target]');
                console.log('üéØ Closest trigger element:', trigger);
                
                if (trigger) {
                    console.log('üéØ Trigger classes:', trigger.className);
                    console.log('üéØ Trigger attributes:', trigger.attributes ? Array.from(trigger.attributes).map(attr => `${attr.name}="${attr.value}"`).join(', ') : 'none');
                } else {
                    console.log('‚ùå No trigger element found');
                }
                
                const targetSelector = trigger?.getAttribute('data-bs-target');
                console.log('üéØ Target selector:', targetSelector);
                
                if (targetSelector && targetSelector !== '#' && targetSelector.length > 1) {
                    console.log('‚úÖ Valid target selector found, looking for element...');
                    const targetElement = document.querySelector(targetSelector);
                    console.log('üéØ Target element found:', !!targetElement);
                    console.log('üéØ Target element:', targetElement);
                    
                    if (targetElement) {
                        console.log('üéØ Target element classes:', targetElement.className);
                        const isExpanded = targetElement.classList.contains('show');
                        console.log('üìä Current state:', isExpanded ? 'expanded' : 'collapsed');
                        
                        console.log('ÔøΩ About to toggle state...');
                        if (isExpanded) {
                            targetElement.classList.remove('show');
                            e.target.classList.remove('bi-chevron-down');
                            e.target.classList.add('bi-chevron-right');
                            console.log('üîº Collapsed Home section');
                        } else {
                            targetElement.classList.add('show');
                            e.target.classList.remove('bi-chevron-right');
                            e.target.classList.add('bi-chevron-down');
                            console.log('üîΩ Expanded Home section');
                        }
                        
                        console.log('ÔøΩ Scheduling state save...');
                        setTimeout(saveSidebarState, 100);
                        console.log('‚úÖ All operations completed');
                    } else {
                        console.log('‚ùå Target element not found for selector:', targetSelector);
                    }
                } else {
                    console.log('‚ùå Invalid or empty target selector:', targetSelector);
                    console.log('üîç Attempting manual collapse target detection...');
                    
                    // Try to find the collapse element manually
                    const homeItem = e.target.closest('.sidebar-item');
                    let targetElement = homeItem?.querySelector('.collapse');
                    
                    if (!targetElement) {
                        // Look for a sibling collapse element
                        const nextSibling = homeItem?.nextElementSibling;
                        if (nextSibling?.classList.contains('collapse')) {
                            targetElement = nextSibling;
                        }
                    }
                    
                    console.log('üéØ Manual target element found:', !!targetElement);
                    console.log('üéØ Manual target element:', targetElement);
                    
                    if (targetElement) {
                        console.log('üéØ Manual target element classes:', targetElement.className);
                        const isExpanded = targetElement.classList.contains('show');
                        console.log('üìä Current state:', isExpanded ? 'expanded' : 'collapsed');
                        
                        console.log('üîÑ About to toggle state...');
                        if (isExpanded) {
                            targetElement.classList.remove('show');
                            e.target.classList.remove('bi-chevron-down');
                            e.target.classList.add('bi-chevron-right');
                            console.log('üîº Collapsed Home section');
                        } else {
                            targetElement.classList.add('show');
                            e.target.classList.remove('bi-chevron-right');
                            e.target.classList.add('bi-chevron-down');
                            console.log('üîΩ Expanded Home section');
                        }
                        
                        // IMPORTANT: Force state save immediately for Home section
                        console.log('üíæ Force saving Home state immediately...');
                        setTimeout(() => {
                            const newState = !isExpanded; // The new expanded state
                            console.log('üíæ Home new state should be:', newState);
                            
                            // Get current state from localStorage
                            const currentSavedState = localStorage.getItem(SIDEBAR_STATE_KEY);
                            if (currentSavedState) {
                                try {
                                    const parsedState = JSON.parse(currentSavedState);
                                    parsedState.home = parsedState.home || {};
                                    parsedState.home.isExpanded = newState;
                                    parsedState.home.text = 'Home';
                                    parsedState.home.lastUpdate = Date.now(); // Add timestamp
                                    parsedState.home.children = parsedState.home.children || {};
                                    localStorage.setItem(SIDEBAR_STATE_KEY, JSON.stringify(parsedState));
                                    console.log('üíæ‚úÖ Home state force-saved as:', newState, 'with timestamp');
                                } catch (error) {
                                    console.error('üíæ‚ùå Error force-saving Home state:', error);
                                }
                            }
                            
                            // Also trigger the normal state saving
                            saveSidebarState();
                        }, 100);
                        console.log('‚úÖ Manual operations completed');
                    } else {
                        console.log('‚ùå No collapse target found manually either');
                        console.log('üîç Available collapse elements in sidebar:');
                        const allCollapses = document.querySelectorAll('#quarto-sidebar .collapse');
                        allCollapses.forEach((el, i) => {
                            console.log(`  Collapse ${i}: id="${el.id}" classes="${el.className}"`);
                        });
                    }
                }
                
            } catch (error) {
                console.error('üí• ERROR in Home chevron handler:', error);
                console.error('üí• Error stack:', error.stack);
            }
        });
        
        console.log('‚úÖ Home chevron handler added');
    } else if (homeChevron && homeChevron.hasAttribute('data-home-fixed')) {
        console.log('‚ö†Ô∏è Home chevron already has handler');
    } else {
        console.log('‚ùå Home chevron not found');
        // Debug: Let's see what we can find
        console.log('üîç Available sidebar items:');
        const allItems = sidebar?.querySelectorAll('.sidebar-item') || [];
        allItems.forEach((item, index) => {
            const link = item.querySelector('.sidebar-item-text');
            const chevron = item.querySelector('.bi-chevron-right, .bi-chevron-down');
            console.log(`  Item ${index}: "${link?.textContent?.trim()}" href="${link?.href}" hasChevron=${!!chevron}`);
        });
    }
    
    // PHASE 1: Pre-render collapse (silent, no persistence)
    preRenderCollapseAll();
    
    // PHASE 2: Progressive restore (visible, with animations)  
    setTimeout(() => {
        progressivelyRestoreSidebarState();
    }, 100);
    
}, 1000);

// Save state when page unloads
window.addEventListener('beforeunload', function() {
    saveSidebarState();
});

// DEBUG: Add debugging to understand state restoration issue
function debugStateRestoration() {
    console.log('üêõ DEBUG: Analyzing state restoration...');
    
    const savedState = localStorage.getItem(SIDEBAR_STATE_KEY);
    if (!savedState) {
        console.log('üêõ DEBUG: No saved state found');
        return;
    }
    
    try {
        const state = JSON.parse(savedState);
        console.log('üêõ DEBUG: Saved state structure:', state);
        console.log('üêõ DEBUG: Saved state keys:', Object.keys(state));
        
        // Check Home state specifically
        if (state['home']) {
            console.log('üêõ DEBUG: Home state found:', state['home']);
        } else {
            console.log('üêõ DEBUG: No Home state found');
        }
        
        // Check Events state specifically
        if (state['events']) {
            console.log('üêõ DEBUG: Events state found:', state['events']);
        } else {
            console.log('üêõ DEBUG: No Events state found');
        }
        
        // Check what sections we have
        const sections = getCollapsibleSections();
        console.log('üêõ DEBUG: Found sections:', sections.map(s => ({
            text: s.text,
            isExpanded: s.isExpanded,
            hierarchicalPath: s.hierarchicalPath
        })));
        
    } catch (error) {
        console.error('üêõ DEBUG: Error parsing saved state:', error);
    }
}

// Run debug after DOM is ready
setTimeout(() => {
    debugStateRestoration();
}, 2000);

console.log('‚úÖ Sidebar persistence system initialized');
</script>
