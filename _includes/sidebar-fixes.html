<!-- Sidebar styling and fixes -->
<style>
/* Home link special styling - make it white and prominent */
.sidebar .nav-link[href="index.qmd"],
.sidebar .sidebar-item-text[href="index.qmd"],
.sidebar a[href="index.qmd"],
.sidebar-navigation .sidebar-item-text[href="index.qmd"],
#quarto-sidebar .sidebar-item-text[href="index.qmd"] {
  font-weight: 600 !important;
  font-size: 1.1rem !important;
  color: white !important;
  background: linear-gradient(135deg, #2780e3 0%, #1967d2 100%) !important;
  border: 2px solid #2780e3 !important;
  margin-bottom: 1rem !important;
  padding: 0.8rem 1rem !important;
  border-radius: 12px !important;
  box-shadow: 0 3px 8px rgba(39, 128, 227, 0.3) !important;
  transition: all 0.3s ease !important;
  display: block !important;
}

.sidebar .nav-link[href="index.qmd"]:hover,
.sidebar .sidebar-item-text[href="index.qmd"]:hover,
.sidebar a[href="index.qmd"]:hover,
.sidebar-navigation .sidebar-item-text[href="index.qmd"]:hover,
#quarto-sidebar .sidebar-item-text[href="index.qmd"]:hover {
  background: linear-gradient(135deg, #1967d2 0%, #1557b0 100%) !important;
  transform: translateX(3px) translateY(-1px) !important;
  box-shadow: 0 6px 16px rgba(39, 128, 227, 0.4) !important;
  border-color: #1967d2 !important;
  color: white !important;
}

/* Ensure sidebar icons work with emoji fallback */
.sidebar-navigation .sidebar-item-text {
    display: inline-flex;
    align-items: center;
}

/* FIXED: Left sidebar hierarchical indentation and spacing */
/* Reset all sidebar items to consistent baseline */
#quarto-sidebar .sidebar-item {
  margin-bottom: 0.1rem;
}

/* Base styling for all sidebar item texts */
#quarto-sidebar .sidebar-item-text {
  display: flex;
  align-items: center;
  gap: 0 !important; /* Remove the 0.5rem gap */
  line-height: 1.3;
  border-radius: 4px;
  transition: all 0.2s ease;
}

/* Level 0 (Root level): "Home", "Events", "Tools", etc. */
#quarto-sidebar > .sidebar-navigation > .sidebar-item > .sidebar-item-text {
  font-weight: 600 !important;
  font-size: 0.95rem !important;
  padding: 0.4rem 0.75rem !important;
  color: #2d3748 !important;
}

/* Level 1 (First nested): "Build Conference 2025", "Development Tools", etc. */
#quarto-sidebar .sidebar-item .sidebar-item > .sidebar-item-text {
  font-weight: 500 !important;
  font-size: 0.9rem !important;
  padding: 0.3rem 0.75rem !important;
  padding-left: 1.5rem !important; /* Indent from level 0 */
  color: #4a5568 !important;
}

/* Level 2 (Second nested): "Git Command Line", "HTTP Files Testing", etc. */
#quarto-sidebar .sidebar-item .sidebar-item .sidebar-item > .sidebar-item-text {
  font-weight: 400 !important;
  font-size: 0.85rem !important;
  padding: 0.25rem 0.75rem !important;
  padding-left: 2.25rem !important; /* Further indent from level 1 */
  color: #718096 !important;
}

/* Level 3 (Third nested): Deep nested items */
#quarto-sidebar .sidebar-item .sidebar-item .sidebar-item .sidebar-item > .sidebar-item-text {
  font-weight: 400 !important;
  font-size: 0.8rem !important;
  padding: 0.2rem 0.75rem !important;
  padding-left: 3rem !important; /* Further indent from level 2 */
  color: #a0aec0 !important;
}

/* Hover effects for better UX */
#quarto-sidebar .sidebar-item-text:hover {
  background-color: rgba(237, 242, 247, 0.8) !important;
}

/* Active state styling - hierarchical specificity */
#quarto-sidebar .sidebar-item-text.active {
  background-color: rgba(39, 128, 227, 0.1) !important;
  color: #2780e3 !important;
  border-left: 3px solid #2780e3 !important;
}

/* Override any conflicting container-based rules */
#quarto-sidebar .sidebar-item-container .sidebar-item-text,
#quarto-sidebar .sidebar-section .sidebar-item-text {
  /* Reset any container-specific padding - let hierarchy rules take precedence */
  padding: inherit !important;
}

/* Ensure icons align properly at all levels */
#quarto-sidebar .sidebar-item-text i,
#quarto-sidebar .sidebar-item-text .bi {
  flex-shrink: 0;
  width: 1em;
  text-align: center;
  margin-right: 0.5rem !important;
}

/* Collapse search component to minimize space */
.sidebar-search,
#quarto-search,
.mt-2.flex-shrink-0.align-items-center {
  max-height: 0 !important;
  overflow: hidden !important;
  opacity: 0 !important;
  margin: 0 !important;
  padding: 0 !important;
  border: none !important;
  transition: all 0.3s ease !important;
}

/* Fix sidebar alignment and remove unnecessary margins */
#quarto-sidebar {
  padding-top: 0 !important;
  margin-top: 0 !important;
}

/* Remove any unwanted spacing at the top of sidebar content */
#quarto-sidebar .sidebar-menu-container,
#quarto-sidebar .sidebar-navigation {
  margin-top: 0 !important;
  padding-top: 0 !important;
}

/* Make left sidebar align like right sidebar without breaking content */
#quarto-sidebar {
  position: sticky !important;
  top: 0 !important;
  align-self: flex-start !important;
  max-height: 100vh !important;
  overflow-y: auto !important;
}

/* Simulate the margin-sidebar wrapper div behavior */
#quarto-sidebar {
  /* Add the same margin-top that .sidebar.margin-sidebar has */
  margin-top: 1rem !important;
  margin-bottom: 1rem !important;
  padding: 0 !important;
  
  /* Wrapper div properties */
  display: block !important;
  width: auto !important;
  min-height: 0 !important;
  flex-shrink: 0 !important;
  box-sizing: border-box !important;
}

/* Ensure right sidebar has consistent behavior */
.quarto-margin-sidebar {
  margin-top: 1rem !important;
  padding-top: 0 !important;
}
</style>

<script>
// IMMEDIATE TEST - This should show up right away
console.log('🚀 SIDEBAR SCRIPT WITH HIERARCHICAL PERSISTENCE LOADING...');
console.log('Current time:', new Date().toLocaleTimeString());

// Clear localStorage for testing (uncomment to reset)
// localStorage.removeItem('learningHubSidebarState');
// console.log('🧹 Cleared existing localStorage for fresh start');

// Debug current localStorage content
const existingState = localStorage.getItem('learningHubSidebarState');
if (existingState) {
    console.log('📂 Existing localStorage state found:', JSON.parse(existingState));
} else {
    console.log('📂 No existing localStorage state found');
}

// Storage key for sidebar state
const SIDEBAR_STATE_KEY = 'learningHubSidebarState';

// Function to build hierarchical path for unique identification
function buildHierarchicalPath(element) {
    const path = [];
    let current = element;
    
    // Walk up the DOM tree to build the path
    while (current && !current.matches('#quarto-sidebar')) {
        if (current.matches('.sidebar-item')) {
            const textElement = current.querySelector('.sidebar-item-text');
            if (textElement) {
                const text = textElement.textContent?.trim();
                if (text) {
                    path.unshift(text); // Add to the beginning of the array
                }
            }
        }
        current = current.parentElement;
    }
    
    const finalPath = path.join(' > ') || 'unknown';
    return finalPath;
}

// Test if we can find the sidebar immediately
setTimeout(() => {
    const sidebar = document.getElementById('quarto-sidebar');
    console.log('🎯 Sidebar element found?', !!sidebar);
    if (sidebar) {
        console.log('📏 Sidebar HTML length:', sidebar.innerHTML.length);
        console.log('🔍 Sidebar children count:', sidebar.children.length);
    }
}, 100);

// Function to get all collapsible sections in the sidebar
function getCollapsibleSections() {
    const sidebar = document.getElementById('quarto-sidebar');
    if (!sidebar) return [];
    
    const sections = [];
    const chevrons = sidebar.querySelectorAll('.bi-chevron-right, .bi-chevron-down');
    
    console.log(`🔍 Found ${chevrons.length} chevron icons`);
    
    chevrons.forEach((chevron, index) => {
        const sidebarItem = chevron.closest('.sidebar-item');
        const sidebarText = sidebarItem?.querySelector('.sidebar-item-text');
        
        console.log(`Chevron ${index + 1}:`, {
            text: sidebarText?.textContent?.trim(),
            hasDataBsToggle: !!chevron.closest('[data-bs-toggle]'),
            hasDataBsTarget: !!chevron.closest('[data-bs-target]'),
            hasAriaExpanded: !!chevron.closest('[aria-expanded]'),
            chevronClasses: chevron.className
        });
        
        if (sidebarText && sidebarItem) {
            const text = sidebarText.textContent?.trim();
            const hierarchicalPath = buildHierarchicalPath(sidebarItem);
            
            // Check visibility of nested content
            const immediateChildren = Array.from(sidebarItem.children).filter(child => 
                child.classList && (child.classList.contains('sidebar-item') || child.classList.contains('sidebar-section'))
            );
            
            const nestedItems = sidebarItem.querySelectorAll(':scope > .sidebar-item, :scope > .sidebar-section, :scope .sidebar-item-container > .sidebar-item');
            
            const hasVisibleNestedContent = Array.from(nestedItems).some(item => {
                const computedStyle = window.getComputedStyle(item);
                return computedStyle.display !== 'none' && 
                       computedStyle.visibility !== 'hidden' &&
                       item.offsetHeight > 0 &&
                       item.offsetWidth > 0;
            });
            
            // Check Bootstrap collapse classes
            const parentCollapse = sidebarItem.querySelector('.collapse');
            const hasShowClass = parentCollapse ? parentCollapse.classList.contains('show') : false;
            
            // Check aria-expanded attribute
            const button = sidebarItem.querySelector('[aria-expanded]');
            const ariaExpanded = button ? button.getAttribute('aria-expanded') === 'true' : null;
            
            // Determine expanded state with priority
            let isExpanded;
            if (ariaExpanded !== null) {
                isExpanded = ariaExpanded;
            } else if (hasShowClass) {
                isExpanded = true;
            } else {
                isExpanded = hasVisibleNestedContent;
            }
            
            const safeId = hierarchicalPath
                .replace(/[^a-zA-Z0-9\s>/]/g, '')
                .replace(/\s+/g, '_')
                .replace(/>/g, '__')
                .substring(0, 100)
                .toLowerCase();
            
            sections.push({
                element: sidebarItem,
                text: text,
                hierarchicalPath: hierarchicalPath,
                chevron: chevron,
                isExpanded: isExpanded,
                id: safeId
            });
        }
    });
    
    console.log(`📋 Found ${sections.length} collapsible sections`);
    return sections;
}

// Save sidebar state to localStorage using hierarchical structure
function saveSidebarState() {
    try {
        const sections = getCollapsibleSections();
        const hierarchicalState = {};
        
        sections.forEach(section => {
            // Build the path array from hierarchicalPath
            const pathParts = section.hierarchicalPath.split(' > ').map(part => 
                part.replace(/[^a-zA-Z0-9\s]/g, '').replace(/\s+/g, '_').toLowerCase()
            );
            
            // Navigate/create the nested structure
            let current = hierarchicalState;
            pathParts.forEach((part, index) => {
                if (!current[part]) {
                    current[part] = {
                        text: section.hierarchicalPath.split(' > ')[index],
                        isExpanded: false,
                        children: {}
                    };
                }
                
                // If this is the final part, update with actual state
                if (index === pathParts.length - 1) {
                    current[part].isExpanded = section.isExpanded;
                } else {
                    current = current[part].children;
                }
            });
        });
        
        localStorage.setItem(SIDEBAR_STATE_KEY, JSON.stringify(hierarchicalState));
        console.log(`💾 Saved state for ${sections.length} sections`);
        
    } catch (error) {
        console.error('❌ Failed to save sidebar state:', error);
    }
}

// Restore sidebar state from localStorage using hierarchical structure
function restoreSidebarState() {
    try {
        const savedState = localStorage.getItem(SIDEBAR_STATE_KEY);
        if (!savedState) {
            console.log('📂 No saved sidebar state found');
            return;
        }
        
        const hierarchicalState = JSON.parse(savedState);
        console.log('🔄 Restoring sidebar state...');
        
        const sections = getCollapsibleSections();
        
        // Helper function to find state in nested structure
        function findStateInHierarchy(pathParts, state) {
            let current = state;
            for (const part of pathParts) {
                const safePart = part.replace(/[^a-zA-Z0-9\s]/g, '').replace(/\s+/g, '_').toLowerCase();
                if (current[safePart]) {
                    current = current[safePart];
                    if (pathParts.indexOf(part) < pathParts.length - 1) {
                        current = current.children || {};
                    }
                } else {
                    return null; // Path not found
                }
            }
            return current;
        }
        
        let restoredCount = 0;
        sections.forEach(section => {
            const pathParts = section.hierarchicalPath.split(' > ');
            const savedSection = findStateInHierarchy(pathParts, hierarchicalState);
            
            if (savedSection) {
                const shouldBeExpanded = savedSection.isExpanded;
                const isCurrentlyExpanded = section.isExpanded;
                
                // If state doesn't match, click the chevron to toggle it
                if (shouldBeExpanded !== isCurrentlyExpanded) {
                    setTimeout(() => {
                        section.chevron.click();
                        restoredCount++;
                    }, 100);
                }
            }
        });
        
        if (restoredCount > 0) {
            console.log(`✅ Restored ${restoredCount} sections`);
        }
        
    } catch (error) {
        console.error('❌ Failed to restore sidebar state:', error);
    }
}

// Enhanced click detection with state saving
document.addEventListener('click', function(event) {
    // If it's in the sidebar, check if it's a chevron click
    if (event.target.closest('#quarto-sidebar')) {
        
        // Check if this is a chevron click (collapse/expand action)
        if (event.target.classList.contains('bi-chevron-right') || 
            event.target.classList.contains('bi-chevron-down') ||
            event.target.closest('.bi-chevron-right') ||
            event.target.closest('.bi-chevron-down')) {
            
            console.log('🔄 Chevron clicked - saving state...');
            
            // Wait for the DOM to update after the click, then save state
            setTimeout(() => {
                saveSidebarState();
            }, 300);
        }
    }
});

// Initialize everything when page loads
setTimeout(() => {
    console.log('🔧 Initializing sidebar persistence...');
    
    // First, restore any saved state
    setTimeout(() => {
        restoreSidebarState();
    }, 500);
    
    // Save initial state after restoration
    setTimeout(() => {
        saveSidebarState();
    }, 1500);
    
}, 1000);

// Save state when page unloads
window.addEventListener('beforeunload', function() {
    saveSidebarState();
});

console.log('✅ Sidebar persistence system initialized');
</script>
