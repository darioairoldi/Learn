<div id="custom-right-nav" style="display: none;">
  <div class="toc-title">Related Pages</div>
  <nav class="toc" role="doc-toc">
    <ul>
      <li><em>Loading...</em></li>
    </ul>
  </nav>
</div>

<style>
/* Professional Related Pages navigation styling - RIGHT SIDEBAR ONLY */
#custom-right-nav {
  width: 100%;
  background: #f8f9fa;
  border: 1px solid #e9ecef;
  border-radius: 6px;
  padding: 12px;
  margin-top: 2rem; /* Add spacing from native TOC */
  font-size: 0.9rem;
  max-height: 60vh; /* Reduced from 70vh to leave space for native TOC */
  overflow-y: auto;
  scroll-behavior: smooth;
}

/* Ensure our custom nav doesn't interfere with native TOC styling */
#custom-right-nav.custom-navigation {
  background: #f0f8ff; /* Slightly different background to distinguish from native TOC */
  border-color: #2780e3;
}

#custom-right-nav .toc-title {
  font-weight: 600;
  font-size: 1rem;
  color: #2780e3;
  margin-bottom: 12px;
  padding-bottom: 6px;
  border-bottom: 2px solid #2780e3;
}

/* Ensure native TOC is not affected by our styles */
#TOC, 
.table-of-contents:not(#custom-right-nav .table-of-contents),
nav[role="doc-toc"]:not(#custom-right-nav nav) {
  margin-bottom: 1rem !important;
}

/* Styling for section labels in Related Pages */
.nav-section-label {
  display: block;
  padding: 0.25rem 0;
  color: #2780e3;
  font-weight: 600;
  text-decoration: none;
}

/* Styling for navigation links in Related Pages */
#custom-right-nav .nav-link {
  display: block;
  padding: 0.25rem 0;
  color: #495057;
  text-decoration: none;
  border-radius: 3px;
  transition: all 0.2s ease;
}

#custom-right-nav .nav-link:hover {
  color: #2780e3;
  text-decoration: none;
  background-color: rgba(39, 128, 227, 0.1);
  padding-left: 0.5rem;
}

/* Active (current page) styling in Related Pages */
#custom-right-nav .nav-link.active {
  color: #2780e3;
  font-weight: 600;
  background-color: rgba(39, 128, 227, 0.15);
  padding-left: 0.5rem;
  border-left: 3px solid #2780e3;
}
</style>

<script>
document.addEventListener('DOMContentLoaded', function() {
  console.log('üìã Related Pages navigation loading...');
  
  // Global navigation structure from navigation.json
  let navigationConfig = null;
  
  // Wrap everything in try-catch to prevent other JS errors from breaking this
  try {
    // Load navigation configuration (much cleaner than YAML parsing!)
    async function loadNavigationConfig() {
      try {
        console.log('üîÑ Loading navigation.json configuration...');
        
        // FIXED: Properly construct the navigation.json URL for GitHub Pages
        let navUrl;
        
        // For GitHub Pages, we need to construct the URL based on the current location
        const currentUrl = window.location.href;
        const currentPath = window.location.pathname;
        
        if (currentUrl.includes('darioairoldi.github.io/Learn')) {
          // We're on GitHub Pages - navigation.json should be at the Learn root
          navUrl = 'https://darioairoldi.github.io/Learn/navigation.json';
        } else if (currentPath.includes('/Learn/')) {
          // Local or other hosting with Learn in path
          const learnIndex = currentPath.indexOf('/Learn/');
          const basePath = currentPath.substring(0, learnIndex + 6); // Include '/Learn/'
          navUrl = window.location.origin + basePath + 'navigation.json';
        } else {
          // Fallback to root
          navUrl = window.location.origin + '/navigation.json';
        }
        
        console.log('üîç Attempting to load navigation from:', navUrl);
        
        const response = await fetch(navUrl);
        if (response.ok) {
          navigationConfig = await response.json();
          console.log('‚úÖ Loaded navigation config:', navigationConfig);
          
          // Validate the structure
          if (navigationConfig && navigationConfig.contents && Array.isArray(navigationConfig.contents)) {
            console.log('‚úÖ Navigation structure is valid with', navigationConfig.contents.length, 'top-level items');
            // Re-render navigation with config data
            renderRightNav();
          } else {
            console.log('‚ö†Ô∏è Invalid navigation structure, falling back to DOM parsing');
            navigationConfig = null;
            renderRightNav();
          }
        } else {
          console.log('‚ö†Ô∏è Could not load navigation.json (HTTP', response.status, '), falling back to DOM parsing');
          renderRightNav(); // Fall back to DOM parsing
        }
      } catch (error) {
        console.log('‚ö†Ô∏è Error loading navigation.json:', error);
        renderRightNav(); // Fall back to DOM parsing
      }
    }
    
    // Handle responsive layout function
    function handleResponsiveLayout() {
      const customNav = document.querySelector('#custom-right-nav');
      if (!customNav) return;
      
      const isMobile = window.innerWidth <= 800;
      
      if (isMobile) {
        customNav.style.display = 'none';
      } else if (customNav.classList.contains('has-content')) {
        customNav.style.display = 'block';
      }
    }
    
    // Initialize right navigation with minimal delay
    function initializeRightNav() {
      console.log('üöÄ Initializing right navigation...');
      
      try {
        setTimeout(() => {
          createCustomRightNav();
          handleResponsiveLayout();
          // Load config after creating nav
          loadNavigationConfig();
        }, 300);
      } catch (error) {
        console.error('‚ùå Error in initializeRightNav:', error);
      }
    }
    
    // Try immediately for any page
    initializeRightNav();
    
    // Also try when the page is fully loaded
    window.addEventListener('load', function() {
      console.log('üìÑ Page loaded, rendering right nav...');
      try {
        setTimeout(renderRightNav, 200);
      } catch (error) {
        console.error('‚ùå Error in load event:', error);
      }
    });
    
    // Handle window resize
    window.addEventListener('resize', handleResponsiveLayout);
    
    // ALSO: Listen for sidebar clicks to trigger updates
    document.addEventListener('click', function(event) {
      try {
        // Check if a sidebar item was clicked
        const sidebarItem = event.target.closest('.sidebar-item-text, .nav-link');
        if (sidebarItem && sidebarItem.closest('#quarto-sidebar')) {
          console.log('üñ±Ô∏è Sidebar item clicked:', sidebarItem.textContent.trim());
          // Delay slightly to let Quarto update the active states
          setTimeout(renderRightNav, 100);
        }
      } catch (error) {
        console.error('‚ùå Error in click handler:', error);
      }
    });
    
    // Get current page path - ENHANCED VERSION
    function getCurrentPagePath() {
      try {
        let path = window.location.pathname;
        
        if (path === '/' || path === '') {
          return 'index';
        }
        
        // Remove leading slash and decode URI components
        path = path.replace(/^\//, '');
        try {
          path = decodeURIComponent(path);
        } catch (e) {
          console.log('‚ö†Ô∏è URI decoding failed');
        }
        
        // Remove .html extension and normalize
        path = path.replace('.html', '');
        
        // DEBUG: Log the path processing with more detail
        console.log('üîç Original pathname:', window.location.pathname);
        console.log('üîç After decoding:', path);
        
        // For GitHub Pages, remove the repo name prefix if present
        if (path.startsWith('Learn/')) {
          path = path.substring(5); // Remove "Learn/"
          console.log('üîç After removing Learn prefix:', path);
        }
        
        console.log('üîç Final processed path:', path);
        
        return path;
      } catch (error) {
        console.error('‚ùå Error in getCurrentPagePath:', error);
        return '';
      }
    }
    
    // ENHANCED: Use navigation.json config if available, fall back to DOM parsing
    function findCurrentPageSiblings() {
      try {
        if (navigationConfig && navigationConfig.contents) {
          console.log('‚úÖ Using navigation.json configuration for navigation');
          return findSiblingsFromConfig();
        } else {
          console.log('‚ö†Ô∏è Using DOM parsing fallback');
          return findSiblingsFromDOM();
        }
      } catch (error) {
        console.error('‚ùå Error in findCurrentPageSiblings:', error);
        return null;
      }
    }
    
    // Find siblings using navigation.json configuration - FIXED VERSION
    function findSiblingsFromConfig() {
      const currentPath = getCurrentPagePath();
      console.log('üîç Looking for current page in config:', currentPath);
      
      // Find current item in the configuration
      const result = findItemInConfig(navigationConfig.contents, currentPath);
      if (!result) {
        console.log('‚ùå Current page not found in config');
        return [];
      }
      
      const { item, parent, siblings } = result;
      console.log('‚úÖ Found current item:', item.text || item.section);
      console.log('üîç Item has contents:', !!(item.contents && item.contents.length > 0));
      console.log('üîç Parent exists:', !!parent);
      
      if (item.contents && item.contents.length > 0) {
        // This is a section with children - show ONLY first-level children
        console.log('üìÇ Section node - showing first-level children');
        
        // Get all direct children
        const directChildren = item.contents || [];
        console.log('üîç Direct children count:', directChildren.length);
        
        // Filter to show meaningful navigation items
        const meaningfulChildren = directChildren.filter(child => {
          // Include if it has a section name (indicates it's a navigable section)
          if (child.section) return true;
          
          // Include if it has text and href (indicates it's a navigable page) 
          if (child.text && child.href && child.href !== '#') return true;
          
          // Exclude items that are just structural without navigation value
          return false;
        });
        
        console.log('üìÇ Meaningful children found:', meaningfulChildren.length);
        console.log('üìÇ Children details:', meaningfulChildren.map(c => ({
          section: c.section, 
          text: c.text, 
          href: c.href,
          hasContents: !!(c.contents && c.contents.length > 0)
        })));
        
        // Prefer sections over individual pages for cleaner navigation
        const sectionsOnly = meaningfulChildren.filter(child => child.section);
        const pagesToShow = sectionsOnly.length > 0 ? sectionsOnly : meaningfulChildren;
        
        console.log('üìÇ Final pages to show:', pagesToShow.length);
        
        return pagesToShow.map(child => ({
          text: child.text || child.section,
          href: child.href || '#',
          isActive: false,
          isSection: !!child.section
        }));
      } else {
        // This is a leaf page - show ALL siblings including the current one
        console.log('üìÑ Leaf node - showing ALL siblings (including current)');
        
        if (!parent || !parent.contents) {
          console.log('üìÑ No parent or parent contents found');
          return [];
        }
        
        const allSiblings = parent.contents || [];
        console.log('üîç Total siblings (including self):', allSiblings.length);
        
        // Filter siblings - INCLUDE the current item and all navigable siblings
        const siblingItems = allSiblings.filter(sibling => {
          // Include items with href (including current item)
          if (sibling.href && sibling.href !== '#') return true;
          
          // Include sections (including current item)
          if (sibling.section) return true;
          
          return false;
        });
        
        console.log('üìÑ All siblings (including current):', siblingItems.length);
        console.log('üìÑ Sibling details:', siblingItems.map(s => ({
          section: s.section,
          text: s.text,
          href: s.href,
          isCurrent: s === item
        })));
        
        return siblingItems.map(sibling => ({
          text: sibling.text || sibling.section,
          href: sibling.href,
          isActive: sibling === item,  // Mark current item as active
          isSection: !!sibling.section
        }));
      }
    }
    
    // Recursively find item in config structure - ENHANCED VERSION
    function findItemInConfig(items, targetPath, parent = null) {
      if (!items || !Array.isArray(items)) return null;
      
      console.log('üîç Searching in', items.length, 'items for path:', targetPath);
      
      for (let i = 0; i < items.length; i++) {
        const item = items[i];
        console.log(`üîç Checking item ${i + 1}:`, {
          section: item.section,
          text: item.text,
          href: item.href,
          hasContents: !!(item.contents && item.contents.length > 0)
        });
        
        if (item.href && pathsMatch(item.href, targetPath)) {
          console.log('‚úÖ Found matching item:', item.text || item.section);
          return { 
            item, 
            parent, 
            siblings: parent ? parent.contents : items 
          };
        }
        
        // If this item is a section without direct href, check if the path might belong to it
        if (item.section && !item.href && item.contents && item.contents.length > 0) {
          console.log('üîç Checking section contents for:', item.section);
          const found = findItemInConfig(item.contents, targetPath, item);
          if (found) return found;
        }
        
        // If this item has contents, search recursively
        if (item.contents && item.contents.length > 0) {
          console.log('üîç Searching recursively in:', item.text || item.section);
          const found = findItemInConfig(item.contents, targetPath, item);
          if (found) return found;
        }
      }
      
      console.log('‚ùå No item found at this level');
      return null;
    }
    
    // Check if two paths match (with various normalizations) - ENHANCED VERSION
    function pathsMatch(configPath, currentPath) {
      if (!configPath || !currentPath) return false;
      
      const normalize = (path) => {
        return path.toLowerCase()
          .replace(/\\/g, '/')
          .replace(/\.(md|html|qmd)$/, '')
          .replace(/^\/+/, '')
          .replace(/\/+$/, '')
          .trim();
      };
      
      const normalizedConfig = normalize(configPath);
      const normalizedCurrent = normalize(currentPath);
      
      console.log('üîç Path matching - Config:', normalizedConfig, 'Current:', normalizedCurrent);
      
      // Direct match (highest priority)
      if (normalizedConfig === normalizedCurrent) {
        console.log('‚úÖ Direct path match');
        return true;
      }
      
      // Handle GitHub Pages paths (remove Learn/ prefix from current path if present)
      const currentWithoutRepo = normalizedCurrent.replace(/^learn\//, '');
      if (normalizedConfig === currentWithoutRepo) {
        console.log('‚úÖ Path match after removing repo prefix');
        return true;
      }
      
      // Check if current path ends with config path (for subdirectory matching)
      if (normalizedCurrent.endsWith(normalizedConfig)) {
        // But ensure it's a meaningful match, not just filename
        const configParts = normalizedConfig.split('/');
        const currentParts = normalizedCurrent.split('/');
        
        // Only match if we have at least 2 path segments matching
        if (configParts.length >= 2 && currentParts.length >= configParts.length) {
          const configLastTwo = configParts.slice(-2).join('/');
          const currentMatchingParts = currentParts.slice(-configParts.length).join('/');
          
          if (configLastTwo === currentMatchingParts.split('/').slice(-2).join('/')) {
            console.log('‚úÖ Path match - meaningful directory structure match');
            return true;
          }
        }
      }
      
      // Check if config path ends with current path (for parent directory matching)
      if (normalizedConfig.endsWith(normalizedCurrent)) {
        console.log('‚úÖ Path match - config ends with current');
        return true;
      }
      
      // LAST RESORT: Filename-based matching (but with stricter conditions)
      const configParts = normalizedConfig.split('/');
      const currentParts = normalizedCurrent.split('/');
      
      // Only do filename matching if the directory context is similar
      if (configParts.length >= 2 && currentParts.length >= 2) {
        const configLast = configParts[configParts.length - 1];
        const currentLast = currentParts[currentParts.length - 1];
        
        // Check if both the filename AND parent directory have some similarity
        const configParent = configParts[configParts.length - 2];
        const currentParent = currentParts[currentParts.length - 2];
        
        if (configLast === currentLast && 
            (configParent === currentParent || 
             configParent.includes(currentParent) || 
             currentParent.includes(configParent))) {
          console.log('‚úÖ Contextual filename-based path match');
          return true;
        }
      }
      
      console.log('‚ùå No path match found');
      return false;
    }
    
    // Fallback DOM parsing - UPDATED TO SHOW FIRST-LEVEL SECTIONS
    function findSiblingsFromDOM() {
      const sidebar = document.querySelector('#quarto-sidebar');
      if (!sidebar) return [];
      
      const activeItem = sidebar.querySelector('.sidebar-item-text.active');
      if (!activeItem) return [];
      
      console.log('üîç DOM: Active item found:', activeItem.textContent.trim());
      
      const activeContainer = activeItem.closest('.sidebar-item');
      if (!activeContainer) return [];
      
      // Check if the current page is a section page (has child sections)
      const currentSectionContainer = activeContainer.querySelector('.sidebar-item-container');
      
      console.log('üîç DOM: Section container exists:', !!currentSectionContainer);
      
      if (currentSectionContainer) {
        // This is a section page - show first-level child sections only
        console.log('üìÇ DOM: Section page detected - showing first-level children');
        
        const siblings = [];
        
        // Try multiple selectors to find direct children
        const directChildrenSelectors = [
          ':scope > .sidebar-item',
          '.sidebar-item'
        ];
        
        let directChildren = [];
        for (const selector of directChildrenSelectors) {
          directChildren = currentSectionContainer.querySelectorAll(selector);
          if (directChildren.length > 0) {
            console.log(`üîç DOM: Found ${directChildren.length} children using selector: ${selector}`);
            break;
          }
        }
        
        if (directChildren.length === 0) {
          // Alternative approach: look for any links within the section container
          directChildren = currentSectionContainer.querySelectorAll('.sidebar-item-text[href]');
          console.log(`üîç DOM: Found ${directChildren.length} direct links in section`);
        }
        
        directChildren.forEach((child, index) => {
          console.log(`üîç DOM: Processing child ${index + 1}:`, child);
          
          // Try to find the link within the child
          let childLink = null;
          if (child.classList && child.classList.contains('sidebar-item-text')) {
            childLink = child;
          } else {
            childLink = child.querySelector('.sidebar-item-text[href]');
          }
          
          if (childLink) {
            const href = childLink.getAttribute('href');
            const text = childLink.textContent.trim();
            
            console.log(`üîç DOM: Child link - text: "${text}", href: "${href}"`);
            
            if (href && href !== '#' && text) {
              // Check if this child also has subsections (making it a section)
              const hasSubsections = child.querySelector ? child.querySelector('.sidebar-item-container') : false;
              
              siblings.push({
                text: text,
                href: href,
                isActive: childLink.classList.contains('active'),
                isSection: !!hasSubsections
              });
              
              console.log(`‚úÖ DOM: Added sibling: "${text}"`);
            }
          }
        });
        
        console.log('üìÇ DOM: Found first-level children:', siblings.map(s => s.text));
        return siblings;
      } else {
        // This is a leaf page - show ALL siblings including current at the same level
        console.log('üìÑ DOM: Leaf page detected - showing ALL siblings (including current)');
        
        const parentContainer = activeContainer.parentElement;
        if (!parentContainer) return [];
        
        const siblings = [];
        const siblingItems = parentContainer.querySelectorAll(':scope > .sidebar-item .sidebar-item-text[href]');
        
        siblingItems.forEach(item => {
          const href = item.getAttribute('href');
          if (href && href !== '#') {
            siblings.push({
              text: item.textContent.trim(),
              href: href,
              isActive: item.classList.contains('active'),
              isSection: false
            });
          }
        });
        
        console.log('üìÑ DOM: Found ALL siblings (including current):', siblings.map(s => s.text));
        console.log('üìÑ DOM: Active sibling marked:', siblings.filter(s => s.isActive).map(s => s.text));
        return siblings;
      }
    }

    function createCustomRightNav() {
      try {
        console.log('üèóÔ∏è Creating custom right nav...');
        
        // Find right sidebar container
        const containerSelectors = [
          '#quarto-margin-sidebar',
          '.margin-sidebar', 
          '#quarto-sidebar-toc'
        ];
        
        let targetContainer = null;
        for (const selector of containerSelectors) {
          const found = document.querySelector(selector);
          if (found) {
            targetContainer = found;
            console.log('‚úÖ Found right sidebar container:', selector);
            break;
          }
        }

        if (!targetContainer) {
          console.log('‚ö†Ô∏è Creating fallback right sidebar container...');
          const rightSidebarContainer = document.createElement('div');
          rightSidebarContainer.id = 'custom-margin-sidebar';
          rightSidebarContainer.style.cssText = `
            position: fixed;
            right: 20px;
            top: 100px;
            width: 250px;
            max-height: 60vh;
            overflow-y: auto;
            z-index: 1000;
            background: white;
            border: 1px solid #ddd;
            border-radius: 6px;
            padding: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
          `;
          document.body.appendChild(rightSidebarContainer);
          targetContainer = rightSidebarContainer;
          console.log('‚úÖ Created fallback container');
        }

        // Remove existing custom nav
        const existing = document.querySelector('#custom-right-nav');
        if (existing) {
          existing.remove();
        }

        // Preserve existing TOC
        const existingToc = targetContainer.querySelector('#TOC, .table-of-contents, nav[role="doc-toc"]:not(#custom-right-nav nav)');
        if (existingToc) {
          console.log('‚úÖ Preserving existing Quarto TOC');
        }

        // Create the custom nav element
        const customNav = document.createElement('div');
        customNav.id = 'custom-right-nav';
        customNav.className = 'toc-right custom-navigation';
        customNav.innerHTML = `
          <div class="toc-title">Related Pages</div>
          <nav class="toc" role="doc-toc">
            <ul>
              <li><em>Loading...</em></li>
            </ul>
          </nav>
        `;

        // Insert after existing TOC or append to container
        if (existingToc) {
          customNav.style.marginTop = '2rem';
          existingToc.parentNode.insertBefore(customNav, existingToc.nextSibling);
        } else {
          targetContainer.appendChild(customNav);
        }

        console.log('‚úÖ Custom nav created');
        
        // Render content immediately
        setTimeout(renderRightNav, 100);
      } catch (error) {
        console.error('‚ùå Error in createCustomRightNav:', error);
      }
    }
    
    // OPTIMIZED: Render only sibling pages, not entire navigation tree - UPDATED WITH SECTION SUPPORT
    function renderRightNav() {
      try {
        const customNav = document.querySelector('#custom-right-nav');
        if (!customNav) return;
        
        const siblings = findCurrentPageSiblings();
        const navContainer = customNav.querySelector('.toc > ul');
        
        if (!navContainer) return;
        
        // Clear existing content
        navContainer.innerHTML = '';
        
        if (!siblings || siblings.length === 0) {
          navContainer.innerHTML = '<li><em>No related pages found</em></li>';
          console.log('üìÑ No related pages to show');
          return;
        }
        
        // Render sibling pages
        siblings.forEach(sibling => {
          const listItem = document.createElement('li');
          listItem.className = 'nav-item';
          
          if (sibling.isSection && sibling.href === '#') {
            // This is a section without a direct link - make it a label
            const span = document.createElement('span');
            span.textContent = sibling.text;
            span.className = 'nav-section-label';
            listItem.appendChild(span);
          } else {
            // This is a regular link
            const link = document.createElement('a');
            link.href = sibling.href;
            link.textContent = sibling.text;
            link.className = 'nav-link';
            
            if (sibling.isActive) {
              // Active link styling
              link.classList.add('active');
            }
            
            listItem.appendChild(link);
          }
          
          navContainer.appendChild(listItem);
        });
        
        customNav.classList.add('has-content');
        console.log('‚úÖ Rendered right nav with', siblings.length, 'items');
      } catch (error) {
        console.error('‚ùå Error in renderRightNav:', error);
      }
    }
  } catch (error) {
    console.error('‚ùå Error in Related Pages navigation script:', error);
  }
});
</script>