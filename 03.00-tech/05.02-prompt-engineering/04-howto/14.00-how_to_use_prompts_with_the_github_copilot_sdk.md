---
title: "How to Use Prompts with the GitHub Copilot SDK"
author: "Dario Airoldi"
date: "2026-02-20"
categories: [tech, prompt-engineering, github-copilot, sdk, agents]
description: "Learn how to consume prompt files, agent definitions, instruction files, and MCP servers from SDK-based applications using the GitHub Copilot SDK"
---

# How to Use Prompts with the GitHub Copilot SDK

The <mark>**GitHub Copilot SDK**</mark> (announced January 2026, technical preview) brings Copilot's agentic loop to <mark>**any application**</mark>â€”not just VS Code or the CLI. Available for Node.js, Python, Go, and .NET, it lets you embed the same agent runtime that powers Copilot Chat into your own apps.

This article focuses on <mark>**how SDK-based applications consume the same prompt engineering artifacts**</mark> documented throughout this series: prompt files, instruction files, agent definitions, skills, and MCP servers. If you've been following articles 01â€“13, everything you've learned applies directly to SDK apps.

## Table of Contents

- [ğŸ¯ What the SDK is and how it differs](#-what-the-sdk-is-and-how-it-differs)
- [ğŸ—ï¸ Architecture overview](#ï¸-architecture-overview)
- [âš¡ Setting up the SDK](#-setting-up-the-sdk)
- [ğŸ“ Prompt file consumption in SDK apps](#-prompt-file-consumption-in-sdk-apps)
- [ğŸ¤– Agent definitions and skill files](#-agent-definitions-and-skill-files)
- [ğŸ“‹ Instruction files for behavioral constraints](#-instruction-files-for-behavioral-constraints)
- [ğŸ”Œ MCP server integration](#-mcp-server-integration)
- [ğŸšï¸ Multi-model routing](#ï¸-multi-model-routing)
- [ğŸ’¾ Memory and persistence](#-memory-and-persistence)
- [ğŸ”§ Practical example: documentation review agent](#-practical-example-documentation-review-agent)
- [âš ï¸ Limitations and considerations](#ï¸-limitations-and-considerations)
- [ğŸ¯ Conclusion](#-conclusion)
- [ğŸ“š References](#-references)

---

## ğŸ¯ What the SDK is and how it differs

### Editor vs. SDK: two surfaces, one prompt format

The key insight for prompt engineers is simple: <mark>**the SDK consumes the same files you already write**</mark>.

| Surface | How you interact | Prompt discovery | Tool access |
|---------|-----------------|------------------|-------------|
| **VS Code** | Chat panel, slash commands | `/promptName` from `.github/prompts/` | Built-in + MCP servers |
| **Copilot CLI** | Terminal commands | Workspace scanning | Built-in + MCP servers |
| **SDK Apps** | Programmatic API calls | Workspace scanning via SDK client | Custom tools + MCP servers |

The SDK doesn't introduce a new prompt format. It reuses <mark>`.prompt.md`</mark>, <mark>`.agent.md`</mark>, <mark>`.instructions.md`</mark>, and <mark>`SKILL.md`</mark> files exactly as documented in [articles 01â€“06](./02-getting-started/01.00-how_github_copilot_uses_markdown_and_prompt_folders.md) of this series.

### What's different

The SDK surface **lacks an editor UI**, which means:

- âŒ No `#file` references (there's no file picker)
- âŒ No slash commands or hashtag commands (there's no chat input with autocomplete)
- âŒ No chat modes (Agent, Plan, Ask, Edit)
- âœ… Prompts are loaded programmatically or via workspace scanning
- âœ… All behavioral rules from instruction files still apply
- âœ… MCP servers work identically

---

## ğŸ—ï¸ Architecture overview

The SDK uses a <mark>**client-server architecture**</mark> where your application communicates with the Copilot CLI running in server mode:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€Î“Ã¶Ã‰
â”‚    Your Application     â”‚
â”‚  (Node.js/Python/Go/.NET) â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚ JSON-RPC
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€Î“Ã¶Ã‰
â”‚   Copilot CLI           â”‚
â”‚   (server mode)         â”‚
â”‚                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€Î“Ã¶Ã‰  â”‚
â”‚  â”‚ Prompt Files      â”‚  â”‚
â”‚  â”‚ Agent Definitions â”‚  â”‚
â”‚  â”‚ Instruction Files â”‚  â”‚
â”‚  â”‚ MCP Servers       â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€Î“Ã¶Ã‰
â”‚   Copilot API â†’ Models  â”‚
â”‚   (GPT-5, Claude, etc.) â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

The SDK manages the CLI process lifecycle automatically. The CLI performs workspace scanning to discover your prompt engineering artifactsâ€”just as it would when running in terminal mode.

---

## âš¡ Setting up the SDK

### Prerequisites

1. **GitHub Copilot subscription** â€” Required (free tier available with limited usage)
2. **Copilot CLI** â€” Must be installed separately; the SDK communicates with it in server mode
3. **Supported runtime** â€” Node.js 18+, Python 3.10+, Go 1.21+, or .NET 8.0+

### Installation

```bash
# Node.js / TypeScript
npm install @github/copilot-sdk

# Python
pip install github-copilot-sdk

# Go
go get github.com/github/copilot-sdk/go

# .NET
dotnet add package GitHub.Copilot.SDK
```

### Quick start (TypeScript)

```typescript
import { CopilotClient } from "@github/copilot-sdk";

// Initialize and start the client
const client = new CopilotClient();
await client.start();

// Create a session with a specific model
const session = await client.createSession({
    model: "gpt-5",
});

// Send a prompt
const response = await session.send({
    prompt: "Review this code for security vulnerabilities",
});
```

### Quick start (Python)

```python
from github_copilot_sdk import CopilotClient

# Initialize and start the client
client = CopilotClient()
await client.start()

# Create a session
session = await client.create_session(model="claude-sonnet-4")

# Send a prompt
response = await session.send(
    prompt="Analyze this architecture for scalability issues"
)
```

### Quick start (.NET)

```csharp
using GitHub.Copilot.SDK;

// Initialize and start the client
var client = new CopilotClient();
await client.StartAsync();

// Create a session
var session = await client.CreateSessionAsync(new SessionOptions
{
    Model = "gpt-5"
});

// Send a prompt
var response = await session.SendAsync("Review this code for security issues");
```

---

## ğŸ“ Prompt file consumption in SDK apps

### Workspace detection

When the SDK client starts, the CLI server scans the workspace for prompt files. The scanning follows the same rules documented in [article 01](./02-getting-started/01.00-how_github_copilot_uses_markdown_and_prompt_folders.md):

1. `.github/prompts/*.prompt.md` â€” Workspace prompt files
2. `.github/instructions/*.instructions.md` â€” Path-specific instruction files
3. `.github/copilot-instructions.md` â€” Repo-level instructions
4. `.github/agents/*.agent.md` â€” Agent definitions
5. `.github/skills/*/SKILL.md` â€” Agent skills

### Loading prompts programmatically

The most common pattern in SDK apps is to load prompt content directly rather than relying on slash commands:

```typescript
import { readFileSync } from "fs";
import { CopilotClient } from "@github/copilot-sdk";

// Load your prompt file content
const promptContent = readFileSync(
    ".github/prompts/security-review.prompt.md",
    "utf-8"
);

const client = new CopilotClient();
await client.start();

const session = await client.createSession({ model: "gpt-5" });

// Send the prompt content as a message
await session.send({ prompt: promptContent });
```

### YAML frontmatter in SDK context

The YAML frontmatter fields in `.prompt.md` files behave differently in SDK apps:

| Field | VS Code behavior | SDK behavior |
|-------|-----------------|--------------|
| `name` | Sets slash command name | Used for identification only |
| `description` | Shown in picker | Metadata only |
| `agent` | Sets chat mode | Agent definitions still applied |
| `model` | Sets session model | Respected if session allows override |
| `tools` | Restricts available tools | Restricts available tools âœ… |

The `tools` field is particularly important for SDK appsâ€”it provides the same tool restriction behavior as in VS Code, ensuring your prompts don't access tools they shouldn't.

---

## ğŸ¤– Agent definitions and skill files

### Using agents with the SDK

Agent definitions (`.agent.md`) work in SDK apps by defining specialized personas with restricted tool sets. The SDK client can switch between agents just as VS Code switches chat modes:

```typescript
const session = await client.createSession({
    model: "claude-opus-4.6",
    agent: "security-reviewer", // References .github/agents/security-reviewer.agent.md
});
```

The agent's system prompt, tool restrictions, and behavioral instructions are automatically loaded from the `.agent.md` file. All the agent design patterns from [article 04](./04.00-how_to_structure_content_for_copilot_agent_files.md) apply directly.

### Using skills with the SDK

Agent Skills (`SKILL.md`) are automatically discovered by the CLI's workspace scanning. The SDK client can invoke skills that match the user's intent:

```typescript
// The CLI automatically matches skills based on the prompt content
await session.send({
    prompt: "Create a new article following our documentation standards",
    // The CLI identifies and loads the matching SKILL.md
});
```

For details on creating effective skills, see [article 06](./06.00-how_to_structure_content_for_copilot_skills.md).

---

## ğŸ“‹ Instruction files for behavioral constraints

Instruction files (`.instructions.md`) are <mark>**automatically applied**</mark> by the CLI server based on `applyTo` glob patternsâ€”exactly as in VS Code. You don't need to load them manually.

### How it works in SDK apps

1. The CLI server scans `.github/instructions/` for instruction files
2. The `applyTo` pattern in the YAML frontmatter determines which files trigger the instructions
3. When your SDK app references a file matching the pattern, the instructions are injected into the context

This means all the instruction file patterns from [article 05](./05.00-how_to_structure_content_for_copilot_instruction_files.md) work without modification.

### Example: enforcing coding standards

If your workspace has `.github/instructions/csharp.instructions.md` with:

```yaml
---
applyTo: "**/*.cs"
---
```

Then whenever the SDK session involves C# files, those instructions are automatically appliedâ€”the same behavior you'd see in VS Code.

---

## ğŸ”Œ MCP server integration

MCP servers are a <mark>**first-class feature**</mark> of the SDK. They work identically to VS Code's MCP integration (see [article 07](./07.00-how_to_create_mcp_servers_for_copilot.md) for building MCP servers).

### Configuration

MCP servers are configured via `mcp.json` in your workspace, the same file VS Code uses:

```json
{
  "servers": {
    "my-validation-server": {
      "command": "dotnet",
      "args": ["run", "--project", "src/McpServer/"]
    }
  }
}
```

The SDK client automatically discovers and connects to MCP servers defined in `mcp.json`.

### Tool call flow

```
SDK App â†’ sends prompt â†’ CLI Server â†’ calls model â†’ model requests tool
                                                           â†“
                                                     MCP Server executes tool
                                                           â†“
                                                     result flows back to model
                                                           â†“
                                                     response to SDK App
```

The model handles tool invocation planningâ€”you don't need to manually orchestrate tool calls. The agentic loop in the CLI server manages the conversation turn, tool calls, and follow-up reasoning automatically.

---

## ğŸšï¸ Multi-model routing

The SDK supports <mark>**model selection per session**</mark>, enabling the multi-model architecture patterns described in [article 08](./08.00-how_to_optimize_prompts_for_specific_models.md).

### Available models

SDK apps access models through the Copilot subscription, which currently includes:

| Model | Provider | Best for |
|-------|----------|----------|
| GPT-4o | OpenAI | General tasks, fast responses |
| GPT-5 | OpenAI | Complex reasoning, broad domains |
| o3 / o4-mini | OpenAI | Mathematical and scientific reasoning |
| Claude Sonnet 4 | Anthropic | Balanced coding and analysis |
| Claude Opus 4.6 | Anthropic | Frontier agentic tasks, multi-step workflows |
| Gemini 2.0 Flash | Google | Fast inference, multimodal |

### Model-per-task pattern

```typescript
// Use a fast model for simple classification
const triageSession = await client.createSession({ model: "gpt-4o" });
const category = await triageSession.send({
    prompt: "Classify this issue: " + issueText,
});

// Use a frontier model for complex analysis
const analysisSession = await client.createSession({ model: "claude-opus-4.6" });
const analysis = await analysisSession.send({
    prompt: "Perform deep security analysis on: " + codeText,
});
```

---

## ğŸ’¾ Memory and persistence

The SDK provides <mark>**persistent conversational memory**</mark> across interactions within a session:

- **Session persistence** â€” Context is maintained across multiple `send()` calls within the same session
- **Intelligent compaction** â€” The SDK automatically compacts context when approaching token limits, preserving the most relevant information
- **Infinite sessions** â€” Long-running workflows don't fail from context overflow; the SDK manages compaction transparently

```typescript
// Multi-turn conversation with persistent context
const session = await client.createSession({ model: "gpt-5" });

await session.send({ prompt: "Read the file src/auth/handler.ts" });
await session.send({ prompt: "What security issues do you see?" });
await session.send({ prompt: "Fix the SQL injection vulnerability you found" });
// Each turn has full context from previous turns
```

---

## ğŸ”§ Practical example: documentation review agent

Here's an end-to-end example that combines prompt files, agent definitions, and MCP servers to build a documentation review agent:

### 1. Agent definition

Create `.github/agents/doc-reviewer.agent.md`:

```markdown
---
name: doc-reviewer
description: Reviews documentation articles for quality and consistency
tools:
  - read_file
  - grep_search
  - mcp: iqpilot
---

You're a documentation reviewer that checks articles against the team's writing
standards. For each article, check:

1. Structure follows the Diâ”œÃ­taxis framework
2. References are properly classified
3. YAML frontmatter is complete
4. Writing tone matches Microsoft Voice Principles
```

### 2. Instruction file

The existing `.github/instructions/documentation.instructions.md` automatically applies to all `.md` filesâ€”no changes needed.

### 3. SDK application

```typescript
import { CopilotClient } from "@github/copilot-sdk";
import { readdirSync } from "fs";

async function reviewArticles() {
    const client = new CopilotClient();
    await client.start();

    // Create a session using the doc-reviewer agent
    const session = await client.createSession({
        model: "claude-opus-4.6",
        agent: "doc-reviewer",
    });

    // Find all articles to review
    const articles = readdirSync("03.00-tech/05.02-prompt-engineering/")
        .filter((f) => f.endsWith(".md"));

    for (const article of articles) {
        const result = await session.send({
            prompt: `Review the article: 03.00-tech/05.02-prompt-engineering/${article}`,
        });
        console.log(`Review for ${article}:`, result);
    }

    await client.stop();
}

reviewArticles();
```

This example leverages:

- **Agent definition** â€” The `doc-reviewer.agent.md` provides the review persona and tool restrictions
- **Instruction files** â€” Documentation standards are automatically injected via `applyTo` patterns
- **MCP server** â€” The IQPilot MCP server provides validation tools
- **Model choice** â€” Claude Opus 4.6 handles the nuanced writing analysis

---

## âš ï¸ Limitations and considerations

### Technical preview status

The GitHub Copilot SDK is in <mark>**technical preview**</mark> as of February 2026. This means:

- âš ï¸ APIs may change in future releases
- âš ï¸ Not recommended for production workloads without fallback strategies
- âš ï¸ Feature parity across languages may vary during preview

### Billing

SDK usage follows the same billing as Copilot CLI:

- Each prompt counts toward your <mark>**premium request quota**</mark>
- Enterprise and individual plans have different quotas
- For details, see [Requests in GitHub Copilot](https://docs.github.com/en/copilot/concepts/billing/copilot-requests)

### Network dependency

The SDK requires connectivity to the Copilot serviceâ€”it can't run fully offline. The CLI server communicates with GitHub's API for authentication and model access.

### Differences from VS Code

| Feature | VS Code | SDK Apps |
|---------|---------|----------|
| Interactive file picker (`#file`) | âœ… | âŒ |
| Visual diff review | âœ… | âŒ |
| Chat history UI | âœ… | âŒ (you manage) |
| Terminal integration | âœ… | âŒ (you manage) |
| Prompt discovery UI | âœ… | âŒ (programmatic) |
| MCP servers | âœ… | âœ… |
| Agent definitions | âœ… | âœ… |
| Instruction files | âœ… | âœ… |

---

## ğŸ¯ Conclusion

The GitHub Copilot SDK extends the prompt engineering practices you've learned throughout this series to **any application surface**. The key takeaways:

- **Same files, new surface** â€” `.prompt.md`, `.agent.md`, `.instructions.md`, and `SKILL.md` files work in SDK apps without modification
- **Programmatic control** â€” You get fine-grained control over session creation, model selection, and tool availability
- **MCP integration** â€” Your custom MCP servers work identically in SDK apps
- **Multi-model routing** â€” Apply the model-per-task patterns from [article 08](./08.00-how_to_optimize_prompts_for_specific_models.md) with full flexibility
- **Preview status** â€” The SDK is in technical preview; expect API evolution

> **Next in the series:** Articles 15 and 16 will cover testing/iterating on prompts and versioning prompt librariesâ€”topics that become even more critical when prompts are consumed by SDK applications.

---

## ğŸ“š References

**[GitHub Copilot SDK Repository](https://github.com/github/copilot-sdk)** ğŸ“˜ [Official]  
The official SDK repository with installation guides, API references, and starter examples for all four supported languages.

**[GitHub Copilot SDK â€” Building Agents for Any Application](../../../01.00-news/20260124-copilotstudio-sdk/github-copilot-sdk-building-agents-for-any-application.md)** ğŸ“— [Verified Community]  
Detailed analysis of the SDK announcement with architecture diagrams, comparison tables, and practical implications.

**[Requests in GitHub Copilot](https://docs.github.com/en/copilot/concepts/billing/copilot-requests)** ğŸ“˜ [Official]  
Official GitHub documentation on billing and premium request quotas for Copilot CLI and SDK usage.

**[Model Context Protocol Specification](https://modelcontextprotocol.io/)** ğŸ“˜ [Official]  
The MCP standard specification. SDK apps use MCP servers identically to VS Code.

**[How GitHub Copilot Uses Markdown and Prompt Folders](./02-getting-started/01.00-how_github_copilot_uses_markdown_and_prompt_folders.md)** ğŸ“— [Verified Community]  
The series overview article covering all Copilot customization surfaces, now updated with SDK Apps support.

---

### ğŸ“ Related articles in this series

- **[01. How Copilot Uses Markdown and Prompt Folders](./02-getting-started/01.00-how_github_copilot_uses_markdown_and_prompt_folders.md)** â€” Overview of all Copilot customization surfaces
- **[04. Agent Files](./04.00-how_to_structure_content_for_copilot_agent_files.md)** â€” Agent design patterns used in SDK apps
- **[06. Skills](./06.00-how_to_structure_content_for_copilot_skills.md)** â€” Portable skills consumed by SDK apps
- **[07. MCP Servers](./07.00-how_to_create_mcp_servers_for_copilot.md)** â€” Building MCP servers for SDK integration
- **[08. Model-Specific Prompting](./08.00-how_to_optimize_prompts_for_specific_models.md)** â€” Multi-model routing strategies

---

<!-- VALIDATION METADATA - DO NOT MODIFY ABOVE THIS LINE -->
<!--
```yaml
article_metadata:
  filename: "14.00-how_to_use_prompts_with_the_github_copilot_sdk.md"
  type: "how-to"
  word_count: ~2800
  reading_time_minutes: 11

cross_references:
  series:
    name: "Prompt Engineering for GitHub Copilot"
    part: 12
    previous: "./13.00-how_to_optimize_token_consumption_during_prompt_orchestrations.md"
    next: null
  related_articles:
    - path: "./02-getting-started/01.00-how_github_copilot_uses_markdown_and_prompt_folders.md"
      relationship: "extends"
    - path: "./04.00-how_to_structure_content_for_copilot_agent_files.md"
      relationship: "references"
    - path: "./07.00-how_to_create_mcp_servers_for_copilot.md"
      relationship: "references"
    - path: "../../01.00-news/20260124-copilotstudio-sdk/github-copilot-sdk-building-agents-for-any-application.md"
      relationship: "source"

validations:
  grammar:
    status: "not-started"
    last_run: null
    issues_found: null
    model: null
  readability:
    status: "not-started"
    last_run: null
    score: null
    model: null
  structure:
    status: "not-started"
    last_run: null
    issues_found: null
    model: null
  fact_check:
    status: "not-started"
    last_run: null
    sources_verified: null
    model: null
```
-->
