---
title: "How to use agent hooks for lifecycle automation"
author: "Dario Airoldi"
date: "2026-02-20"
categories: [tech, prompt-engineering, github-copilot]
description: "Learn how to use agent hooks to automate workflows, enforce security policies, and control agent behavior at key lifecycle points in GitHub Copilot with JSON configuration, event schemas, and cross-platform compatibility."
---

# How to use agent hooks for lifecycle automation

> âš ï¸ **Preview Feature**: Agent hooks were introduced in VS Code 1.109.3 and are currently in **Preview**. The configuration format and behavior might change in future releases. Your organization might have disabled hooksâ€”contact your admin for details.

Agent hooks (<mark>`.github/hooks/*.json`</mark>) enable you to execute <mark>custom shell commands at key lifecycle points</mark> during agent sessions.  
Unlike instruction files (which guide behavior through natural language) or agent files (which define personas and tools), <mark>hooks provide deterministic, code-driven automation</mark> with guaranteed outcomesâ€”they run your scripts, not the model's interpretation of them.

This article explores how to configure hooks effectively, understand the eight lifecycle events, write hook scripts that control agent behavior, and integrate hooks with your existing customization stack.

## Table of contents

- [ðŸŽ¯ Understanding agent hooks](#-understanding-agent-hooks)
- [ðŸ“‹ Hook configuration structure](#-hook-configuration-structure)
- [ðŸ”„ Hook lifecycle events](#-hook-lifecycle-events)
- [ðŸ“¥ Hook input and output](#-hook-input-and-output)
- [âœï¸ Writing effective hook scripts](#ï¸-writing-effective-hook-scripts)
- [âš ï¸ Critical limitations and boundaries](#ï¸-critical-limitations-and-boundaries)
- [ðŸš« Common pitfalls and how to avoid them](#-common-pitfalls-and-how-to-avoid-them)
- [ðŸŽ¨ Advanced patterns](#-advanced-patterns)
- [ðŸ§ª Testing and validation](#-testing-and-validation)
- [ðŸ”’ Security considerations](#-security-considerations)
- [ðŸ’¡ Decision framework](#-decision-framework)
- [ðŸŽ¯ Conclusion](#-conclusion)
- [ðŸ“š References](#-references)

## ðŸŽ¯ Understanding agent hooks

### What are agent hooks?

<mark>**Agent hooks**</mark> are JSON-configured commands that <mark>**execute at specific lifecycle points during an agent session**</mark>. They receive structured JSON input via stdin and can return JSON output via stdout to influence agent behaviorâ€”including blocking tool execution, injecting context, or preventing the agent from stopping.

### Key characteristics

| Aspect | Description |
|--------|-------------|
| **File format** | `.json` files with a `hooks` object |
| **Location** | `.github/hooks/` (workspace) or `~/.claude/settings.json` (user) |
| **Activation** | <mark>Automatic at lifecycle eventsâ€”no user invocation needed</mark> |
| **Scope** | Session-wide, applies to all tool invocations and agent states |
| **Visibility** | <mark>Deterministicâ€”runs your code, not the model's interpretation</mark> |
| **Cross-compatibility** | <mark>Compatible with Claude Code and Copilot CLI formats</mark> |
| **Execution contexts** | Works across local agents, background agents, and cloud agents |
| **Communication** | JSON via stdin (input) and stdout (output) |

### Hooks vs other customization types

The table below shows how hooks compare to other GitHub Copilot customization files. Unlike all other types, hooks run your code directly rather than influencing the model through natural language.

| Feature | Hooks | Instructions | Prompts | Agents | Skills |
|---------|-------|-------------|---------|--------|--------|
| **File** | `.json` | `.instructions.md` | `.prompt.md` | `.agent.md` | `SKILL.md` |
| **Language** | Shell commands | Markdown | Markdown | Markdown | Markdown |
| **Activation** | Lifecycle events | File pattern | On-demand | Agent picker | Description match |
| **Deterministic** | <mark>âœ… Yes</mark> | âŒ No | âŒ No | âŒ No | âŒ No |
| **Can block execution** | âœ… Yes | âŒ No | âŒ No | âŒ No | âŒ No |
| **Can modify input** | âœ… Yes | âŒ No | âŒ No | âŒ No | âŒ No |
| **Cross-platform** | âœ… VS Code, CLI, Claude Code | âš ï¸ VS Code + GitHub.com | âŒ VS Code only | âŒ VS Code only | âœ… VS Code, CLI, coding agent |

### When to use hooks

**âœ… Use hooks for:**

- **<mark>Security enforcement</mark>** â€” Block dangerous commands like `rm -rf /` or `DROP TABLE` before they execute
- **<mark>Automated code quality</mark>** â€” Run formatters, linters, or tests after file modifications
- **<mark>Audit trails</mark>** â€” Log every tool invocation, command execution, or file change for compliance
- **<mark>Context injection</mark>** â€” Add project-specific information, environment details, or branch metadata at session start
- **<mark>Approval control</mark>** â€” Auto-approve safe operations while requiring confirmation for sensitive ones
- **<mark>Subagent governance</mark>** â€” Track and constrain nested agent usage

**âŒ Don't use hooks for:**

- **Coding standards** â€” Use instruction files with `applyTo` patterns instead
- **Task workflows** â€” Use prompt files or skills for repeatable procedures
- **Persona and role definition** â€” Use agent files for specialized behaviors
- **Natural language guidance** â€” Use instructions; hooks don't influence the model's reasoning
- **Complex logic requiring LLM judgment** â€” Hooks are deterministic, not AI-driven

## ðŸ“‹ Hook configuration structure

### File locations

VS Code searches for hook configuration files in these locations, with workspace hooks taking precedence:

| Location | Path | Scope | Committed? |
|----------|------|-------|------------|
| **Workspace (recommended)** | `.github/hooks/*.json` | Project-specific, shared with team | âœ… Yes |
| **Workspace local** | `.claude/settings.local.json` | Local workspace hooks | âŒ No |
| **Workspace settings** | `.claude/settings.json` | Workspace-level hooks | âœ… Yes |
| **User settings** | `~/.claude/settings.json` | Personal hooks, all workspaces | âŒ No |

> **Tip**: Use `.github/hooks/` for team-shared hooks. Use `~/.claude/settings.json` for personal hooks that apply across all your projects.

### JSON configuration format

Create a JSON file with a `hooks` object containing arrays of hook commands for each event type:

```json
{
  "hooks": {
    "PreToolUse": [
      {
        "type": "command",
        "command": "./scripts/validate-tool.sh",
        "timeout": 15
      }
    ],
    "PostToolUse": [
      {
        "type": "command",
        "command": "npx prettier --write \"$TOOL_INPUT_FILE_PATH\""
      }
    ],
    "SessionStart": [
      {
        "type": "command",
        "command": "./scripts/init-session.sh"
      }
    ]
  }
}
```

### Hook command properties

Each hook entry must have `type: "command"` and at least one command property:

| Property | Type | Required | Description |
|----------|------|----------|-------------|
| `type` | string | âœ… | Must be `"command"` |
| `command` | string | âœ… | Default command to run (cross-platform fallback) |
| `windows` | string | âŒ | Windows-specific command override |
| `linux` | string | âŒ | Linux-specific command override |
| `osx` | string | âŒ | macOS-specific command override |
| `cwd` | string | âŒ | Working directory (relative to repository root) |
| `env` | object | âŒ | Additional environment variables |
| `timeout` | number | âŒ | Timeout in seconds (default: 30) |

> **Note**: OS-specific commands are selected based on the <mark>extension host platform</mark>. In remote development scenarios (SSH, Containers, WSL), this might differ from your local operating system.

### OS-specific commands

Specify different commands for each operating system when your hook scripts differ by platform:

```json
{
  "hooks": {
    "PostToolUse": [
      {
        "type": "command",
        "command": "./scripts/format.sh",
        "windows": "powershell -File scripts\\format.ps1",
        "linux": "./scripts/format-linux.sh",
        "osx": "./scripts/format-mac.sh"
      }
    ]
  }
}
```

The execution service selects the appropriate command based on your OS. If no OS-specific command is defined, it falls back to the `command` property.

## ðŸ”„ Hook lifecycle events

VS Code supports <mark>eight hook events</mark> that fire at specific points during an agent session. The following diagram shows when each event fires in a typical session:

```
Session Start
    â”‚
    â”œâ”€â”€ SessionStart â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Initialize resources, log session start
    â”‚
    â”œâ”€â”€ UserPromptSubmit â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Audit user requests, inject context
    â”‚
    â”œâ”€â”€ PreToolUse â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Block/allow/modify tool input
    â”‚   â”‚
    â”‚   â””â”€â”€ [Tool executes]
    â”‚       â”‚
    â”‚       â””â”€â”€ PostToolUse â”€â”€â”€â”€â”€â”€â”€â”€â”€ Run formatters, log results
    â”‚
    â”œâ”€â”€ SubagentStart â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Track nested agents, inject context
    â”‚   â”‚
    â”‚   â””â”€â”€ [Subagent runs]
    â”‚       â”‚
    â”‚       â””â”€â”€ SubagentStop â”€â”€â”€â”€â”€â”€â”€â”€ Aggregate results, cleanup
    â”‚
    â”œâ”€â”€ PreCompact â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Save state before context truncation
    â”‚
    â””â”€â”€ Stop â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Generate reports, cleanup, notify
```

The following table summarizes each event, when it fires, and its typical use cases:

| Event | When it fires | Typical use cases |
|-------|---------------|-------------------|
| <mark>`SessionStart`</mark> | User submits the first prompt of a new session | Initialize resources, log session start, validate project state |
| <mark>`UserPromptSubmit`</mark> | User submits a prompt | Audit user requests, inject system context |
| <mark>`PreToolUse`</mark> | Before agent invokes any tool | Block dangerous operations, require approval, modify tool input |
| <mark>`PostToolUse`</mark> | After tool completes successfully | Run formatters, log results, trigger follow-up actions |
| <mark>`SubagentStart`</mark> | Subagent is spawned | Track nested agent usage, initialize subagent resources |
| <mark>`SubagentStop`</mark> | Subagent completes | Aggregate results, cleanup subagent resources |
| <mark>`PreCompact`</mark> | Before conversation context is compacted | Export important context, save state before truncation |
| <mark>`Stop`</mark> | Agent session ends | Generate reports, cleanup resources, send notifications |

## ðŸ“¥ Hook input and output

Hooks communicate with VS Code through <mark>stdin (input)</mark> and <mark>stdout (output)</mark> using JSON.

### Common input fields

Every hook receives a JSON object via stdin with these common fields:

```json
{
  "timestamp": "2026-02-09T10:30:00.000Z",
  "cwd": "/path/to/workspace",
  "sessionId": "session-identifier",
  "hookEventName": "PreToolUse",
  "transcript_path": "/path/to/transcript.json"
}
```

### Common output format

All hooks can return JSON via stdout to influence agent behavior:

```json
{
  "continue": true,
  "stopReason": "Security policy violation",
  "systemMessage": "Operation blocked by security hook"
}
```

| Field | Type | Description |
|-------|------|-------------|
| `continue` | boolean | Set to `false` to stop processing (default: `true`) |
| `stopReason` | string | Reason for stopping (shown to the model) |
| `systemMessage` | string | Message displayed to the user |

### Exit codes

The hook's exit code determines how VS Code handles the result:

| Exit code | Behavior |
|-----------|----------|
| **0** | Successâ€”parse stdout as JSON |
| **2** | Blocking errorâ€”stop processing and show error to model |
| **Other** | Non-blocking warningâ€”show warning to user, continue processing |

### Event-specific schemas

### PreToolUse

The most powerful hook event. It fires before the agent invokes any tool and can <mark>block, allow, or modify the tool invocation</mark>.

**Input** (in addition to common fields):

```json
{
  "tool_name": "editFiles",
  "tool_input": { "files": ["src/main.ts"] },
  "tool_use_id": "tool-123"
}
```

**Output** â€” uses a `hookSpecificOutput` object:

```json
{
  "hookSpecificOutput": {
    "hookEventName": "PreToolUse",
    "permissionDecision": "deny",
    "permissionDecisionReason": "Destructive command blocked by policy",
    "updatedInput": { "files": ["src/safe.ts"] },
    "additionalContext": "User has read-only access to production files"
  }
}
```

| Field | Values | Description |
|-------|--------|-------------|
| `permissionDecision` | `"allow"`, `"deny"`, `"ask"` | Controls tool approval |
| `permissionDecisionReason` | string | Reason shown to the user |
| `updatedInput` | object | Modified tool input (optional) |
| `additionalContext` | string | Extra context for the model |

<mark>**Permission decision priority**</mark>: When multiple hooks run for the same tool invocation, the most restrictive decision wins: `deny` > `ask` > `allow`.

> **Tip**: To determine the format of `updatedInput`, run the command "Show Chat Debug View" and find the logged tool schema. If `updatedInput` doesn't match the expected schema, it's ignored.

### PostToolUse

Fires after a tool completes successfully. Use it for formatting, logging, or triggering follow-up actions.

**Input** (in addition to common fields):

```json
{
  "tool_name": "editFiles",
  "tool_input": { "files": ["src/main.ts"] },
  "tool_use_id": "tool-123",
  "tool_response": "File edited successfully"
}
```

**Output**:

```json
{
  "decision": "block",
  "reason": "Post-processing validation failed",
  "hookSpecificOutput": {
    "hookEventName": "PostToolUse",
    "additionalContext": "The edited file has lint errors that need to be fixed"
  }
}
```

| Field | Values | Description |
|-------|--------|-------------|
| `decision` | `"block"` | Block further processing (optional) |
| `reason` | string | Reason for blocking (shown to the model) |
| `hookSpecificOutput.additionalContext` | string | Extra context injected into the conversation |

### SessionStart

Fires when a new agent session begins. Use it to inject project context, validate the environment, or initialize resources.

**Input** (in addition to common fields):

```json
{
  "source": "new"
}
```

**Output**:

```json
{
  "hookSpecificOutput": {
    "hookEventName": "SessionStart",
    "additionalContext": "Project: my-app v2.1.0 | Branch: main | Node: v20.11.0"
  }
}
```

| Field | Type | Description |
|-------|------|-------------|
| `additionalContext` | string | Context added to the agent's conversation |

### UserPromptSubmit

Fires when the user submits a prompt. Use it for auditing, filtering, or injecting system context.

**Input** (in addition to common fields): Includes a `prompt` field with the text the user submitted.

**Output**: Uses the common output format only.

### Stop

Fires when the agent session ends. Can <mark>prevent the agent from stopping</mark>â€”for example, to require test execution before the session completes.

**Input** (in addition to common fields):

```json
{
  "stop_hook_active": false
}
```

| Field | Type | Description |
|-------|------|-------------|
| `stop_hook_active` | boolean | `true` when the agent is already continuing as a result of a previous stop hook. <mark>Check this value to prevent infinite loops.</mark> |

**Output**:

```json
{
  "hookSpecificOutput": {
    "hookEventName": "Stop",
    "decision": "block",
    "reason": "Run the test suite before finishing"
  }
}
```

> âš ï¸ **Warning**: When a `Stop` hook blocks the agent from stopping, the agent continues running and additional turns consume [premium requests](https://docs.github.com/en/copilot/managing-copilot/monitoring-usage-and-entitlements/about-premium-requests). Always check the `stop_hook_active` field to prevent the agent from running indefinitely.

### SubagentStart

Fires when a subagent is spawned. Use it to track nested agent usage or inject context specific to the subagent.

**Input** (in addition to common fields):

```json
{
  "agent_id": "subagent-456",
  "agent_type": "Plan"
}
```

| Field | Type | Description |
|-------|------|-------------|
| `agent_id` | string | Unique identifier for the subagent |
| `agent_type` | string | The agent name (e.g., `"Plan"` for built-in agents, or custom agent names) |

**Output**:

```json
{
  "hookSpecificOutput": {
    "hookEventName": "SubagentStart",
    "additionalContext": "This subagent should follow the project coding guidelines"
  }
}
```

### SubagentStop

Fires when a subagent completes. Can prevent the subagent from stoppingâ€”similar to the `Stop` hook.

**Input** (in addition to common fields):

```json
{
  "agent_id": "subagent-456",
  "agent_type": "Plan",
  "stop_hook_active": false
}
```

**Output**:

```json
{
  "decision": "block",
  "reason": "Verify subagent results before completing"
}
```

### PreCompact

Fires before conversation context is compacted. Use it to save important state before truncation.

**Input** (in addition to common fields):

```json
{
  "trigger": "auto"
}
```

| Field | Type | Description |
|-------|------|-------------|
| `trigger` | string | How the compaction was triggered. `"auto"` when the conversation exceeds the prompt budget. |

**Output**: Uses the common output format only.

## âœï¸ Writing effective hook scripts

### Core principles

### 1. Keep hooks fast

Hooks execute synchronously in the agent's lifecycle. <mark>Slow hooks degrade the entire agent experience.</mark>

- Target **under 5 seconds** for `PreToolUse` and `PostToolUse` hooks
- Use the `timeout` property to set a hard limit (default: 30 seconds)
- Avoid network calls unless absolutely necessary
- Cache results where possible

### 2. Output valid JSON

Hooks communicate via stdout. <mark>Any non-JSON output causes parsing failures.</mark>

**âŒ Wrong** â€” mixing stdout with log messages:

```bash
#!/bin/bash
echo "Starting validation..."  # This breaks JSON parsing!
echo '{"continue": true}'
```

**âœ… Correct** â€” log to stderr, output only JSON to stdout:

```bash
#!/bin/bash
echo "Starting validation..." >&2  # Log to stderr
echo '{"continue": true}'          # Output JSON to stdout
```

### 3. Handle errors gracefully

Use exit codes to communicate status. Don't let unhandled errors crash the hook silently.

```bash
#!/bin/bash
set -e

# Validate input
if [ -z "$1" ]; then
  echo '{"continue": false, "stopReason": "No input provided"}' 
  exit 2
fi

# Process and output result
result=$(process_input "$1" 2>/dev/null) || {
  echo "Warning: processing failed" >&2
  exit 1  # Non-blocking warning
}

echo "{\"continue\": true, \"systemMessage\": \"$result\"}"
exit 0
```

### 4. Read input from stdin

Hook scripts receive their input as JSON on stdin. Parse it properly:

**Bash (with jq):**

```bash
#!/bin/bash
input=$(cat)
tool_name=$(echo "$input" | jq -r '.tool_name')
tool_input=$(echo "$input" | jq -r '.tool_input')

if [ "$tool_name" = "runTerminalCommand" ]; then
  # Validate the command
  command=$(echo "$tool_input" | jq -r '.command')
  if echo "$command" | grep -qE "rm\s+-rf|DROP\s+TABLE|format\s+c:"; then
    echo '{"hookSpecificOutput":{"hookEventName":"PreToolUse","permissionDecision":"deny","permissionDecisionReason":"Destructive command blocked by security policy"}}'
    exit 0
  fi
fi

echo '{"continue": true}'
```

**PowerShell:**

```powershell
$input = $Input | Out-String | ConvertFrom-Json

if ($input.tool_name -eq "runTerminalCommand") {
    $command = $input.tool_input.command
    if ($command -match "rm\s+-rf|DROP\s+TABLE|format\s+c:") {
        @{
            hookSpecificOutput = @{
                hookEventName = "PreToolUse"
                permissionDecision = "deny"
                permissionDecisionReason = "Destructive command blocked by security policy"
            }
        } | ConvertTo-Json -Depth 5
        exit 0
    }
}

@{ continue = $true } | ConvertTo-Json
```

**Python:**

```python
#!/usr/bin/env python3
import json
import sys

input_data = json.load(sys.stdin)

if input_data.get("tool_name") == "runTerminalCommand":
    command = input_data.get("tool_input", {}).get("command", "")
    dangerous_patterns = ["rm -rf", "DROP TABLE", "format c:"]
    
    if any(pattern in command for pattern in dangerous_patterns):
        json.dump({
            "hookSpecificOutput": {
                "hookEventName": "PreToolUse",
                "permissionDecision": "deny",
                "permissionDecisionReason": "Destructive command blocked by security policy"
            }
        }, sys.stdout)
        sys.exit(0)

json.dump({"continue": True}, sys.stdout)
```

## âš ï¸ Critical limitations and boundaries

### What hooks can't do

1. **Hooks don't influence reasoning** â€” They can inject context via `additionalContext`, but they can't change *how* the model thinks. Use instruction files for behavioral guidance.

2. **No matcher support in VS Code (yet)** â€” VS Code parses Claude Code's matcher syntax but currently ignores it. Hooks apply to all tools of the matched event type, not just specific tools. Filter by `tool_name` in your script.

3. **No async execution** â€” Hooks run synchronously. Long-running hooks block the agent's lifecycle.

4. **Limited tool schema visibility** â€” The `updatedInput` field in `PreToolUse` must match the tool's expected schema. Use "Show Chat Debug View" to discover schemas.

5. **No hook-to-hook communication** â€” Each hook execution is independent. Use the filesystem or environment variables to share state between hooks if needed.

### Format compatibility notes

VS Code provides cross-compatibility with other hook formats:

| Format | Compatibility |
|--------|--------------|
| **Claude Code** | VS Code parses the format, including matchers (ignored). Empty string matcher (`""`) represents all tools. |
| **Copilot CLI** | VS Code converts `lowerCamelCase` event names (e.g., `preToolUse`) to `PascalCase` (`PreToolUse`). Both `bash` and `powershell` command formats are supported. |

## ðŸš« Common pitfalls and how to avoid them

### 1. Writing to stdout before the JSON response

**Problem**: Any text on stdout before your JSON output causes parse failures.

```bash
# âŒ This breaks everything
echo "Processing..."
echo '{"continue": true}'
```

**Fix**: Send diagnostic messages to stderr:

```bash
# âœ… Correct
echo "Processing..." >&2
echo '{"continue": true}'
```

### 2. Forgetting to check `stop_hook_active`

**Problem**: A `Stop` hook that always blocks creates an infinite loop, consuming premium requests indefinitely.

```json
{
  "hookSpecificOutput": {
    "hookEventName": "Stop",
    "decision": "block",
    "reason": "Run tests first"
  }
}
```

**Fix**: Check `stop_hook_active` in your script:

```bash
input=$(cat)
stop_active=$(echo "$input" | jq -r '.stop_hook_active')

if [ "$stop_active" = "true" ]; then
  echo '{"continue": true}'  # Don't block again
  exit 0
fi

# Only block on first stop
echo '{"hookSpecificOutput":{"hookEventName":"Stop","decision":"block","reason":"Run tests first"}}'
```

### 3. Not setting execute permissions

**Problem**: Hook script fails with "Permission denied" on Linux/macOS.

**Fix**: Set execute permissions on your scripts:

```bash
chmod +x .github/hooks/scripts/*.sh
```

### 4. Timeout issues

**Problem**: Complex hooks exceed the default 30-second timeout and get killed.

**Fix**: Set an appropriate timeout and optimize your script:

```json
{
  "hooks": {
    "PostToolUse": [
      {
        "type": "command",
        "command": "./scripts/run-tests.sh",
        "timeout": 120
      }
    ]
  }
}
```

### 5. Hardcoding credentials in hook scripts

**Problem**: Secrets committed to version control via hook scripts.

**Fix**: Use environment variables or the `env` property:

```json
{
  "hooks": {
    "SessionStart": [
      {
        "type": "command",
        "command": "./scripts/init.sh",
        "env": {
          "API_ENDPOINT": "https://internal.example.com"
        }
      }
    ]
  }
}
```

For secrets, use your OS credential store or a `.env` file that's gitignored.

## ðŸŽ¨ Advanced patterns

### Pattern 1: Block dangerous terminal commands

```json
{
  "hooks": {
    "PreToolUse": [
      {
        "type": "command",
        "command": "./scripts/block-dangerous-commands.sh",
        "windows": "powershell -File scripts\\block-dangerous-commands.ps1"
      }
    ]
  }
}
```

The script inspects `tool_name` and `tool_input` to detect patterns like `rm -rf`, `DROP TABLE`, or `format c:` and returns a `deny` permission decision.

### Pattern 2: Auto-format code after edits

```json
{
  "hooks": {
    "PostToolUse": [
      {
        "type": "command",
        "command": "npx prettier --write \"$TOOL_INPUT_FILE_PATH\""
      }
    ]
  }
}
```

After any file edit, Prettier automatically formats the modified fileâ€”ensuring consistent styling without relying on the model to follow formatting rules.

### Pattern 3: Inject project context at session start

```json
{
  "hooks": {
    "SessionStart": [
      {
        "type": "command",
        "command": "./scripts/inject-context.sh"
      }
    ]
  }
}
```

**Script example** â€” injects branch, Node version, and project metadata:

```bash
#!/bin/bash
branch=$(git branch --show-current 2>/dev/null || echo "unknown")
node_version=$(node --version 2>/dev/null || echo "unknown")
project=$(jq -r '.name // "unnamed"' package.json 2>/dev/null || echo "unnamed")

cat <<EOF
{
  "hookSpecificOutput": {
    "hookEventName": "SessionStart",
    "additionalContext": "Project: $project | Branch: $branch | Node: $node_version"
  }
}
EOF
```

### Pattern 4: Log tool usage for auditing

```json
{
  "hooks": {
    "PreToolUse": [
      {
        "type": "command",
        "command": "./scripts/audit-log.sh"
      }
    ]
  }
}
```

The script appends tool invocation details (timestamp, tool name, input) to a log file for compliance and debugging.

### Pattern 5: Require approval for specific tools

Filter by `tool_name` in your script and return `"permissionDecision": "ask"` for sensitive operations:

```bash
#!/bin/bash
input=$(cat)
tool_name=$(echo "$input" | jq -r '.tool_name')

case "$tool_name" in
  runTerminalCommand|deleteFiles)
    echo '{"hookSpecificOutput":{"hookEventName":"PreToolUse","permissionDecision":"ask","permissionDecisionReason":"Sensitive operation requires approval"}}'
    ;;
  *)
    echo '{"hookSpecificOutput":{"hookEventName":"PreToolUse","permissionDecision":"allow"}}'
    ;;
esac
```

### Pattern 6: Enforce test execution before session end

Combine `Stop` and `SubagentStop` hooks to require test execution:

```bash
#!/bin/bash
input=$(cat)
stop_active=$(echo "$input" | jq -r '.stop_hook_active')

# Prevent infinite loops
if [ "$stop_active" = "true" ]; then
  echo '{"continue": true}'
  exit 0
fi

# Check if tests were run during this session
if [ ! -f ".hook-state/tests-passed" ]; then
  echo '{"hookSpecificOutput":{"hookEventName":"Stop","decision":"block","reason":"Run the test suite before finishing. Execute: npm test"}}'
  exit 0
fi

echo '{"continue": true}'
```

## ðŸ§ª Testing and validation

### View hook diagnostics

To see which hooks are loaded and check for configuration errors:

1. Right-click in the Chat view and select **Diagnostics**
2. Look for the **hooks** section to see loaded hooks and any validation errors

### View hook output

To review hook output and errors during execution:

1. Open the **Output** panel (`Ctrl+Shift+U`)
2. Select **GitHub Copilot Chat Hooks** from the channel dropdown

### Configure hooks with `/hooks`

Use the `/hooks` slash command in chat to configure hooks through an interactive UI:

1. Type `/hooks` in the chat input and press Enter
2. Select a hook event type from the list
3. Choose an existing hook to edit or select **Add new hook** to create one
4. Select or create a hook configuration file

The command opens the hook file in the editor with your cursor positioned at the command field, ready for editing.

### Manual testing workflow

1. **Create a minimal hook** that logs input to a file:

   ```bash
   #!/bin/bash
   cat > /tmp/hook-debug.json
   echo '{"continue": true}'
   ```

2. **Trigger the event** â€” Start a session, invoke a tool, etc.

3. **Inspect the logged input** â€” Review `/tmp/hook-debug.json` to understand the exact JSON schema your hook receives.

4. **Iterate** â€” Build your logic against the real input format.

## ðŸ”’ Security considerations

> âš ï¸ **Hooks execute shell commands with the same permissions as VS Code.** Review hook configurations carefully, especially when using hooks from untrusted sources.

### Best practices

| Practice | Reason |
|----------|--------|
| **Review hook scripts before enabling** | Especially in shared repositoriesâ€”hooks run arbitrary shell commands |
| **Limit hook permissions** | Apply the principle of least privilege; hooks should only access what they need |
| **Validate and sanitize input** | Hook scripts receive input from the agent; validate it to prevent injection attacks |
| **Never hardcode secrets** | Use environment variables or secure credential storage |
| **Protect hook scripts from agent edits** | Use `chat.tools.edits.autoApprove` to disallow the agent from editing hook scripts without manual approval |

### Agent self-modification risk

If the agent has access to edit scripts run by hooks, it can modify those scripts during its own run and execute the code it writes. To mitigate this:

- Configure `chat.tools.edits.autoApprove` to require confirmation for hook script edits
- Place hook scripts in a location the agent can't easily find or modify
- Use read-only file permissions on critical hook scripts

## ðŸ’¡ Decision framework

Use this decision tree to determine whether hooks are the right solution:

```
Do you need DETERMINISTIC behavior?
â”‚
YESâ”€ Does it involve intercepting tool execution?
â”‚   â”‚
â”‚   YESâ”€ âœ… USE PreToolUse / PostToolUse HOOKS
â”‚   â”‚
â”‚   NOâ”€ Does it involve session lifecycle?
â”‚       â”‚
â”‚       YESâ”€ âœ… USE SessionStart / Stop HOOKS
â”‚       â”‚
â”‚       NOâ”€ Does it need to run at a specific lifecycle point?
â”‚           â”‚
â”‚           YESâ”€ âœ… USE THE APPROPRIATE HOOK EVENT
â”‚           â”‚
â”‚           NOâ”€ Consider VS Code tasks or scripts
â”‚
NOâ”€ Do you need to influence model behavior?
    â”‚
    YESâ”€ Is it file-specific?
    â”‚   â”‚
    â”‚   YESâ”€ âœ… USE INSTRUCTION FILES (applyTo patterns)
    â”‚   â”‚
    â”‚   NOâ”€ Is it a reusable workflow with templates?
    â”‚       â”‚
    â”‚       YESâ”€ âœ… USE SKILLS
    â”‚       â”‚
    â”‚       NOâ”€ âœ… USE PROMPT or AGENT FILES
    â”‚
    NOâ”€ â“ RECONSIDER: Maybe not needed?
```

### Quick reference table

| Need | Solution | File type |
|------|----------|-----------|
| Block dangerous commands | Hook | `.github/hooks/security.json` |
| Auto-format after edits | Hook | `.github/hooks/formatting.json` |
| Log all tool invocations | Hook | `.github/hooks/audit.json` |
| Inject project context | Hook | `.github/hooks/context.json` |
| Enforce tests before stopping | Hook | `.github/hooks/quality.json` |
| TypeScript coding standards | Instruction | `.instructions.md` |
| Generate React component | Prompt | `.prompt.md` |
| Security reviewer persona | Agent | `.agent.md` |
| Testing workflow with templates | Skill | `SKILL.md` |

## ðŸŽ¯ Conclusion

Agent hooks fill a critical gap in the Copilot customization stack by providing <mark>deterministic, code-driven automation</mark> at key lifecycle points. While instruction files, prompts, agents, and skills all influence the model through natural language, <mark>hooks guarantee execution</mark>â€”your scripts run exactly as written, every time.

**Key takeaways:**

1. **Hooks are deterministic** â€” They execute your code, not the model's interpretation of guidance
2. **Eight lifecycle events** cover the full agent session from start to stop
3. **`PreToolUse` is the most powerful event** â€” It can block, allow, modify, or require approval for any tool invocation
4. **Always check `stop_hook_active`** â€” Prevent infinite loops in `Stop` and `SubagentStop` hooks
5. **Output valid JSON to stdout only** â€” Send diagnostic messages to stderr
6. **Cross-platform compatible** â€” Works with Claude Code and Copilot CLI hook formats
7. **Security matters** â€” Hooks run shell commands with VS Code's full permissions; review scripts carefully
8. **Don't overuse hooks** â€” They're for deterministic automation, not behavioral guidance; use instructions for that

By combining hooks with instruction files, prompts, agents, and skills, you can build a comprehensive customization system where the model follows your natural language guidance *and* your deterministic policies are enforced programmatically.

---

## ðŸ“š References

### Official documentation

**[VS Code: Agent Hooks](https://code.visualstudio.com/docs/copilot/customization/hooks)** `[ðŸ“˜ Official]`  
Microsoft's official documentation for agent hooks in VS Code. Covers the complete lifecycle event system, JSON configuration format, input/output schemas for all eight events, security considerations, and troubleshooting. The primary reference for understanding hooks.

**[VS Code: Copilot Customization Overview](https://code.visualstudio.com/docs/copilot/copilot-customization)** `[ðŸ“˜ Official]`  
Comprehensive overview of all Copilot customization options including instructions, prompts, agents, skills, and hooks. Explains how different customization types work together and when to use each.

**[VS Code: Use Tools with Agents](https://code.visualstudio.com/docs/copilot/agents/agent-tools)** `[ðŸ“˜ Official]`  
Documentation on tool approval and execution in VS Code. Hooks interact directly with tool invocationsâ€”understanding tool schemas helps write effective `PreToolUse` and `PostToolUse` hooks.

**[VS Code: Subagents](https://code.visualstudio.com/docs/copilot/agents/subagents)** `[ðŸ“˜ Official]`  
Documentation on subagent delegation. Relevant for understanding `SubagentStart` and `SubagentStop` hook events and how hooks can govern nested agent behavior.

**[VS Code: Enterprise Policies](https://code.visualstudio.com/docs/enterprise/policies)** `[ðŸ“˜ Official]`  
Enterprise-level policies that can disable hooks. Understanding organizational controls helps teams deploy hooks safely.

### Community resources

**[GitHub: Awesome Copilot Repository](https://github.com/github/awesome-copilot)** `[ðŸ“— Verified Community]`  
Community-curated collection of Copilot customizations. Browse for real-world examples of hook scripts and patterns across different teams and organizations.

**[GitHub Blog: How to Use GitHub Copilot](https://github.blog/developer-skills/github/how-to-use-github-copilot-in-your-ide-tips-tricks-and-best-practices/)** `[ðŸ“— Verified Community]`  
Official GitHub blog post on maximizing Copilot effectiveness. While focused on general usage, provides context on how hooks complement other customization strategies.

### ðŸ“Ž Related articles in this series

**[The GitHub Copilot customization stack](../01-overview/01.00-the_github_copilot_customization_stack.md)** `[ðŸ“™ Internal]`  
Series overview mapping every customization mechanism. Start here to understand how hooks fit into the broader architecture alongside instructions, prompts, agents, and skills.

**[How to Structure Content for Copilot Agent Files](./04.00-how_to_structure_content_for_copilot_agent_files.md)** `[ðŸ“™ Internal]`  
Agent file guide that explains tool control and persona definition. Hooks complement agents by enforcing deterministic policies that agents follow.

**[How to Structure Content for Copilot Instruction Files](./05.00-how_to_structure_content_for_copilot_instruction_files.md)** `[ðŸ“™ Internal]`  
Instruction file guide explaining behavioral guidance through natural language. Hooks and instructions serve complementary purposesâ€”instructions influence reasoning, hooks enforce execution.

**[How to Structure Content for Copilot Skills](./06.00-how_to_structure_content_for_copilot_skills.md)** `[ðŸ“™ Internal]`  
Skills guide covering portable, resource-rich capabilities. Skills bundle templates and scripts alongside instructions; hooks execute scripts at lifecycle points.

**[How to Manage Information Flow During Prompt Orchestrations](./12.00-how_to_manage_information_flow_during_prompt_orchestrations.md)** `[ðŸ“™ Internal]`  
Information flow management in multi-step orchestrations. Hooks provide deterministic checkpoints in the flow that don't depend on model interpretation.

<!-- 
---
validations:
  grammar: {last_run: null, model: null, outcome: null, issues_found: 0}
  readability: {last_run: null, model: null, outcome: null, flesch_score: null, grade_level: null}
  understandability: {last_run: null, model: null, outcome: null, target_audience: null}
  structure: {last_run: null, model: null, outcome: null, has_toc: true, has_introduction: true, has_conclusion: true, has_references: true}
  facts: {last_run: null, model: null, outcome: null, claims_checked: 0, sources_verified: 0}
  logic: {last_run: null, model: null, outcome: null, flow_score: null}

article_metadata:
  filename: "09.00-how_to_use_agent_hooks_for_lifecycle_automation.md"
  created: "2026-02-20"
  last_updated: "2026-02-20"
  version: "1.0"
  status: "draft"
  version_history:
    - date: "2026-02-20"
      changes: "Initial article creation covering Agent Hooks (Preview)"
  word_count: 4800
  reading_time_minutes: 20
  primary_topic: "GitHub Copilot Agent Hooks"

cross_references:
  related_articles:
    - "01.00-the_github_copilot_customization_stack.md"
    - "04.00-how_to_structure_content_for_copilot_agent_files.md"
    - "05.00-how_to_structure_content_for_copilot_instruction_files.md"
    - "06.00-how_to_structure_content_for_copilot_skills.md"
    - "12.00-how_to_manage_information_flow_during_prompt_orchestrations.md"
  series: "Prompt Engineering for GitHub Copilot"
  prerequisites:
    - "01.00-the_github_copilot_customization_stack.md"
---
-->
