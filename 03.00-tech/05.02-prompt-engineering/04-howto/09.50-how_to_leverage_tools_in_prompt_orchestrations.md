---
title: "How to leverage tools in prompt orchestrations"
author: "Dario Airoldi"
date: "2026-02-22"
categories: [tech, prompt-engineering, github-copilot, tools]
description: "Master the two-level tool architecture: YAML capability declarations and runtime tool calls. Complete catalog of built-in, MCP, and extension tools with selection strategies, token costs, and practical patterns."
---

# How to leverage tools in prompt orchestrations

> Tools are the hands and eyes of your AI agents. Without them, an agent can only *think*â€”with them, it can search code, edit files, run commands, ask you questions, and delegate to other agents. This article is the definitive reference for understanding, selecting, and using tools effectively.

Up to this point in the series, you've learned how to create the building blocks of GitHub Copilot customization: [prompt files](./03.00-how_to_structure_content_for_copilot_prompt_files.md), [agent files](./04.00-how_to_structure_content_for_copilot_agent_files.md), [instruction files](./05.00-how_to_structure_content_for_copilot_instruction_files.md), [skills](./06.00-how_to_structure_content_for_copilot_skills.md), [MCP servers](./07.00-how_to_create_mcp_servers_for_copilot.md), and [hooks](./09.00-how_to_use_agent_hooks_for_lifecycle_automation.md). Each of those articles mentioned toolsâ€”restricting them in agent YAML, referencing them in prompts, building them as MCP servers. But none explained what tools actually *are* at runtime, how they work under the hood, or how to choose the right tool for each situation.

This article fills that gap. It covers the complete tool architectureâ€”from the YAML declarations you write to the runtime function calls the model makesâ€”and gives you the knowledge to select, combine, and optimize tools for any prompt orchestration.

## Table of contents

- [ðŸŽ¯ The two-level tool architecture](#-the-two-level-tool-architecture)
- [ðŸ“‹ Level 1: YAML capability declarations](#-level-1-yaml-capability-declarations)
- [âš™ï¸ Level 2: Runtime tool calls](#ï¸-level-2-runtime-tool-calls)
- [ðŸ” Search tools: finding the right information](#-search-tools-finding-the-right-information)
- [âœï¸ Edit tools: modifying the workspace](#ï¸-edit-tools-modifying-the-workspace)
- [ðŸ–¥ï¸ Execution tools: running commands](#ï¸-execution-tools-running-commands)
- [ðŸ’¬ Interaction tools: communicating with users](#-interaction-tools-communicating-with-users)
- [ðŸ¤ Delegation tools: orchestrating agents](#-delegation-tools-orchestrating-agents)
- [ðŸ”Œ Tool sources: built-in vs. MCP vs. extensions](#-tool-sources-built-in-vs-mcp-vs-extensions)
- [ðŸ“Š Token cost analysis](#-token-cost-analysis)
- [ðŸŽ¯ Tool selection strategy](#-tool-selection-strategy)
- [ðŸ›¡ï¸ Tool restrictions and safety](#ï¸-tool-restrictions-and-safety)
- [ðŸ”§ Practical patterns](#-practical-patterns)
- [âš ï¸ Common pitfalls](#ï¸-common-pitfalls)
- [ðŸŽ¯ Conclusion](#-conclusion)
- [ðŸ“š References](#-references)

---

## ðŸŽ¯ The two-level tool architecture

GitHub Copilot's tool system operates at two distinct levels. Understanding this separation is essential for effective prompt engineeringâ€”confusing Level 1 and Level 2 is the most common source of tool-related mistakes.

### Two names, two layers

| Level | What you write | What runs | Example |
|-------|----------------|-----------|---------|
| **Level 1** â€” YAML declarations | `tools: ['codebase', 'editor']` in frontmatter | Nothing directlyâ€”these are *permissions* | `codebase`, `editor`, `filesystem`, `fetch` |
| **Level 2** â€” Runtime tool calls | The model invokes functions during execution | Actual operations on your workspace | `read_file`, `grep_search`, `create_file`, `run_in_terminal` |

The relationship is hierarchical: Level 1 declarations **enable** groups of Level 2 runtime tools. When you write `tools: ['editor']` in YAML, you're granting the agent permission to use runtime tools like `create_file`, `replace_string_in_file`, and `multi_replace_string_in_file`. When you write `tools: ['codebase']`, you're enabling `semantic_search`, `grep_search`, `file_search`, and `read_file`.

```
YAML Declaration (Level 1)         Runtime Tools Enabled (Level 2)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
tools: ['codebase']          â”€â”€â”€â–º  semantic_search, grep_search,
                                   file_search, read_file

tools: ['editor']            â”€â”€â”€â–º  create_file, replace_string_in_file,
                                   multi_replace_string_in_file, read_file

tools: ['filesystem']        â”€â”€â”€â–º  list_dir, file_search, read_file

tools: ['fetch']             â”€â”€â”€â–º  fetch_webpage

tools: ['web_search']        â”€â”€â”€â–º  (web search integration)

tools: ['search']            â”€â”€â”€â–º  grep_search, file_search

tools: ['usages']            â”€â”€â”€â–º  list_code_usages

tools: ['problems']          â”€â”€â”€â–º  get_errors

tools: ['changes']           â”€â”€â”€â–º  get_changed_files
```

### What "always available" means

Some runtime tools are <mark>**always available**</mark> regardless of your YAML `tools` field. These can't be restricted:

| Always-Available Tool | Purpose |
|----------------------|---------|
| `manage_todo_list` | Track task progress in structured todo list |
| `ask_questions` | Present structured questions to the user |
| `runSubagent` | Delegate work to subagents |
| `tool_search_tool_regex` | Discover deferred tools from MCP/extensions |

This means even an agent with `tools: ['codebase']` (read-only) can still track progress, ask the user for clarification, delegate to subagents, and discover MCP tools. You can't create a truly "passive" agentâ€”every agent has at least these four capabilities.

---

## ðŸ“‹ Level 1: YAML capability declarations

Level 1 tools are what you write in the `tools` field of prompt and agent YAML frontmatter. They control **what categories of operations** an agent can perform.

### Core built-in capabilities

| Capability | Description | Read-Only | Network Access |
|------------|-------------|-----------|---------------|
| `codebase` | Semantic search across workspace for code patterns, symbols, implementations | Yes | No |
| `editor` | File read/write operationsâ€”create, modify, delete files | No | No |
| `filesystem` | Directory navigation, file queries, metadata access | Yes | No |
| `fetch` | Retrieve content from web URLs and REST APIs | Yes | Yes |
| `web_search` | Search the internet for current information | Yes | Yes |
| `search` | Workspace text search (exact string and regex) | Yes | No |
| `usages` | Find code usages, references, and call hierarchies | Yes | No |
| `problems` | Get compile errors, lint warnings from VS Code | Yes | No |
| `changes` | View git changes and diffs | Yes | No |

### Tool sets (predefined groups)

VS Code provides predefined groups of related capabilities for convenience:

| Tool Set | Included Capabilities | Use Case |
|----------|----------------------|----------|
| `#edit` | `editor`, `filesystem` | Code modification workflows |
| `#search` | `codebase`, `search`, `usages` | Code discovery and analysis |
| `#reader` | `codebase`, `problems`, `changes`, `usages` | Context gathering without modification |

```yaml
# These are equivalent:
tools: ['codebase', 'search', 'usages']
tools: ['#search']
```

### MCP server tools

Tools from Model Context Protocol servers use the `@server-name` prefix:

```yaml
tools: ['codebase', '@github/*']      # All tools from GitHub MCP server
tools: ['editor', '@azure/deploy']     # Specific Azure tool only
tools: ['#search', '@company-wiki/*']  # Search + custom MCP
```

**Built-in MCP servers:**

| Server | Purpose | Enable Setting |
|--------|---------|---------------|
| `@github` | GitHub APIâ€”issues, PRs, repos, commits | `github.copilot.chat.githubMcpServer.enabled` |
| `@azure` | Azure resources, queries, documentation | Azure extension required |

For building your own MCP servers, see [How to Create MCP Servers for Copilot](./07.00-how_to_create_mcp_servers_for_copilot.md).

### Tool priority order

When multiple sources define tools, this priority order applies:

1. **Prompt file `tools` field** (highest priority)
2. **Referenced agent's `tools` field**
3. **Default tools for current agent mode**

```yaml
# agent defines default tools
# security-reviewer.agent.md
---
tools: ['codebase', 'search', 'fetch']
---

# prompt overrides/extends them
# api-security-audit.prompt.md
---
agent: security-reviewer
tools: ['codebase', 'search', 'fetch', '@github/*']  # adds GitHub MCP
---
```

### Common capability combinations

| Profile | Capabilities | Use Case |
|---------|-------------|----------|
| **Read-only** | `['codebase', 'filesystem', 'search']` | Planning, research, review |
| **Local edit** | `['codebase', 'editor', 'filesystem']` | Refactoring, code generation |
| **Research** | `['codebase', 'fetch', 'web_search']` | Documentation, best practices lookup |
| **Full local** | `['codebase', 'editor', 'filesystem', 'search', 'usages', 'problems']` | Implementation agents |
| **Unrestricted** | `[]` or omit field | All available capabilities enabled |

---

## âš™ï¸ Level 2: Runtime tool calls

Level 2 is where tools actually *do* things. When an agent runs, the model decides which runtime tools to call based on the task, context, and available capabilities. Each tool is a JSON-schema function with specific parameters, behaviors, and token costs.

Here's the complete catalog of runtime tools, organized by function.

---

## ðŸ” Search tools: finding the right information

Search is the most common tool category in prompt orchestrations. Choosing the right search tool is criticalâ€”using `read_file` on a 500-line file when `grep_search` would find the relevant line wastes thousands of tokens.

### `semantic_search`

**Purpose:** Natural language search across the workspace. Uses embeddings to find code or documentation that's *conceptually related* to your query, even if it doesn't share exact keywords.

**When to use:**
- You don't know the exact function name, variable, or keyword
- You're looking for conceptual matches ("authentication flow", "error handling patterns")
- You want to discover related code across multiple files

**When NOT to use:**
- You know the exact string to find (use `grep_search`)
- You know the filename (use `file_search`)
- You need to read a specific file (use `read_file`)

**Key parameters:**
- `query` (required): Natural language describing what you're looking for

**Token cost:** ~2,000 tokens for 10 results (variable based on snippet sizes)

**Example prompt guidance:**
```markdown
Use semantic_search to find code related to "user authentication middleware."
Don't use it for exact string matchesâ€”use grep_search instead.
```

> âš ï¸ **Important:** `semantic_search` cannot be called in parallel with other `semantic_search` calls. When you need multiple semantic searches, run them sequentially.

### `grep_search`

**Purpose:** Fast text search using exact strings or regex patterns across the workspace. Returns matching lines with file paths and line numbers.

**When to use:**
- You know the exact text or pattern to find
- You're searching for function names, variable names, error messages
- You want to see an overview of a specific file by searching within it
- You need regex pattern matching

**Key parameters:**
- `query` (required): Text or regex pattern to search for
- `isRegexp` (required): Whether the pattern is a regex
- `includePattern` (optional): Glob pattern to filter files (e.g., `src/**/*.ts`)
- `maxResults` (optional): Limit number of results

**Token cost:** ~1,500 tokens for 20 matches (compact format)

**Pro tip:** Use `grep_search` with `includePattern` targeting a single file to get a structural overview instead of reading the entire file with `read_file`.

### `file_search`

**Purpose:** Find files in the workspace by glob pattern. Returns file paths onlyâ€”not content.

**When to use:**
- You know the filename or naming pattern
- You want to discover what files exist (e.g., "all test files", "all config files")
- You need to locate a specific file before reading it

**Key parameters:**
- `query` (required): Glob pattern (e.g., `**/*.test.ts`, `src/**/config.*`)
- `maxResults` (optional): Limit number of results

**Token cost:** ~100-500 tokens (paths only, very lightweight)

### `read_file`

**Purpose:** Read the contents of a specific file, with line range control.

**When to use:**
- You need to read specific lines from a known file
- You've found a file via `file_search` or `grep_search` and need its content
- You need to understand code before editing it

**Key parameters:**
- `filePath` (required): Absolute path to the file
- `startLine` (required): 1-based start line
- `endLine` (required): 1-based end line (inclusive)

**Token cost:** ~10 tokens per line read. A 50-line read costs ~500 tokens; a 500-line read costs ~5,000 tokens.

**Best practices:**
- Always specify line rangesâ€”don't read entire large files
- Read larger ranges in fewer calls rather than many small reads
- Use `grep_search` or `file_search` first to identify what to read

### `list_dir`

**Purpose:** List the contents of a directory. Returns names of files and subdirectories.

**When to use:**
- You need to understand project structure
- You're looking for files in a specific directory
- You want to discover what's available before searching

**Key parameters:**
- `path` (required): Absolute path to the directory

**Token cost:** ~100-300 tokens (directory listings are compact)

### Search tool decision tree

```
What are you looking for?
â”‚
â”œâ”€â”€ A concept, pattern, or idea â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º semantic_search
â”‚
â”œâ”€â”€ An exact string or regex â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º grep_search
â”‚   â””â”€â”€ Within a specific file? â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º grep_search + includePattern
â”‚
â”œâ”€â”€ A file by name/pattern â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º file_search
â”‚
â”œâ”€â”€ Content of a known file â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º read_file (specify line range!)
â”‚
â””â”€â”€ Directory structure â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º list_dir
```

---

## âœï¸ Edit tools: modifying the workspace

Edit tools change files on disk. They require the `editor` capability in YAML.

### `create_file`

**Purpose:** Create a new file with specified content. Creates parent directories if they don't exist.

**When to use:**
- Creating new files (code, documentation, config)
- Scaffolding project structures
- Generating output artifacts

**When NOT to use:**
- Editing an existing file (use `replace_string_in_file`)
- Renaming or moving files (use `run_in_terminal` with `mv`)

**Key parameters:**
- `filePath` (required): Absolute path for the new file
- `content` (required): Complete file contents

**Token cost:** Primarily output tokens for the content generated. A 100-line file costs ~1,000 output tokens.

### `replace_string_in_file`

**Purpose:** Replace exactly one occurrence of a literal string in an existing file. The key constraint: your `oldString` must match **exactly one location** in the file.

**When to use:**
- Modifying existing code or content
- Targeted edits where you know the exact context
- Any edit where you need to preserve surrounding code

**Key parameters:**
- `filePath` (required): Absolute path to the file
- `oldString` (required): The exact literal text to replace (include 3+ lines of context before and after)
- `newString` (required): The replacement text

**Token cost:** ~200-500 tokens per operation (context lines + replacement)

**Best practices:**
- Include at least three lines of unchanged context before and after the target text
- If the same string appears multiple times, add more context lines to disambiguate
- For multiple edits to the same file, try `multi_replace_string_in_file` instead

### `multi_replace_string_in_file`

**Purpose:** Apply multiple replacements in a single callâ€”across the same file or different files. More efficient than sequential `replace_string_in_file` calls.

**When to use:**
- Making several related edits across files
- Batch-editing a single file with multiple changes
- Refactoring operations that touch multiple locations

**Key parameters:**
- `explanation` (required): Description of the batch operation
- `replacements` (required): Array of `{filePath, oldString, newString}` objects

**Token cost:** Similar per-replacement cost as `replace_string_in_file`, but avoids the overhead of multiple tool round-trips.

### Edit tool decision tree

```
What do you need to do?
â”‚
â”œâ”€â”€ Create a new file â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º create_file
â”‚
â”œâ”€â”€ Edit one location in a file â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º replace_string_in_file
â”‚
â”œâ”€â”€ Edit multiple locations â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º multi_replace_string_in_file
â”‚   (same file or different files)
â”‚
â””â”€â”€ Rename or move a file â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º run_in_terminal (mv command)
```

---

## ðŸ–¥ï¸ Execution tools: running commands

Execution tools run shell commands and inspect build/lint results.

### `run_in_terminal`

**Purpose:** Execute PowerShell/shell commands in a persistent terminal session. The terminal preserves environment variables, working directory, and context between calls.

**When to use:**
- Running build commands (`dotnet build`, `npm install`)
- Running tests (`pytest`, `npm test`)
- Git operations (`git status`, `git diff`)
- Any operation that requires shell access

**Key parameters:**
- `command` (required): The command to execute
- `explanation` (required): One-sentence description shown to the user
- `goal` (required): Short description of purpose
- `isBackground` (required): `true` for long-running processes (servers), `false` for blocking
- `timeout` (optional): Milliseconds before stopping output tracking

**Token cost:** Variableâ€”depends on command output. Build outputs can be 2,000-10,000+ tokens. Use filtering (e.g., `Select-Object -Last 20`) to limit output.

**Best practices:**
- Never run multiple `run_in_terminal` calls in parallelâ€”they share a session
- For long-running processes (servers, watch mode), use `isBackground: true`
- Filter verbose output to reduce token consumption
- Define explicit command boundaries in agent instructions (what's ALLOWED vs. NEVER)

### `get_terminal_output`

**Purpose:** Check the output of a previously started background terminal command.

**When to use:**
- Checking on a background server you started
- Getting build results from a background process

**Key parameters:**
- `id` (required): Terminal ID returned by `run_in_terminal`

**Token cost:** Depends on accumulated output.

### `get_errors`

**Purpose:** Get compile errors, lint warnings, and diagnostics from VS Code's problems panel.

**When to use:**
- After editing code to verify changes don't introduce errors
- Checking overall project health
- Finding type errors, lint violations, import issues

**Key parameters:**
- `filePaths` (optional): Specific files/folders to check. Omit for all errors.

**Token cost:** ~50-200 tokens per error. A clean project returns minimal tokens.

---

## ðŸ’¬ Interaction tools: communicating with users

These tools let the agent interact with the user during execution. They're **always available**â€”you can't restrict them.

### `ask_questions`

**Purpose:** Present structured questions to the user with predefined options. The only way to get explicit user input during prompt execution without interrupting the flow.

**When to use:**
- Clarifying ambiguous requirements before proceeding
- Getting user preferences on implementation choices
- Confirming decisions that meaningfully affect the outcome

**When NOT to use:**
- The answer is determinable from code or context
- Asking permission to continue or abort (just proceed)
- Reporting a problem (attempt to resolve it instead)
- Quizzes or polls (recommended options are pre-selected and visibleâ€”they'd reveal answers)

**Key parameters:**
- `questions` (required): Array of 1-4 questions, each with:
  - `header` (required): Short label (max 12 chars)
  - `question` (required): Full question text
  - `options` (optional): 0-6 options with `label`, `description`, `recommended`
  - `multiSelect` (optional): Allow multiple selections
  - `allowFreeformInput` (optional): Allow custom text alongside options

**Token cost:** ~300-500 tokens per question set (the question definition + user response).

**Example prompt guidance:**
```markdown
If the user's intent is ambiguous, use ask_questions to clarify.
Batch related questions into a single call (max 4 questions).
Provide a sensible default as the recommended option so users can confirm quickly.
```

### `manage_todo_list`

**Purpose:** Maintain a structured todo list visible in the chat UI. Tracks task progress with explicit state transitions.

**When to use:**
- Complex multi-step work requiring planning and tracking
- When the user provides multiple tasks or requests
- Before starting work on any major step (mark as in-progress)
- Immediately after completing each step (mark as completed)

**When NOT to use:**
- Single, trivial tasks completable in one step
- Purely conversational or informational requests
- Simple file reads or searches

**Key parameters:**
- `todoList` (required): Complete array of all todo items, each with:
  - `id` (required): Sequential number starting from 1
  - `title` (required): Concise 3-7 word action label
  - `status` (required): `not-started`, `in-progress`, or `completed`

**Token cost:** ~500 tokens overhead for a 5-step workflow (the full list is sent with every update).

**How it works:**

`manage_todo_list` serves two purposes:

1. **User visibility:** Shows a live progress tracker in the chat UI, so the user can see what the agent is doing, what's next, and what's done
2. **Agent reliability:** Acts as explicit state checkpointingâ€”the agent commits to a task before starting it and records completion, reducing the chance of skipped steps or going in circles

The tradeoff is token cost vs. reliability. For a five-step workflow, the overhead is ~500 tokens across all updates. That's negligible compared to the 50,000+ tokens a five-step orchestration typically consumes.

**Best practices:**
```markdown
## Task Management

- Create a todo list at the start of multi-step work
- Mark ONE todo as in-progress at a time
- Mark each todo completed IMMEDIATELY after finishing it
- Don't batch completionsâ€”update status individually
```

> **When to use `- [ ]` checkboxes instead:** Markdown checkboxes (`- [ ] Step 1`, `- [x] Step 2`) are a lighter-weight alternative that some models recognize as task tracking signals. They don't render in the UI or provide the same reliability guarantees as `manage_todo_list`, but they cost zero additional tokens since they're just part of the prompt content.

---

## ðŸ¤ Delegation tools: orchestrating agents

Delegation tools let agents spawn other agents to handle subtasks. They're **always available**.

### `runSubagent`

**Purpose:** Launch a new agent to handle a complex, multi-step task autonomously. The subagent gets its own clean context window and returns a single summary.

**When to use:**
- Complex tasks that benefit from isolated, focused context
- Research or analysis that would bloat the main agent's context
- Tasks requiring different tools or model than the main agent

**When NOT to use:**
- Simple tasks completable in one or two tool calls
- Tasks that need the main conversation's full context

**Key parameters:**
- `prompt` (required): Detailed task description for the subagent
- `description` (required): Short 3-5 word summary
- `agentName` (optional): Name of a specific custom agent to invoke

**Token cost:** The subagent consumes its own token budget. Only the final summary (typically 500-2,000 tokens) returns to the main context.

For complete subagent orchestration patterns, see [How to Design Subagent Orchestrations](./11.00-how_to_design_subagent_orchestrations.md).

### `tool_search_tool_regex`

**Purpose:** Discover and load deferred tools from MCP servers and VS Code extensions. This is the **meta-tool**â€”it makes other tools available.

**When to use:**
- Before calling any MCP tool (e.g., `mcp_github_*`, `mcp_azure_*`)
- Before calling any deferred extension tool
- When you need to discover what tools are available from a specific server

**When NOT to use:**
- For tools already loaded by a previous search
- For built-in tools (they're always available)

**Key parameters:**
- `pattern` (required): Python regex pattern matched case-insensitively against tool names, descriptions, and parameters

**Token cost:** ~200-500 tokens per search (returns matching tool schemas).

**How deferred loading works:**

Not all tools are loaded at startup. MCP server tools and VS Code extension tools are <mark>**deferred**</mark>â€”they don't exist until you search for them. The workflow:

```
1. Agent needs to call mcp_github_create_issue
2. Agent first calls: tool_search_tool_regex("mcp_github_create")
3. Tool schema is returned and loaded into the session
4. Now agent can call mcp_github_create_issue normally
```

This lazy-loading mechanism keeps startup fast and avoids overwhelming the context with hundreds of tool schemas. But it means <mark>you must search before you call</mark>â€”calling a deferred tool directly will fail silently.

---

## ðŸ”Œ Tool sources: built-in vs. MCP vs. extensions

Tools come from three distinct sources, each with different loading mechanisms, availability, and characteristics.

### Architecture overview

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  VS CODE (Host)                                              â”‚
â”‚                                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  AI Agent Context                                      â”‚  â”‚
â”‚  â”‚                                                        â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚  â”‚
â”‚  â”‚  â”‚  Built-in     â”‚  â”‚  MCP Server  â”‚  â”‚  Extension  â”‚ â”‚  â”‚
â”‚  â”‚  â”‚  Tools        â”‚  â”‚  Tools       â”‚  â”‚  Tools      â”‚ â”‚  â”‚
â”‚  â”‚  â”‚              â”‚  â”‚              â”‚  â”‚             â”‚ â”‚  â”‚
â”‚  â”‚  â”‚  read_file   â”‚  â”‚  @github/*   â”‚  â”‚  configure_ â”‚ â”‚  â”‚
â”‚  â”‚  â”‚  grep_search â”‚  â”‚  @azure/*    â”‚  â”‚  notebook   â”‚ â”‚  â”‚
â”‚  â”‚  â”‚  create_file â”‚  â”‚  @custom/*   â”‚  â”‚  run_task   â”‚ â”‚  â”‚
â”‚  â”‚  â”‚  ask_questionsâ”‚  â”‚              â”‚  â”‚  get_vscode â”‚ â”‚  â”‚
â”‚  â”‚  â”‚  manage_todo â”‚  â”‚              â”‚  â”‚  _api       â”‚ â”‚  â”‚
â”‚  â”‚  â”‚  runSubagent â”‚  â”‚              â”‚  â”‚             â”‚ â”‚  â”‚
â”‚  â”‚  â”‚  ...         â”‚  â”‚              â”‚  â”‚             â”‚ â”‚  â”‚
â”‚  â”‚  â”‚              â”‚  â”‚              â”‚  â”‚             â”‚ â”‚  â”‚
â”‚  â”‚  â”‚  EAGER LOAD  â”‚  â”‚ DEFERRED     â”‚  â”‚ DEFERRED    â”‚ â”‚  â”‚
â”‚  â”‚  â”‚  Always ready â”‚  â”‚ Need search  â”‚  â”‚ Need search â”‚ â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜ â”‚  â”‚
â”‚  â”‚                           â”‚                  â”‚        â”‚  â”‚
â”‚  â”‚              tool_search_tool_regex           â”‚        â”‚  â”‚
â”‚  â”‚              (discovers and loads)â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                 â”‚
â”‚  â”‚  MCP Server      â”‚  â”‚  MCP Server      â”‚                 â”‚
â”‚  â”‚  Process (stdio) â”‚  â”‚  Process (SSE)   â”‚                 â”‚
â”‚  â”‚  e.g., IQPilot   â”‚  â”‚  e.g., GitHub    â”‚                 â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Source comparison

| Aspect | Built-in Tools | MCP Server Tools | Extension Tools |
|--------|---------------|-----------------|-----------------|
| **Loading** | Eagerâ€”always available | Deferredâ€”need `tool_search_tool_regex` | Deferredâ€”need `tool_search_tool_regex` |
| **Provider** | VS Code core | External processes (stdio/SSE) | VS Code extensions |
| **Examples** | `read_file`, `create_file`, `manage_todo_list` | `mcp_github_*`, `mcp_azure_*`, custom servers | `run_task`, `configure_notebook`, `get_vscode_api` |
| **Configuration** | None needed | `.vscode/settings.json` or `.vscode/mcp.json` | Extension installation |
| **Availability** | VS Code + Visual Studio | VS Code only (currently) | VS Code only |
| **Customization** | Noneâ€”fixed by VS Code | Full controlâ€”you can build your own | Extension developer controls |

### Guidelines for prompt authors

When writing prompts or agent instructions that reference specific tools:

1. **Built-in tools** â€” Reference freely. They're always available.
2. **MCP tools** â€” Include `tool_search_tool_regex` call before first use. Mention the MCP server in your prompt context.
3. **Extension tools** â€” Only reference if you know the extension is installed. Include a fallback strategy.

```markdown
# In your prompt instructions:

## Tool Usage

Use semantic_search and grep_search for codebase analysis.
If GitHub MCP tools are available (search with tool_search_tool_regex 
for "mcp_github"), use them for issue queries.
Otherwise, fall back to fetch_webpage with the GitHub API.
```

---

## ðŸ“Š Token cost analysis

Every tool call consumes tokensâ€”both for the request (function name + arguments) and the response (tool output). Understanding these costs helps you write token-efficient prompts.

### Per-tool cost estimates

| Tool | Request Cost | Typical Response Cost | Total (Typical) | Notes |
|------|-------------|----------------------|-----------------|-------|
| `read_file` (50 lines) | ~50 tokens | ~500 tokens | **~550** | Scales linearly with line count |
| `read_file` (500 lines) | ~50 tokens | ~5,000 tokens | **~5,050** | Expensive for large reads |
| `grep_search` (20 matches) | ~80 tokens | ~1,500 tokens | **~1,580** | Compact per-match format |
| `semantic_search` (10 results) | ~50 tokens | ~2,000 tokens | **~2,050** | Variable snippet sizes |
| `file_search` | ~50 tokens | ~100-500 tokens | **~300** | Cheapestâ€”paths only |
| `list_dir` | ~30 tokens | ~100-300 tokens | **~200** | Very cheap |
| `create_file` (100 lines) | ~1,000 tokens | ~50 tokens | **~1,050** | Cost is in output (content) |
| `replace_string_in_file` | ~200-500 tokens | ~50 tokens | **~400** | Context lines drive cost |
| `multi_replace_string_in_file` | ~500-2,000 tokens | ~100 tokens | **~1,200** | Amortizes round-trip overhead |
| `run_in_terminal` | ~100 tokens | ~200-10,000 tokens | **~2,000** | Use output filtering |
| `get_errors` | ~30 tokens | ~50-1,000 tokens | **~300** | Clean project = cheap |
| `ask_questions` | ~300-500 tokens | ~100 tokens | **~500** | Per question set |
| `manage_todo_list` | ~200-500 tokens | ~50 tokens | **~400** | Full list sent each update |
| `runSubagent` | ~200 tokens | ~500-2,000 tokens | **~1,500** | Only summary returns |
| `tool_search_tool_regex` | ~50 tokens | ~200-500 tokens | **~350** | Loads tool schemas |

### Expensive patterns to avoid

| Pattern | Cost | Better Alternative |
|---------|------|--------------------|
| Reading entire large files | ~5,000+ tokens | `grep_search` to find relevant lines, then `read_file` on specific range |
| Sequential `replace_string_in_file` Ã— 5 | ~2,500 tokens | Single `multi_replace_string_in_file` = ~1,200 tokens |
| Multiple `semantic_search` calls | ~2,000 each | One `grep_search` with regex alternation (e.g., `word1\|word2\|word3`) |
| Unfiltered `run_in_terminal` output | ~10,000+ tokens | Pipe through `Select-Object -Last 20` or filter with `Where-Object` |
| `read_file` to scan for a string | ~5,000 tokens | `grep_search` with `includePattern` on the file |

### Cheap patterns to prefer

| Pattern | Why It's Cheap |
|---------|---------------|
| `file_search` before `read_file` | Paths cost ~100 tokens; avoids reading wrong files |
| `grep_search` with `includePattern` | Scoped search is fast and focused |
| `list_dir` for project discovery | Directory names cost ~200 tokens |
| Parallel independent `read_file` calls | Same total tokens, but faster wall-clock time |
| `get_errors` after edits | Cheap validation; catches issues before expensive retry loops |

For comprehensive token optimization across multi-agent workflows, see [How to Optimize Token Consumption](./13.00-how_to_optimize_token_consumption_during_prompt_orchestrations.md).

---

## ðŸŽ¯ Tool selection strategy

### By prompt type

| Prompt Type | Recommended YAML Capabilities | Key Runtime Tools |
|-------------|------------------------------|-------------------|
| **Planning / Research** | `['codebase', 'filesystem', 'search']` | `semantic_search`, `grep_search`, `file_search`, `read_file`, `list_dir` |
| **Code Review** | `['codebase', 'search', 'problems', 'changes']` | `grep_search`, `read_file`, `get_errors`, `get_changed_files` |
| **Implementation** | `['codebase', 'editor', 'filesystem', 'search']` | `read_file`, `create_file`, `replace_string_in_file`, `multi_replace_string_in_file`, `grep_search` |
| **Documentation** | `['codebase', 'editor', 'filesystem', 'web_search']` | `semantic_search`, `read_file`, `create_file`, `replace_string_in_file` |
| **Testing** | `['codebase', 'editor', 'search', 'problems']` | `grep_search`, `read_file`, `create_file`, `run_in_terminal`, `get_errors` |
| **Orchestrator** | `['codebase', 'search']` + `agent` | `semantic_search`, `read_file`, `runSubagent`, `manage_todo_list` |
| **Security Audit** | `['codebase', 'search', 'web_search']` | `grep_search`, `read_file`, `semantic_search` |

### By agent role

In multi-agent architectures, restrict tools to match each agent's responsibilities:

```yaml
# Researcher â€” read-only, can't modify anything
---
name: Researcher
tools: ['codebase', 'search', 'filesystem', 'fetch']
---

# Builder â€” can edit, can't browse the web
---
name: Builder
tools: ['codebase', 'editor', 'filesystem', 'search']
---

# Reviewer â€” read-only with error checking
---
name: Reviewer
tools: ['codebase', 'search', 'problems', 'changes']
---

# Orchestrator â€” delegates, doesn't implement
---
name: Orchestrator
tools: ['codebase', 'search', 'agent']
---
```

---

## ðŸ›¡ï¸ Tool restrictions and safety

### Why restrict tools?

1. **Security:** Limit external network access (`fetch`, `web_search`) for internal agents
2. **Safety:** Prevent unintended file modifications by read-only agents
3. **Focus:** Remove irrelevant capabilities to reduce tool-calling noise
4. **Token efficiency:** Fewer available tools means less schema in context

### Restricting tools in agent YAML

```yaml
# Security reviewer â€” must NOT edit files
tools: ['codebase', 'search', 'fetch']  # Excludes 'editor'

# Planner â€” must NOT execute commands
tools: ['codebase', 'search', 'usages']  # Excludes 'editor' and terminal

# Auditor â€” no external access
tools: ['codebase', 'editor', 'filesystem']  # Excludes 'fetch', 'web_search'
```

### Terminal command boundaries

When an agent has terminal access, define explicit boundaries in its instructions:

```markdown
## Terminal usage boundaries

**ALLOWED commands:**
- `npm install`, `npm run build`, `npm test`
- `dotnet build`, `dotnet test`
- `git status`, `git diff`

**NEVER execute:**
- `rm -rf`, `del /s`, or any recursive deletion
- Commands that modify system configuration
- Commands that access credentials or secrets
```

### What you CAN'T restrict

Remember: `manage_todo_list`, `ask_questions`, `runSubagent`, and `tool_search_tool_regex` are always available regardless of the `tools` field. To prevent subagent usage, use the `agents` field instead:

```yaml
# Can use runSubagent but restricted to specific agents
agents: ['researcher', 'reviewer']  # Only these subagents allowed
agents: []                          # No subagent invocation
```

### Tool availability by platform

| Capability | VS Code 1.109+ | Visual Studio 17.14+ | GitHub CLI | Copilot SDK |
|------------|----------------|----------------------|------------|-------------|
| `codebase` | Full | Full | Partial | Full |
| `editor` | Full | Full | Full | Full |
| `filesystem` | Full | Full | Full | Full |
| `fetch` | Full | Limited | Full | Full |
| `web_search` | Full | Limited | Limited | Depends on model |
| MCP tools | Full | Not supported | Not supported | Full |
| `runSubagent` | Full | Not supported | Not supported | Full |

---

## ðŸ”§ Practical patterns

### Pattern 1: Guiding tool behavior from prompt instructions

You can influence *which* runtime tools the model uses and *how* it uses them by including guidance in your prompt's markdown body:

```markdown
## Context gathering strategy

1. Start with `file_search` for `**/*.config.*` to discover configuration files
2. Use `grep_search` to find references to the target feature flag
3. Only use `read_file` on files you've confirmed are relevant (specify line ranges)
4. DON'T use `semantic_search` for this taskâ€”we need exact matches

## Editing strategy

When making changes, use `multi_replace_string_in_file` to batch all edits
rather than making sequential single-file edits.
Always run `get_errors` after editing to verify your changes compile.
```

This pattern bridges Level 1 (what's available) and Level 2 (what gets used). Even if all tools are available, your prompt instructions can steer the agent toward the most efficient ones.

### Pattern 2: Context-efficient file analysis

Instead of reading entire files, use a two-phase approach:

```markdown
## Analysis approach

**Phase 1: Discovery** (cheap)
1. Use `list_dir` to understand project structure
2. Use `file_search` to find relevant files by name pattern
3. Use `grep_search` to find specific patterns within those files

**Phase 2: Deep read** (targeted)
4. Use `read_file` ONLY on the specific line ranges identified in Phase 1
5. Read 30-50 lines of context around each match, not the entire file
```

### Pattern 3: Error-driven editing loop

```markdown
## Implementation workflow

1. Read the target file with `read_file` to understand existing structure
2. Make changes with `replace_string_in_file` or `create_file`
3. Run `get_errors` on the modified file
4. If errors exist, fix them and re-run `get_errors`
5. Repeat until clean (max 3 iterations, then ask the user for help)
```

### Pattern 4: Tool fallback chains

```markdown
## Search strategy with fallbacks

1. Try `grep_search` with the exact function name
2. If no results, broaden with `grep_search` using regex: `functionName|related_name`
3. If still no results, use `semantic_search` with a natural language description
4. If still no results, use `list_dir` to explore the project structure manually
```

### Pattern 5: Parallel tool execution

Independent read operations can run in parallel for faster results:

```markdown
## Parallel context gathering

Read these files simultaneously:
- `read_file` on src/config.ts (lines 1-50)
- `read_file` on src/types.ts (lines 1-30)
- `grep_search` for "export interface" in src/**

Then analyze the results together before proceeding.
```

> âš ï¸ **Parallelism rules:** Multiple `read_file`, `grep_search`, `file_search`, and `list_dir` calls can run in parallel. `semantic_search` cannot run in parallel with other `semantic_search` calls. `run_in_terminal` calls should never run in parallel (they share a shell session).

---

## âš ï¸ Common pitfalls

### Pitfall 1: Confusing Level 1 and Level 2

```yaml
# âŒ Wrong: these are runtime tool names, not YAML capabilities
tools: ['read_file', 'grep_search', 'create_file']

# âœ… Correct: use capability categories
tools: ['codebase', 'editor', 'filesystem']
```

The `tools` YAML field takes **capability categories** (Level 1), not individual function names (Level 2).

### Pitfall 2: Reading entire files

```markdown
# âŒ Expensive: reads entire 500-line file (~5,000 tokens)
Read src/service.ts to find the authenticate function.

# âœ… Efficient: grep finds the line, then read the context (~600 tokens)
Use grep_search for "authenticate" in src/service.ts, 
then read_file on the matching line range.
```

### Pitfall 3: Sequential single-file edits

```markdown
# âŒ Slow and expensive: 5 separate tool calls
Replace "oldName" with "newName" in each of these 5 files.

# âœ… Efficient: single batched call
Use multi_replace_string_in_file to rename across all 5 files at once.
```

### Pitfall 4: Missing deferred tool search

```markdown
# âŒ Will fail: MCP tools aren't loaded by default
Call mcp_github_create_issue to open a bug report.

# âœ… Correct: search first, then call
Search for GitHub MCP tools with tool_search_tool_regex,
then call mcp_github_create_issue.
```

### Pitfall 5: Unrestricted terminal access

```yaml
# âŒ Dangerous: agent can run anything
---
name: Code Helper
tools: ['editor', 'codebase']  # terminal implicitly available
---

# âœ… Safer: explicit tool list, terminal boundaries in instructions
---
name: Code Helper
tools: ['editor', 'codebase', 'search']
---
Only use run_in_terminal for: npm install, npm test, dotnet build.
NEVER run destructive commands or access credentials.
```

### Pitfall 6: Not validating after edits

```markdown
# âŒ Risky: doesn't check for errors
Edit the file and move on.

# âœ… Robust: validates every change
After each edit, use get_errors to verify. 
If errors exist, fix them before proceeding.
```

---

## ðŸŽ¯ Conclusion

Tools are the foundation of everything your prompts and agents can do. Understanding the two-level architectureâ€”YAML capability declarations that gate runtime function callsâ€”gives you precise control over agent behavior.

**Key takeaways:**

- **Level 1 (YAML)** controls *permissions*; **Level 2 (runtime)** controls *actions*. Don't confuse them.
- **Search tools** are your most-used category. Use the decision tree: concepts â†’ `semantic_search`, exact strings â†’ `grep_search`, file names â†’ `file_search`, known content â†’ `read_file` with line ranges.
- **Edit tools** should be batched with `multi_replace_string_in_file` when possible, and always validated with `get_errors` afterward.
- **Interaction tools** (`ask_questions`, `manage_todo_list`) are always available and cost-effective for improving reliability.
- **Delegation tools** (`runSubagent`) are key for orchestrationâ€”covered in depth in the [subagent orchestrations article](./11.00-how_to_design_subagent_orchestrations.md).
- **Token costs matter.** Prefer `grep_search` + targeted `read_file` over reading entire files. Batch edits. Filter terminal output.
- **Restrict tools** by agent role to improve safety, focus, and token efficiency.

With this foundation, you're ready to build orchestrations where each agent has exactly the tools it needsâ€”no more, no less. The next article, [How to Design Orchestrator Prompts](./10.00-how_to_design_orchestrator_prompts.md), uses these tools as building blocks for multi-agent coordination.

**Series navigation:**
- **Previous:** [How to Use Agent Hooks for Lifecycle Automation](./09.00-how_to_use_agent_hooks_for_lifecycle_automation.md)
- **Next:** [How to Design Orchestrator Prompts](./10.00-how_to_design_orchestrator_prompts.md)

---

## ðŸ“š References

**ðŸ“˜ [GitHub Copilot Chat Tools â€” VS Code Documentation](https://code.visualstudio.com/docs/copilot/chat/chat-tools)** ðŸ“˜ [Official]  
Primary reference for tool configuration in VS Code. Covers the `tools` YAML field, tool sets, MCP tool references, and platform support. Essential reading for Level 1 configuration.

**ðŸ“˜ [VS Code Chat Subagents Documentation](https://code.visualstudio.com/docs/copilot/chat/subagents)** ðŸ“˜ [Official]  
Official documentation for the `runSubagent` tool and custom agents as subagents. Covers `user-invokable`, `disable-model-invocation`, and the `agents` array.

**ðŸ“˜ [Model Context Protocol Specification](https://spec.modelcontextprotocol.io/)** ðŸ“˜ [Official]  
The formal specification for MCP tools, resources, and transport protocols. Required reading for building custom MCP servers.

**ðŸ“˜ [VS Code MCP Server Configuration](https://code.visualstudio.com/docs/copilot/chat/mcp-servers)** ðŸ“˜ [Official]  
How to configure MCP servers in VS Code settings and workspace files. Covers stdio and SSE transports, authentication, and server management.

**ðŸ“— [GitHub Copilot Customization â€” Custom Instructions](https://docs.github.com/en/copilot/customizing-copilot/adding-repository-custom-instructions-for-github-copilot)** ðŸ“— [Verified Community]  
GitHub's documentation for custom instructions, prompts, and agent files. Cross-reference for how tool configuration fits into the broader customization system.

**ðŸ“™ [How to Create MCP Servers for Copilot](./07.00-how_to_create_mcp_servers_for_copilot.md)** [Internal]  
Series article covering MCP server developmentâ€”the supply side of tools. Read this to understand how custom tools are built and registered.

**ðŸ“™ [How to Structure Content for Agent Files](./04.00-how_to_structure_content_for_copilot_agent_files.md)** [Internal]  
Series article covering agent YAML configuration, including the `tools` field, `agents` field for subagent restrictions, and tool priority ordering.

**ðŸ“™ [How to Design Subagent Orchestrations](./11.00-how_to_design_subagent_orchestrations.md)** [Internal]  
Series article with deep coverage of the `runSubagent` tool, coordinator/worker patterns, and context isolation mechanics.

---

<!-- 
---
validations:
  grammar: {last_run: null, model: null, outcome: null, issues_found: 0}
  readability: {last_run: null, model: null, outcome: null, flesch_score: null, grade_level: null}
  understandability: {last_run: null, model: null, outcome: null, target_audience: null}
  structure: {last_run: null, model: null, outcome: null, has_toc: true, has_introduction: true, has_conclusion: true, has_references: true}
  facts: {last_run: null, model: null, outcome: null, claims_checked: 0, sources_verified: 0}
  logic: {last_run: null, model: null, outcome: null, flow_score: null}

article_metadata:
  filename: "09.50-how_to_leverage_tools_in_prompt_orchestrations.md"
  created: "2026-02-22"
  last_updated: "2026-02-22"
  version: "1.0"
  status: "draft"
  version_history:
    - date: "2026-02-22"
      changes: "Initial article creation â€” consolidated tools coverage from articles 03.00 (Appendix B) and 04.00 (Tool Configuration)"
  word_count: 4500
  reading_time_minutes: 18
  primary_topic: "GitHub Copilot Tool Architecture and Usage"

cross_references:
  related_articles:
    - "03.00-how_to_structure_content_for_copilot_prompt_files.md"
    - "04.00-how_to_structure_content_for_copilot_agent_files.md"
    - "07.00-how_to_create_mcp_servers_for_copilot.md"
    - "10.00-how_to_design_orchestrator_prompts.md"
    - "11.00-how_to_design_subagent_orchestrations.md"
    - "12.00-how_to_manage_information_flow_during_prompt_orchestrations.md"
    - "13.00-how_to_optimize_token_consumption_during_prompt_orchestrations.md"
  series: "Prompt Engineering for GitHub Copilot"
  prerequisites:
    - "01.00-the_github_copilot_customization_stack.md"
    - "03.00-how_to_structure_content_for_copilot_prompt_files.md"
    - "04.00-how_to_structure_content_for_copilot_agent_files.md"
---
-->
