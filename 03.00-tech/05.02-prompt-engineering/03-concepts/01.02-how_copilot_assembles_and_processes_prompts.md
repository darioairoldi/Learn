---
title: "How Copilot assembles and processes prompts"
author: "Dario Airoldi"
date: "2026-03-01"
categories: [tech, prompt-engineering, github-copilot, concepts]
description: "Understand the multi-layered prompt assembly architecture that transforms your chat messages into model requests â€” system prompt layers, user prompt construction, context window growth, and context rot."
---

# How Copilot assembles and processes prompts

Every message you type in GitHub Copilot Chat triggers a multi-layered construction process before the model sees a single token. Understanding *how* this assembly works â€” and *where* each customization mechanism lands â€” is the single most important concept in this series. It's the difference between guessing which file type to use and *knowing* exactly why instructions persist across requests while prompt files don't.

This article explains the prompt assembly architecture from the ground up. You'll learn how the system prompt is built in layers, how the user prompt is constructed from your message plus environment context, how the context window grows over a conversation, and why that growth eventually degrades the model's accuracy.

## Table of contents

- [ğŸ¯ Why assembly matters](#-why-assembly-matters)
- [ğŸ—ï¸ The system prompt: identity and rules](#ï¸-the-system-prompt-identity-and-rules)
- [ğŸ“ The user prompt: your message in context](#-the-user-prompt-your-message-in-context)
- [ğŸ“Š The context window: growth and decay](#-the-context-window-growth-and-decay)
- [âš ï¸ Context rot: the silent accuracy killer](#ï¸-context-rot-the-silent-accuracy-killer)
- [âœ… Choosing the right mechanism](#-choosing-the-right-mechanism)
- [ğŸ¯ Conclusion](#-conclusion)
- [ğŸ“š References](#-references)

---

## ğŸ¯ Why assembly matters

When you type a message in Copilot Chat, you're not sending that message directly to the model. VS Code intercepts your text and assembles a much larger request that includes your project rules, your agent's persona, environment details, workspace structure, and conversation history. The model receives *all of this* as a single input.

This means two things:

1. **Where your content lands determines how the model treats it.** Content in the system prompt is treated as the model's built-in rules. Content in the user prompt is treated as user-provided context. The distinction affects how strongly the model follows your instructions.
2. **Every customization file you create occupies a specific slot in the assembly.** Instruction files land in the system prompt. Prompt files land in the user prompt. Agents override the system prompt's identity layer. If you put content in the wrong file type, it lands in the wrong slot â€” and the model treats it differently than you intended.

---

## ğŸ—ï¸ The system prompt: identity and rules

The <mark>system prompt</mark> is assembled first. It defines who the model is, what rules it follows, and what capabilities it has. VS Code builds it in layers, from most general to most specific:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    SYSTEM PROMPT                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  1. Core identity and global rules                         â”‚
â”‚     "You are an expert AI programming assistant..."         â”‚
â”‚                                                             â”‚
â”‚  2. General instructions                                   â”‚
â”‚     Model-specific behavioral rules and quirks              â”‚
â”‚                                                             â”‚
â”‚  3. Tool use instructions                                  â”‚
â”‚     How to call tools, format parameters, handle results    â”‚
â”‚                                                             â”‚
â”‚  4. Output format instructions                             â”‚
â”‚     Markdown formatting, code block rules, link styles      â”‚
â”‚                                                             â”‚
â”‚  5. Custom instructions (.instructions.md files)           â”‚
â”‚     Your project-specific guidance (auto-injected)          â”‚
â”‚     âš ï¸ copilot-instructions.md is always injected LAST      â”‚
â”‚                                                             â”‚
â”‚  6. Custom agent definition (.agent.md body)               â”‚
â”‚     Agent persona, workflow, and constraints                â”‚
â”‚     Only present when a custom agent is active              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Layers you don't control (1â€“4)

The first four layers are built-in. VS Code generates them automatically for every request. They establish the model's base identity, teach it how to call tools, and define output formatting rules. You can't modify these layers directly, but understanding they exist explains certain model behaviors:

- **Layer 1** sets the model's persona as a programming assistant. This is why Copilot defaults to code-related answers even when you ask general questions.
- **Layer 2** includes model-specific tweaks. Different models get slightly different behavioral instructions to account for their strengths and quirks.
- **Layer 3** teaches the model how to use tools â€” the JSON schema for each tool, how to format parameters, what to do with results. This is why tool calls "just work" without you having to explain the mechanics.
- **Layer 4** defines formatting rules â€” Markdown conventions, code block syntax highlighting, link formats. This is why Copilot's output is consistently formatted.

### Layers you control (5â€“6)

Layer 5 is where your <mark>custom instructions</mark> go. If you have multiple `.instructions.md` files, they're injected based on their `applyTo` patterns â€” only files whose patterns match the current editing context are included. The repository-wide `copilot-instructions.md` file is always appended **last**, giving it the final word on project conventions.

Layer 6 is where <mark>custom agents</mark> inject their persona and workflow. This only happens when a custom agent is active (selected in the agent picker). The agent body acts as a full identity override â€” it doesn't just provide information, it tells the model *who it is* and *how it should behave*.

### Why this layering matters

The system prompt persists across the entire conversation. Every message you send includes the full system prompt. This is why instruction files "feel" persistent â€” they're re-injected with every request. It's also why overloading the system prompt with too many instructions can degrade performance: the model has to process all of it before it even reads your message.

---

## ğŸ“ The user prompt: your message in context

The <mark>user prompt</mark> is assembled separately for each message. It contains everything specific to the current request:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     USER PROMPT                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  1. Prompt file contents (.prompt.md body)                 â”‚
â”‚     Only present when you invoke a prompt via /command       â”‚
â”‚                                                             â”‚
â”‚  2. Environment info                                       â”‚
â”‚     OS, IDE version, available extensions                   â”‚
â”‚                                                             â”‚
â”‚  3. Workspace info                                         â”‚
â”‚     Project structure, folder layout (text format)           â”‚
â”‚                                                             â”‚
â”‚  4. Context info                                           â”‚
â”‚     Current date/time, open terminals, attached files        â”‚
â”‚                                                             â”‚
â”‚  5. Your message                                           â”‚
â”‚     The actual text you type in the chat input               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### The critical distinction: system vs. user

<mark>Prompt files inject into the user prompt, NOT the system prompt.</mark> This is the most commonly misunderstood aspect of prompt engineering for Copilot. The model sees prompt file content as "the user is asking me to follow these instructions" rather than "these are my built-in rules."

This distinction has practical consequences:

| Behavior | System prompt (instructions) | User prompt (prompt files) |
|----------|------------------------------|---------------------------|
| **Persistence** | Every request in the session | Only the request where invoked |
| **Authority** | Model treats as built-in rules | Model treats as user suggestions |
| **Override risk** | Hard for users to override | Can be overridden by newer messages |
| **Token cost** | Paid on every request | Paid once per invocation |

### Auto-injected context

VS Code automatically populates the environment, workspace, and context sections. This is why the model knows your operating system, can reference your project structure, and understands what file you have open â€” even though you didn't mention any of this in your message.

Attached files (via `#file:`, drag-and-drop, or `@workspace` references) appear in the context info section. Each attachment adds tokens to the user prompt, so attaching large files increases the cost of that specific request.

---

## ğŸ“Š The context window: growth and decay

Once the model responds, its output becomes part of the <mark>context window</mark> â€” the running conversation history that both you and the model can see:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   CONTEXT WINDOW                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  System prompt (persists across the session)                â”‚
â”‚  User message #1                                           â”‚
â”‚  Assistant response #1 (+ tool call results)               â”‚
â”‚  User message #2                                           â”‚
â”‚  Assistant response #2 (+ tool call results)               â”‚
â”‚  ...                                                        â”‚
â”‚  âš ï¸ As this grows, earlier content loses influence           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### How the window grows

Every exchange adds content to the context window:

- **Your message** â€” the user prompt (including any prompt file body, environment info, and attached files)
- **The model's response** â€” the generated text
- **Tool call results** â€” when the model calls tools (reading files, running searches, executing commands), the results are appended to the context

Tool calls are particularly expensive. A single `read_file` call might add hundreds of lines to the context. A `grep_search` might return dozens of matches. An agent that makes ten tool calls in a single response can easily consume thousands of tokens of context window space.

### Why context window size matters

Every model has a maximum context window â€” the total number of tokens it can process in a single request. As of early 2026:

| Model | Context window |
|-------|---------------|
| GPT-4o | 128K tokens |
| Claude Sonnet 4 / Opus 4.6 | 200K tokens |
| o3 / o4-mini | 200K tokens |
| Gemini 2.0 Flash | 1M+ tokens |
| GPT-5 | 1M+ tokens |

These numbers seem enormous, but a complex agent session with many tool calls can consume 50Kâ€“100K tokens in just a few exchanges. The system prompt alone might be 5Kâ€“10K tokens when you have multiple instruction files, an agent definition, and tool schemas.

---

## âš ï¸ Context rot: the silent accuracy killer

As the context window fills, a phenomenon called <mark>context rot</mark> degrades the model's accuracy. Research by Liu et al. (2023, "Lost in the Middle") demonstrated that language models pay disproportionate attention to content at the **beginning** and **end** of their context window, while **under-weighting content in the middle**.

### What context rot looks like in practice

- The model "forgets" instructions you gave three exchanges ago
- Tool call results from early in the conversation stop influencing decisions
- The model starts contradicting its own earlier responses
- Code generation quality drops as the conversation lengthens

### Why it happens

Context rot isn't a bug â€” it's a fundamental property of how transformer attention mechanisms work. The attention pattern looks roughly like a U-curve:

```
Attention
  â–²
  â”‚   â–ˆâ–ˆâ–ˆâ–ˆ                                          â–ˆâ–ˆâ–ˆâ–ˆ
  â”‚   â–ˆâ–ˆâ–ˆâ–ˆ                                          â–ˆâ–ˆâ–ˆâ–ˆ
  â”‚   â–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆ                                â–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆâ–ˆ
  â”‚   â–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆ  â–ˆâ–ˆ                        â–ˆâ–ˆ  â–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆâ–ˆ
  â”‚   â–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆ  â–ˆâ–ˆ  â–ˆ    Â·  Â·  Â·    â–ˆ  â–ˆâ–ˆ  â–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆâ–ˆ
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º Position
      Start            Middle               End
```

Content at the start (your system prompt, early instructions) and content at the end (your most recent message) get the most attention. Content in the middle â€” like that detailed code review from five exchanges ago â€” gradually loses influence.

### Mitigation strategies

1. **Start new sessions frequently.** Don't try to do everything in one conversation. When you notice quality dropping, start fresh.
2. **Front-load important instructions.** Put critical rules in instruction files (system prompt position) rather than in chat messages (which drift toward the middle over time).
3. **Use subagents for isolated tasks.** Each subagent gets a fresh context window. The main agent receives only a summary, keeping its context lean. See [Understanding agents, invocation, handoffs, and subagents](./01.04-understanding_agents_invocation_handoffs_and_subagents.md) for the conceptual foundation and [How to design subagent orchestrations](../04-howto/11.00-how_to_design_subagent_orchestrations.md) for practical implementation.
4. **Keep prompt files concise.** Every token in a prompt file is a token that pushes other content toward the under-weighted middle.
5. **Monitor token usage.** VS Code's output channel shows token counts per request. Watch for sessions that consistently approach the context window limit.

For a deeper treatment of context management techniques, see [How to manage information flow during prompt orchestrations](../04-howto/12.00-how_to_manage_information_flow_during_prompt_orchestrations.md). For token optimization strategies, see [How to optimize token consumption during prompt orchestrations](../04-howto/13.00-how_to_optimize_token_consumption_during_prompt_orchestrations.md).

---

## âœ… Choosing the right mechanism

Understanding the assembly architecture helps you choose the right customization mechanism for any situation. The question isn't "which file type should I create?" â€” it's "where in the assembly do I need this content to land?"

| If you want to... | Use | Assembly position | Why |
|---|---|---|---|
| Set persistent project rules | Custom instructions (`.instructions.md`) | System prompt, layer 5 | Injected into every request automatically |
| Run a reusable workflow | Prompt file (`.prompt.md`) | User prompt, on demand | Injected only when you invoke the `/command` |
| Give the model a new identity | Custom agent (`.agent.md`) | System prompt, layer 6 | Overrides the identity layer completely |
| Route to a specific model | Prompt file (`model:` field) or agent (`model:` field) | Request metadata | Model routing without changing behavior rules |
| Add portable, cross-platform capabilities | Skill (`SKILL.md`) | System prompt (on match) | Auto-loaded when prompt matches description |
| Enforce policies deterministically | Hook (`.github/hooks/*.json`) | Outside the prompt entirely | Runs your code, not the model's interpretation |
| Extend Copilot with external tools | MCP server (`mcp.json`) | Tool schemas in system prompt | Adds new tools the model can call at runtime |

### The decision flowchart

```
Does the content need to persist across every request?
â”œâ”€ YES â†’ Is it project-wide or file-specific?
â”‚        â”œâ”€ Project-wide â†’ copilot-instructions.md
â”‚        â””â”€ File-specific â†’ .instructions.md with applyTo
â”œâ”€ NO â†’ Is it a reusable workflow?
â”‚       â”œâ”€ YES â†’ Does it need a specific persona?
â”‚       â”‚        â”œâ”€ YES â†’ .agent.md
â”‚       â”‚        â””â”€ NO â†’ .prompt.md
â”‚       â””â”€ NO â†’ Is it deterministic enforcement?
â”‚               â”œâ”€ YES â†’ Hook (.json)
â”‚               â””â”€ NO â†’ Is it an external integration?
â”‚                       â”œâ”€ YES â†’ MCP server
â”‚                       â””â”€ NO â†’ Inline chat message
```

---

## ğŸ¯ Conclusion

The prompt assembly architecture is the conceptual backbone of everything in this series. The system prompt carries your persistent rules and agent identity. The user prompt carries your one-time workflows and attached context. The context window accumulates everything â€” and as it grows, earlier content loses influence through context rot.

Every customization mechanism you'll learn about in subsequent articles â€” prompt files, instruction files, agents, skills, hooks, MCP servers â€” maps to a specific position in this assembly. When you understand *where* each mechanism lands and *why*, choosing the right tool for each situation becomes straightforward.

### Key takeaways

- The **system prompt** is built in 6 layers: 4 built-in layers you don't control, plus your custom instructions (layer 5) and agent definition (layer 6)
- The **user prompt** contains your message, prompt file content, and auto-injected environment/workspace context
- **Prompt files inject into the user prompt**, not the system prompt â€” they're treated as user suggestions, not built-in rules
- The **context window** grows with every exchange, consuming tokens from tool calls, responses, and attached files
- **Context rot** degrades accuracy as the window fills â€” mitigate by starting new sessions, using subagents, and front-loading critical instructions

### Next steps

- [Understanding prompt files, instructions, and context layers](./01.03-understanding_prompt_files_instructions_and_context_layers.md) â€” deep dive into the three written customization types
- [Understanding agents, invocation, handoffs, and subagents](./01.04-understanding_agents_invocation_handoffs_and_subagents.md) â€” how agents override the identity layer and delegate work
- [How to manage information flow during prompt orchestrations](../04-howto/12.00-how_to_manage_information_flow_during_prompt_orchestrations.md) â€” practical strategies for keeping context windows lean

---

## ğŸ“š References

**[VS Code Copilot Customization Overview](https://code.visualstudio.com/docs/copilot/customization/overview)** `[ğŸ“˜ Official]`
Microsoft's comprehensive guide to customizing GitHub Copilot in VS Code. Covers custom agents, instructions, prompt files, and MCP configuration. The authoritative source for understanding how customization files are loaded and assembled.

**[Lost in the Middle: How Language Models Use Long Contexts](https://arxiv.org/abs/2307.03172)** `[ğŸ“— Verified Community]`
Academic research (Liu et al., 2023, TACL) documenting the U-shaped attention pattern in transformer models. Demonstrates that models under-weight middle content in long contexts. Foundational research for understanding context rot and why instruction placement matters.

**[GitHub Copilot Documentation â€” Repository Instructions](https://docs.github.com/en/copilot/how-tos/configure-custom-instructions/add-repository-instructions)** `[ğŸ“˜ Official]`
Official GitHub documentation for customizing Copilot with repository-level instructions. Covers prompt files, instruction files, and agent configuration. Essential for understanding the specification behind the assembly architecture.

**[VS Code v1.107 Release Notes](https://code.visualstudio.com/updates/v1_107)** `[ğŸ“˜ Official]`
December 2024 release introducing Agent HQ, background agents, MCP 1.0, and the Language Models Editor. Relevant context for understanding how the assembly architecture extends to background and cloud execution contexts.

---

<!--
---
validations:
  grammar: {last_run: null, model: null, outcome: null, issues_found: 0}
  readability: {last_run: null, model: null, outcome: null, flesch_score: null, grade_level: null}
  understandability: {last_run: null, model: null, outcome: null, target_audience: null}
  structure: {last_run: null, model: null, outcome: null, has_toc: true, has_introduction: true, has_conclusion: true, has_references: true}
  facts: {last_run: null, model: null, outcome: null, claims_checked: 0, sources_verified: 0}
  logic: {last_run: null, model: null, outcome: null, flow_score: null}

article_metadata:
  filename: "01.02-how_copilot_assembles_and_processes_prompts.md"
  created: "2026-03-01"
  last_updated: "2026-03-01"
  version: "1.0"
  status: "published"
  primary_topic: "Prompt assembly architecture"

cross_references:
  related_articles:
    - "01.03-understanding_prompt_files_instructions_and_context_layers.md"
    - "01.04-understanding_agents_invocation_handoffs_and_subagents.md"
    - "12.00-how_to_manage_information_flow_during_prompt_orchestrations.md"
    - "13.00-how_to_optimize_token_consumption_during_prompt_orchestrations.md"
  series: "Prompt Engineering for GitHub Copilot"
  series_order: 3
  prerequisites:
    - "01.00-the_github_copilot_customization_stack.md"
---
-->
