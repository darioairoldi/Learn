---
title: "Understanding skills, hooks, and lifecycle automation"
author: "Dario Airoldi"
date: "2026-03-01"
categories: [tech, prompt-engineering, github-copilot, concepts]
description: "Understand how Agent Skills provide portable, resource-rich capabilities and how Agent Hooks provide deterministic lifecycle automation â€” two complementary mechanisms that extend Copilot beyond natural language guidance."
---

# Understanding skills, hooks, and lifecycle automation

Most of Copilot's customization stack works through natural language â€” you write Markdown instructions, and the model interprets them. This works well for guidance, standards, and workflows. But some situations need more.

<mark>Agent Skills</mark> bundle templates, scripts, and examples alongside instructions, creating portable capabilities that work across VS Code, CLI, and the GitHub Coding Agent. <mark>Agent Hooks</mark> run your code at lifecycle points during agent sessions, providing deterministic enforcement that doesn't depend on model interpretation.

Together, skills and hooks fill the gap between "suggesting the model do something" and "guaranteeing it happens." This article explains what each mechanism is, how they work conceptually, how they complement each other, and when to choose one over the other.

## Table of contents

- [ğŸ¯ Beyond natural language guidance](#-beyond-natural-language-guidance)
- [ğŸ“¦ Agent Skills: portable, resource-rich capabilities](#-agent-skills-portable-resource-rich-capabilities)
- [ğŸª Agent Hooks: deterministic lifecycle automation](#-agent-hooks-deterministic-lifecycle-automation)
- [ğŸ”„ How skills and hooks complement each other](#-how-skills-and-hooks-complement-each-other)
- [âœ… Decision framework: skills vs. hooks vs. other types](#-decision-framework-skills-vs-hooks-vs-other-types)
- [âš ï¸ Current limitations](#ï¸-current-limitations)
- [ğŸ¯ Conclusion](#-conclusion)
- [ğŸ“š References](#-references)

---

## ğŸ¯ Beyond natural language guidance

Every customization type in the Copilot stack has a fundamental limitation: it relies on the model to *interpret* and *follow* instructions. Instruction files say "use camelCase" â€” but the model might occasionally use snake_case anyway. Agent files say "don't edit files" â€” but tool restrictions are the only hard guarantee, and even those depend on how the model reasons about tool selection.

Skills and hooks address this limitation from two different angles:

| Mechanism | What it provides | Guarantee level |
|-----------|-----------------|----------------|
| **Skills** | Rich resources (templates, scripts, examples) alongside instructions | Medium â€” the model still interprets, but with concrete reference material |
| **Hooks** | Shell commands that execute at lifecycle events | High â€” your code runs deterministically, regardless of model behavior |

---

## ğŸ“¦ Agent Skills: portable, resource-rich capabilities

A <mark>skill</mark> is a folder containing a `SKILL.md` file plus optional resources (templates, scripts, examples). Unlike instruction files that provide rules, or prompt files that provide workflows, skills provide *capabilities* â€” complete packages that include both the instructions and the materials needed to execute them.

### How skills differ from other types

| Aspect | Skills | Instructions | Prompts | Agents |
|--------|--------|-------------|---------|--------|
| **File** | `SKILL.md` in a directory | `.instructions.md` | `.prompt.md` | `.agent.md` |
| **Activation** | Automatic (description matches your prompt) | Automatic (file pattern) | On-demand (`/command`) | Agent picker |
| **Resources** | âœ… Templates, scripts, examples | âŒ None | âŒ None | âŒ None |
| **Cross-platform** | âœ… VS Code, CLI, coding agent | âš ï¸ VS Code + GitHub.com | âŒ VS Code only | âŒ VS Code only |
| **Tool control** | âŒ Limited | âŒ None | âœ… Full | âœ… Full |
| **Standard** | Open (agentskills.io) | VS Code-specific | VS Code-specific | VS Code-specific |

The critical differentiator is **resources**. A skill doesn't just say "create a test file following our patterns." It says "create a test file using this template" â€” and includes the actual template. The model doesn't have to guess what "our patterns" look like; it has a concrete example to follow.

### The progressive disclosure system

Skills use a <mark>three-level loading system</mark> to minimize context consumption:

```
Level 1: DISCOVERY (Always loaded)
â”œâ”€â”€ name: "webapp-testing"
â””â”€â”€ description: "Automated testing workflow for web apps..."
    (~50-100 tokens per skill)
        â”‚
        â–¼  (When your prompt matches the description)
Level 2: INSTRUCTIONS (Loaded on match)
â””â”€â”€ SKILL.md body content
    (~500-1500 tokens)
        â”‚
        â–¼  (When Copilot references a specific resource)
Level 3: RESOURCES (Loaded on demand)
â”œâ”€â”€ templates/component.test.js
â”œâ”€â”€ examples/login-form-tests.js
â””â”€â”€ scripts/setup-test-env.sh
    (Loaded only when explicitly needed)
```

This design means that having 20 skills in your repository costs only ~2,000 tokens at Level 1 (just names and descriptions). The full content loads only when relevant â€” a significant advantage over instruction files, which inject their full content into every matching request.

### Skill structure

A typical skill folder:

```
.github/skills/webapp-testing/
â”œâ”€â”€ SKILL.md                    # Required: instructions + metadata
â”œâ”€â”€ templates/                  # Optional: reusable templates
â”‚   â””â”€â”€ component.test.js
â”œâ”€â”€ examples/                   # Optional: real-world examples
â”‚   â””â”€â”€ login-form-tests.js
â””â”€â”€ scripts/                    # Optional: automation scripts
    â””â”€â”€ setup-test-env.sh
```

The `SKILL.md` file has YAML frontmatter with `name` and `description` (both required), followed by instructions in the body:

```yaml
---
name: webapp-testing
description: >
  Generate test suites for React components using Jest.
  Use when writing tests, debugging failures, or setting up test infrastructure.
---

# Web Application Testing Skill

## Purpose
Generate comprehensive test suites following team conventions.

## When to use
- Writing new component tests
- Debugging test failures
- Setting up test infrastructure

## Workflow
1. Analyze the component's props and state
2. Generate test file using [test template](./templates/component.test.js)
3. Run tests to verify coverage
```

### When to use skills

- **Cross-platform workflows** â€” tasks that should work the same in VS Code, CLI, and the coding agent
- **Template-driven tasks** â€” code generation, scaffolding, migration where concrete templates improve consistency
- **Community sharing** â€” open standard means skills work across tools
- **Resource-heavy workflows** â€” tasks that need reference files, scripts, or examples alongside instructions

---

## ğŸª Agent Hooks: deterministic lifecycle automation

<mark>Agent hooks</mark> are JSON-configured shell commands that execute at specific lifecycle points during agent sessions. Unlike every other customization type (which influences the model through natural language), hooks run *your code* â€” deterministically, with guaranteed outcomes.

### Why determinism matters

Consider this scenario: your instruction file says "always run the linter after editing a file." The model usually follows this â€” but sometimes it doesn't. It forgets, or it decides the linter isn't relevant for "just a small change," or it runs the linter but ignores the results.

A hook configured on the `PostToolUse` event runs your linter script *every time* a file is modified. The model doesn't choose whether to run it. Your code executes automatically.

### The eight lifecycle events

Hooks fire at specific points during agent sessions:

| Event | When it fires | Common use cases |
|-------|--------------|------------------|
| `SessionStart` | First prompt of a new session | Initialize resources, inject project context |
| `UserPromptSubmit` | User submits a prompt | Audit requests, inject system context |
| `PreToolUse` | Before agent invokes any tool | Block dangerous operations, modify tool input |
| `PostToolUse` | After tool completes successfully | Run formatters, linters, log results |
| `PreCompact` | Before context compaction | Export important context, save state |
| `SubagentStart` | Subagent is spawned | Track nested agent usage |
| `SubagentStop` | Subagent completes | Aggregate results, clean up |
| `Stop` | Agent session ends | Generate reports, send notifications |

### How hooks work

Hooks receive structured JSON via stdin and can return JSON via stdout. The `PreToolUse` event is particularly powerful because it can *block* tool execution or *modify* tool inputs:

```
Agent wants to run a terminal command
        â”‚
        â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  PreToolUse hook fires      â”‚
â”‚  Receives: tool name, args  â”‚
â”‚                             â”‚
â”‚  Hook script evaluates:     â”‚
â”‚  â”œâ”€ Contains "rm -rf"?      â”‚
â”‚  â”‚   â†’ Return: BLOCK        â”‚
â”‚  â”œâ”€ Contains "DROP TABLE"?  â”‚
â”‚  â”‚   â†’ Return: BLOCK        â”‚
â”‚  â””â”€ Otherwise               â”‚
â”‚      â†’ Return: ALLOW        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚
        â–¼
Tool executes (or is blocked)
```

### Hook configuration

Hooks are configured in JSON files stored in `.github/hooks/`:

```json
{
  "hooks": {
    "PreToolUse": [
      {
        "type": "command",
        "command": "./scripts/validate-tool.sh",
        "timeout": 15
      }
    ],
    "PostToolUse": [
      {
        "type": "command",
        "command": "npx prettier --write \"$TOOL_INPUT_FILE_PATH\""
      }
    ]
  }
}
```

### Hook characteristics

| Aspect | Description |
|--------|-------------|
| **Deterministic** | âœ… Runs your code, not the model's interpretation |
| **Can block execution** | âœ… `PreToolUse` can prevent dangerous operations |
| **Can modify input** | âœ… Hooks can alter tool parameters before execution |
| **Cross-compatible** | âœ… Same format as Claude Code and Copilot CLI |
| **Execution contexts** | Works across local, background, and cloud agents |

### When to use hooks

- **Security enforcement** â€” block dangerous commands, prevent file deletion, restrict access
- **Code quality automation** â€” run formatters and linters automatically after edits
- **Audit trails** â€” log every tool invocation for compliance and debugging
- **Context injection** â€” add project metadata, environment details, or branch info at session start
- **Approval control** â€” auto-approve safe operations, require confirmation for sensitive ones
- **Subagent governance** â€” track and constrain nested agent usage

---

## ğŸ”„ How skills and hooks complement each other

Skills and hooks address different aspects of the same problem: making Copilot's behavior more reliable. They're complementary, not competing:

| Aspect | Skills provide | Hooks provide |
|--------|---------------|---------------|
| **Content** | Reference material (templates, examples, scripts) | Execution automation (shell commands at lifecycle points) |
| **Reliability** | Improved accuracy through concrete examples | Guaranteed execution through deterministic code |
| **Scope** | Task-specific capabilities | Session-wide policies |
| **Language** | Markdown (interpreted by model) | Shell commands (executed by system) |

### When to combine them

Skills and hooks work best together in scenarios that need both guidance and enforcement:

- **Skill:** "Generate tests using our team template"
- **Hook:** `PostToolUse` runs the test suite after every file creation

- **Skill:** "Create database migrations following our naming convention"
- **Hook:** `PreToolUse` validates migration file names before write operations

- **Skill:** "Scaffold new API endpoints using our patterns"
- **Hook:** `PostToolUse` runs the linter and formatter on every created file

---

## âœ… Decision framework: skills vs. hooks vs. other types

```
What are you trying to accomplsh?
â”‚
â”œâ”€ "I need the model to follow a workflow with templates"
â”‚   â””â”€ â†’ Skill (SKILL.md + resources)
â”‚
â”œâ”€ "I need to guarantee something happens at a lifecycle point"
â”‚   â””â”€ â†’ Hook (.github/hooks/*.json)
â”‚
â”œâ”€ "I need persistent coding standards"
â”‚   â””â”€ â†’ Instruction file (.instructions.md)
â”‚
â”œâ”€ "I need a specialized AI persona with tool restrictions"
â”‚   â””â”€ â†’ Agent (.agent.md)
â”‚
â”œâ”€ "I need a one-time reusable workflow"
â”‚   â””â”€ â†’ Prompt file (.prompt.md)
â”‚
â””â”€ "I need both guidance AND enforcement"
    â””â”€ â†’ Skill + Hook (combine both)
```

### Quick comparison table

| Need | Best mechanism | Why |
|------|---------------|-----|
| Block dangerous commands | Hook (`PreToolUse`) | Deterministic â€” can't be bypassed |
| Auto-format after edits | Hook (`PostToolUse`) | Guaranteed execution, not model judgment |
| Generate tests from template | Skill | Provides the actual template, not just instructions |
| Enforce naming conventions | Instruction file | Pattern-based, always active for matching files |
| Define a security reviewer persona | Agent | Identity override with tool restrictions |
| Run a code review workflow | Prompt file | On-demand task with tool control |
| Cross-platform scaffolding | Skill | Works across VS Code, CLI, and coding agent |
| Audit all tool invocations | Hook (`PreToolUse` + `PostToolUse`) | Captures every operation deterministically |

---

## âš ï¸ Current limitations

### Skills limitations

- **Preview feature** â€” APIs and behaviors may change in future releases
- **No tool control** â€” skills can't restrict which tools the model uses (unlike agents and prompts)
- **No handoffs** â€” skills can't orchestrate multi-step workflows between agents
- **Description-based activation** â€” if the description doesn't match the user's prompt, the skill won't activate
- **Requires `chat.useAgentSkills: true`** setting in VS Code

### Hooks limitations

- **Preview feature** â€” configuration format may change
- **Shell commands only** â€” hooks run shell scripts, not native code
- **Timeout constraints** â€” hooks must complete within their timeout (default varies by event)
- **No model influence** â€” hooks can't change how the model reasons; they only control execution
- **Organization policies** â€” your organization might have disabled hooks for security reasons

---

## ğŸ¯ Conclusion

Skills and hooks extend GitHub Copilot's customization stack beyond natural language guidance into concrete resources and deterministic automation. Skills package templates, scripts, and examples into portable capabilities that improve the model's accuracy through reference material. Hooks guarantee that specific code runs at lifecycle events, regardless of model behavior.

### Key takeaways

- **Skills** are portable capabilities with resources (templates, scripts, examples) that work across VS Code, CLI, and the coding agent
- **Hooks** are deterministic shell commands that fire at eight lifecycle events during agent sessions
- Skills improve accuracy through **concrete reference material**; hooks provide **guaranteed execution**
- The **progressive disclosure** system means skills consume minimal tokens until activated
- **`PreToolUse`** hooks can block dangerous operations â€” the most powerful enforcement mechanism in the stack
- Skills and hooks are **complementary** â€” combine them when you need both guidance and enforcement

### Next steps

- [How to structure content for Copilot skills](../04-howto/06.00-how_to_structure_content_for_copilot_skills.md) â€” practical guide to writing `SKILL.md` files
- [How to use agent hooks for lifecycle automation](../04-howto/09.00-how_to_use_agent_hooks_for_lifecycle_automation.md) â€” complete coverage of all eight lifecycle events
- [Understanding MCP and the tool ecosystem](./01.06-understanding_mcp_and_the_tool_ecosystem.md) â€” the protocol for extending Copilot with external tools

---

## ğŸ“š References

**[VS Code Agent Hooks Documentation](https://code.visualstudio.com/docs/copilot/customization/hooks)** `[ğŸ“˜ Official]`
Official VS Code documentation for agent hooks. Covers all eight lifecycle events, JSON configuration format, input/output schemas, permission decisions in `PreToolUse`, and cross-platform compatibility with Claude Code and Copilot CLI.

**[VS Code Copilot Customization Overview](https://code.visualstudio.com/docs/copilot/customization/overview)** `[ğŸ“˜ Official]`
Microsoft's comprehensive guide to customizing Copilot, including coverage of Agent Skills â€” file structure, progressive disclosure, cross-platform support, and enabling the preview feature.

**[Agent Skills Open Standard (agentskills.io)](https://agentskills.io/)** `[ğŸ“˜ Official]`
The open standard defining the skill file format, progressive disclosure system, and cross-platform compatibility requirements.

**[VS Code v1.107 Release Notes](https://code.visualstudio.com/updates/v1_107)** `[ğŸ“˜ Official]`
December 2024 release introducing Agent Skills as a preview feature, alongside Agent HQ and enhanced lifecycle management.

---

<!--
---
validations:
  grammar: {last_run: null, model: null, outcome: null, issues_found: 0}
  readability: {last_run: null, model: null, outcome: null, flesch_score: null, grade_level: null}
  understandability: {last_run: null, model: null, outcome: null, target_audience: null}
  structure: {last_run: null, model: null, outcome: null, has_toc: true, has_introduction: true, has_conclusion: true, has_references: true}
  facts: {last_run: null, model: null, outcome: null, claims_checked: 0, sources_verified: 0}
  logic: {last_run: null, model: null, outcome: null, flow_score: null}

article_metadata:
  filename: "01.05-understanding_skills_hooks_and_lifecycle_automation.md"
  created: "2026-03-01"
  last_updated: "2026-03-01"
  version: "1.0"
  status: "published"
  primary_topic: "Skills, hooks, and lifecycle automation"

cross_references:
  related_articles:
    - "06.00-how_to_structure_content_for_copilot_skills.md"
    - "09.00-how_to_use_agent_hooks_for_lifecycle_automation.md"
    - "01.06-understanding_mcp_and_the_tool_ecosystem.md"
  series: "Prompt Engineering for GitHub Copilot"
  series_order: 6
  prerequisites:
    - "01.02-how_copilot_assembles_and_processes_prompts.md"
---
-->
