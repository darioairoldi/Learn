---
title: "Understanding agents, invocation, handoffs, and subagents"
author: "Dario Airoldi"
date: "2026-03-01"
categories: [tech, prompt-engineering, github-copilot, concepts, agents]
description: "Understand what custom agents are, how they override the model's identity, techniques for invocation and handoff workflows, and how subagent delegation enables scalable multi-agent orchestrations."
---

# Understanding agents, invocation, handoffs, and subagents

Custom agents are the most powerful customization mechanism in GitHub Copilot's stack. While prompt files provide reusable commands and instruction files set persistent rules, agents do something fundamentally different â€” they change *who the model is*. When you switch to a custom agent, you're not just giving the model new instructions. You're replacing its identity, restricting its tools, and defining how it should approach every subsequent interaction.

This article explains agents conceptually: what they are, why they exist as a separate mechanism, how invocation and handoff patterns work, and how subagent delegation enables complex multi-step workflows. For the practical how-to of *writing* agent files, see [How to structure content for Copilot agent files](../04-howto/04.00-how_to_structure_content_for_copilot_agent_files.md). For designing orchestration prompts that coordinate agents, see [How to design orchestrator prompts](../04-howto/10.00-how_to_design_orchestrator_prompts.md).

## Table of contents

- [ğŸ¯ What agents are â€” and what they're not](#-what-agents-are--and-what-theyre-not)
- [ğŸ—ï¸ How agents override the identity layer](#ï¸-how-agents-override-the-identity-layer)
- [ğŸ“‹ .agent.md vs AGENTS.md: two different worlds](#-agentmd-vs-agentsmd-two-different-worlds)
- [ğŸ”— Invocation techniques](#-invocation-techniques)
- [ğŸ¤ Handoffs: multi-agent workflows](#-handoffs-multi-agent-workflows)
- [ğŸ”€ Subagent delegation](#-subagent-delegation)
- [ğŸ­ The orchestrator pattern](#-the-orchestrator-pattern)
- [âš ï¸ Boundaries and limitations](#ï¸-boundaries-and-limitations)
- [ğŸ¯ Conclusion](#-conclusion)
- [ğŸ“š References](#-references)

---

## ğŸ¯ What agents are â€” and what they're not

A <mark>custom agent</mark> is a specialized AI persona stored as an `.agent.md` file. Each agent defines:

- **A specific role or expertise** â€” security reviewer, planner, implementer, documentation writer
- **Restricted tool access** â€” what the agent can and can't do
- **Specialized instructions** â€” how the agent should approach tasks
- **Optional model preference** â€” which LLM to use for this agent
- **Optional handoffs** â€” transitions to other agents

### Agents vs. other customization types

The key distinction is *persistence and identity*:

| Mechanism | What it does | Persistence | Identity change |
|-----------|-------------|-------------|----------------|
| **Prompt files** | Injects a task into the user prompt | One request only | No â€” the model stays "itself" |
| **Instruction files** | Injects rules into the system prompt | Every matching request | No â€” adds rules without changing identity |
| **Agents** | Overrides the system prompt's identity layer | Every request until switched | **Yes** â€” the model becomes the agent |

When you invoke a prompt file, the model is still "GitHub Copilot, a helpful AI programming assistant" â€” it just has an extra task to complete. When you switch to a custom agent, the model *becomes* that agent. It adopts the agent's persona, follows its workflow, and restricts itself to the agent's declared tools.

### Why agents exist

Agents exist because some tasks require more than new instructions â€” they require a different *mindset*:

- **A planning agent** should think before acting, research thoroughly, and produce a structured plan. It shouldn't impulsively edit files.
- **An implementation agent** should focus on execution â€” editing files, running tests, fixing errors. It shouldn't spend time philosophizing about architecture.
- **A security review agent** should be skeptical, thorough, and restrictive. It should look for vulnerabilities, not help write features.

Instruction files can suggest these behaviors, but they can't enforce them. An instruction that says "don't edit files" is guidance the model might ignore under pressure. An agent that only has `codebase` and `problems` tools literally *can't* edit files â€” the capability isn't available.

---

## ğŸ—ï¸ How agents override the identity layer

Recall the [prompt assembly architecture](./01.02-how_copilot_assembles_and_processes_prompts.md): the system prompt is built in six layers, with the agent definition at layer 6 (the final layer). When a custom agent is active, its body content replaces the default identity:

```
Without custom agent:                 With custom agent:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Layer 1: Core identity  â”‚          â”‚ Layer 1: Core identity  â”‚
â”‚ Layer 2: Model rules    â”‚          â”‚ Layer 2: Model rules    â”‚
â”‚ Layer 3: Tool schema    â”‚          â”‚ Layer 3: Tool schema    â”‚
â”‚ Layer 4: Output format  â”‚          â”‚ Layer 4: Output format  â”‚
â”‚ Layer 5: Instructions   â”‚          â”‚ Layer 5: Instructions   â”‚
â”‚ Layer 6: (empty)        â”‚          â”‚ Layer 6: AGENT PERSONA  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚   "You are a security   â”‚
                                     â”‚    auditor. Analyze..."  â”‚
                                     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

The agent body acts as a **full behavioral override.** It doesn't just add information â€” it tells the model who it is and how it should operate. This is why well-designed agents feel like working with a specialist rather than a general-purpose assistant.

### Tool restriction as capability control

The agent's `tools:` field in YAML frontmatter controls what runtime tools become available. This is capability control, not just guidance:

| Agent role | Typical tools | What this prevents |
|-----------|---------------|-------------------|
| Planning/research agent | `codebase`, `problems`, `changes` | Can't edit files, can't run commands |
| Implementation agent | `codebase`, `editor`, `filesystem`, `terminal` | Full access (appropriate for implementation) |
| Review agent | `codebase`, `problems`, `usages` | Can't modify code, can only analyze |
| Documentation agent | `codebase`, `editor` | Can read and write, but can't execute |

---

## ğŸ“‹ .agent.md vs AGENTS.md: two different worlds

A common source of confusion is the difference between `.agent.md` files and `AGENTS.md` files. Despite similar names, they serve fundamentally different purposes:

| Aspect | `.agent.md` files | `AGENTS.md` files |
|--------|-------------------|-------------------|
| **Purpose** | Define VS Code chat personas | Provide instructions to the GitHub Copilot Coding Agent |
| **Location** | `.github/agents/*.agent.md` | Anywhere in repository (commonly root or per-folder) |
| **Platform** | VS Code only (v1.106+) | GitHub.com, VS Code, Visual Studio |
| **Execution** | Interactive â€” runs locally in IDE | Asynchronous â€” runs on GitHub, creates PRs |
| **Tool control** | âœ… Full control via `tools` field | âŒ No tool configuration |
| **Handoffs** | âœ… Workflow transitions between agents | âŒ Not supported |
| **Model selection** | âœ… Via `model` field | âŒ Platform-determined |

### When to use which

- **`.agent.md`** â€” for interactive development workflows in VS Code: planning, reviewing, implementing, documenting
- **`AGENTS.md`** â€” for the GitHub Copilot Coding Agent that works on issues asynchronously and creates pull requests
- **Alternative filenames**: `CLAUDE.md`, `GEMINI.md` work as model-specific alternatives to `AGENTS.md`

---

## ğŸ”— Invocation techniques

Agents can be invoked through three distinct mechanisms, each suited to different situations.

### Direct selection (user-initiated)

The simplest invocation: the user selects an agent from the agent picker in Copilot Chat. This switches the active persona for all subsequent messages until the user switches again.

**When to use:** When the user intentionally wants to work with a specialist â€” "I need to plan this feature" (select the planner agent).

### The `agents` property (subagent routing)

An agent's YAML can declare which other agents it's allowed to invoke as subagents:

```yaml
---
name: orchestrator
agents:
  - researcher
  - implementer
  - reviewer
tools: ['agent', 'codebase', 'editor']
---
```

The `agents` property accepts:
- **An array of agent names** â€” only these agents are available as subagents
- **`*`** â€” all agents are available
- **`[]`** (empty array) â€” no subagent access

**When to use:** When building orchestrator agents that delegate to specialist agents. The `agents` property lets you control which specialists are available, preventing uncontrolled delegation chains.

### The `runSubagent` tool (programmatic delegation)

The model itself can decide to spawn a subagent at runtime using the `runSubagent` tool. This is the mechanism behind the `agents` property â€” when an agent has `tools: ['agent']`, the model gains access to `runSubagent` and can invoke it when it determines delegation would help.

**When to use:** You don't call `runSubagent` directly. It's available to the model when you include `agent` in the agent's `tools` list. The model decides when delegation is beneficial based on its instructions and the current task.

---

## ğŸ¤ Handoffs: multi-agent workflows

<mark>Handoffs</mark> enable orchestrating sequential workflows between agents. Unlike subagent delegation (where one agent spawns another in an isolated context), handoffs *transfer control* â€” the conversation moves from one agent to another, with the user reviewing and approving each transition.

### How handoffs work

A handoff is declared in the agent's YAML frontmatter:

```yaml
---
name: architect
description: Plans implementation approach
handoffs:
  - label: Start Implementation
    agent: implementer
    prompt: "Implement the plan outlined above."
    send: false  # false = user reviews before sending
---
```

When the architect agent completes its task, the user sees a "Start Implementation" button. Selecting it starts a new conversation with the implementer agent, pre-filled with the handoff prompt.

### Handoff properties

| Property | Description | Required |
|----------|-------------|----------|
| `label` | Button text shown to the user | Yes |
| `agent` | Target agent name | Yes |
| `prompt` | Message to pre-fill for the target agent | No |
| `send` | Auto-send (`true`) or let user review (`false`) | No (default: `true`) |

### Handoffs vs. subagents

The choice between handoffs and subagents depends on workflow visibility and control:

| Aspect | Handoffs | Subagents |
|--------|----------|-----------|
| **Control flow** | Sequential â€” user approves each step | Delegated â€” main agent manages internally |
| **User visibility** | High â€” button prompts at each transition | Low â€” collapsed tool call |
| **Context** | New conversation (fresh context) | Isolated child context |
| **Use case** | Multi-phase workflows (plan â†’ implement â†’ review) | Focused subtasks within a single workflow |
| **Communication** | Explicit user transitions | Internal agent-to-agent |
| **Orchestration** | User-driven | Agent-driven |

### Common handoff patterns

**1. Linear pipeline (plan â†’ implement â†’ review):**
```
Architect â†’ [Start Implementation] â†’ Implementer â†’ [Review Code] â†’ Reviewer
```

**2. Branching decision:**
```
Triage Agent â†’ [Quick Fix] â†’ Fixer Agent
             â†’ [Deep Analysis] â†’ Analyst Agent
             â†’ [Escalate] â†’ Senior Reviewer Agent
```

**3. Iterative loop:**
```
Implementer â†’ [Run Tests] â†’ Tester â†’ [Fix Issues] â†’ Implementer
```

---

## ğŸ”€ Subagent delegation

A <mark>subagent</mark> is an independent AI agent that performs focused work in its own isolated context window and returns a summary to the main agent. The main agent stays in control, receiving condensed results without the noise of the subagent's intermediate processing.

### Why isolation matters

Each subagent gets a *fresh context window*. It doesn't inherit the main agent's conversation history, tool call results, or accumulated context. This isolation provides three benefits:

1. **Focus.** The subagent works on exactly one task without being distracted by other context.
2. **Scalability.** The main agent's context window stays lean â€” it gets a summary, not the full transcript.
3. **Parallelism.** Independent subtasks can run concurrently in separate context windows.

### How subagent execution works

```
Main Agent (orchestrator)
  â”‚
  â”œâ”€ Sends task prompt â”€â”€â†’ Subagent A
  â”‚                         â”œâ”€ Gets its own context window
  â”‚                         â”œâ”€ Runs tools autonomously
  â”‚                         â””â”€ Returns summary â”€â”€â†’ Main Agent
  â”‚
  â”œâ”€ Sends task prompt â”€â”€â†’ Subagent B (can run in parallel)
  â”‚                         â”œâ”€ Gets its own context window
  â”‚                         â”œâ”€ Runs tools autonomously
  â”‚                         â””â”€ Returns summary â”€â”€â†’ Main Agent
  â”‚
  â””â”€ Incorporates results â†’ Continues with next step
```

### Key characteristics

| Aspect | Behavior |
|--------|----------|
| **Context isolation** | Each subagent starts with a clean context window â€” no inherited conversation history |
| **Synchronous execution** | The main agent waits for subagent results before continuing |
| **Parallel support** | VS Code can spawn multiple subagents concurrently when tasks are independent |
| **Tool inheritance** | By default, subagents inherit the main session's model and tools |
| **Custom agent override** | When using a custom agent as subagent, its `tools`, `model`, and instructions override defaults |
| **Result format** | Only the subagent's final result returns â€” not intermediate tool calls |

### Subagents vs. new sessions

Subagents maintain a *relationship* with the parent agent â€” they do focused work and report back. Creating a new chat session creates an entirely separate conversation with no connection:

| Aspect | Subagent | New session |
|--------|----------|-------------|
| **Relationship** | Child â€” reports results back | Independent â€” no connection |
| **Context** | Isolated but linked via task prompt | Completely separate |
| **Coordination** | Main agent synthesizes results | Manual user coordination |
| **Use case** | Delegating part of a larger task | Starting unrelated work |

### Controlling subagent visibility

Two agent properties control subagent behavior:

**`user-invokable: false`** â€” Hides the agent from the agent picker. Use this for agents that should only be invoked as subagents, never directly by users:

```yaml
---
name: code-analyzer
user-invokable: false
tools: ['codebase', 'problems']
---
```

**`disable-model-invocation: true`** â€” Prevents the model from automatically invoking this agent as a subagent. The agent is only invoked when explicitly named in an `agents` array or by user selection:

```yaml
---
name: dangerous-migrator
disable-model-invocation: true
tools: ['editor', 'terminal']
---
```

---

## ğŸ­ The orchestrator pattern

The <mark>orchestrator pattern</mark> combines agents, handoffs, and subagents into a coordinated system where a central coordinator decomposes complex tasks and delegates to specialists.

### Conceptual architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚            ORCHESTRATOR AGENT               â”‚
â”‚  â”œâ”€â”€ Receives user request                  â”‚
â”‚  â”œâ”€â”€ Decomposes into subtasks               â”‚
â”‚  â”œâ”€â”€ Delegates to specialists               â”‚
â”‚  â”œâ”€â”€ Synthesizes results                    â”‚
â”‚  â””â”€â”€ Reports summary to user               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ Research  â”‚ â”‚ Implementâ”‚ â”‚ Review   â”‚   â”‚
â”‚  â”‚ Agent    â”‚ â”‚ Agent    â”‚ â”‚ Agent    â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                             â”‚
â”‚  Each specialist:                           â”‚
â”‚  â€¢ Has its own context window               â”‚
â”‚  â€¢ Uses only its declared tools             â”‚
â”‚  â€¢ Returns a focused summary                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Why orchestrators work

The orchestrator pattern mirrors how effective human teams work: a project manager decomposes a task, assigns specialists, and synthesizes their results. The AI equivalent provides:

- **Separation of concerns** â€” each agent focuses on what it does best
- **Context management** â€” the orchestrator's context stays lean because subagent details are summarized
- **Tool safety** â€” research agents can't accidentally edit files; implementation agents have clear write permissions
- **Scalability** â€” adding a new capability means adding a new specialist, not rewriting the orchestrator

### When to use orchestration

| Scenario | Orchestration worthwhile? |
|----------|--------------------------|
| Simple code edit | No â€” use a single agent or inline chat |
| Feature implementation with research | Maybe â€” depends on complexity |
| Multi-step refactoring across files | Yes â€” separate analysis from implementation |
| Full project setup with testing | Yes â€” planning, scaffolding, testing are distinct concerns |
| Security audit with remediation | Yes â€” review and fix are different expertises |

For practical guidance on designing orchestrator prompts, see [How to design orchestrator prompts](../04-howto/10.00-how_to_design_orchestrator_prompts.md). For subagent implementation details, see [How to design subagent orchestrations](../04-howto/11.00-how_to_design_subagent_orchestrations.md).

---

## âš ï¸ Boundaries and limitations

### Current limitations

- **VS Code only.** Custom agents (`.agent.md`) work in VS Code 1.106+. Visual Studio doesn't support them for chat.
- **Experimental subagent support.** The `agents` property and custom agent subagent invocation are experimental and may change.
- **No cross-agent memory.** Agents don't share state between sessions. Each session starts fresh.
- **Handoff context loss.** Handoffs start new conversations â€” the target agent doesn't automatically get the full context of the previous agent's work.

### Best practices

- **Design agents with the principle of least privilege.** Give each agent only the tools it needs for its role.
- **Use `user-invokable: false`** for specialist subagents that shouldn't appear in the agent picker.
- **Keep agent instructions focused.** A 200-line agent body is harder for the model to follow than a 50-line one.
- **Test handoff workflows end-to-end.** Verify that each transition provides enough context for the next agent to continue.

---

## ğŸ¯ Conclusion

Agents are GitHub Copilot's most powerful customization mechanism because they change the model's *identity*, not just its instructions. The ecosystem provides three invocation patterns (direct selection, the `agents` property, and `runSubagent`), two workflow patterns (handoffs for user-controlled transitions, subagents for agent-controlled delegation), and the orchestrator pattern for coordinating complex multi-step tasks.

### Key takeaways

- Agents **override the identity layer** of the system prompt â€” they change who the model *is*
- **Tool restriction** in agents provides true capability control, not just guidance
- **`.agent.md`** is for VS Code chat personas; **`AGENTS.md`** is for the async GitHub Coding Agent
- **Handoffs** transfer control with user approval â€” ideal for multi-phase workflows
- **Subagents** delegate with context isolation â€” ideal for focused subtasks within a larger workflow
- The **orchestrator pattern** combines these mechanisms for scalable, multi-agent systems

### Next steps

- [How to structure content for Copilot agent files](../04-howto/04.00-how_to_structure_content_for_copilot_agent_files.md) â€” practical guide to writing `.agent.md` files
- [How to design orchestrator prompts](../04-howto/10.00-how_to_design_orchestrator_prompts.md) â€” designing the coordinator in orchestration patterns
- [How to design subagent orchestrations](../04-howto/11.00-how_to_design_subagent_orchestrations.md) â€” implementing delegation with `runSubagent`
- [Understanding skills, hooks, and lifecycle automation](./01.05-understanding_skills_hooks_and_lifecycle_automation.md) â€” complementary mechanisms that extend agent capabilities

---

## ğŸ“š References

**[VS Code Copilot Customization Overview](https://code.visualstudio.com/docs/copilot/customization/overview)** `[ğŸ“˜ Official]`
Microsoft's comprehensive guide covering custom agents, their file format, tool configuration, and handoff workflows. The authoritative source for `.agent.md` specification.

**[VS Code Agent Mode Documentation](https://code.visualstudio.com/docs/copilot/chat/chat-agent-mode)** `[ğŸ“˜ Official]`
Documentation for Agent mode in VS Code â€” autonomous file editing, plan mode integration, and multi-step workflows.

**[How to write a great AGENTS.md](https://github.blog/ai-and-ml/github-copilot/how-to-write-a-great-agents-md-lessons-from-over-2500-repositories/)** `[ğŸ“— Verified Community]`
Official GitHub blog post analyzing 2,500+ agent files. Covers the six core areas: commands, testing, project structure, code style, git workflow, and boundaries.

**[VS Code v1.106 Release Notes](https://code.visualstudio.com/updates/v1_106)** `[ğŸ“˜ Official]`
November 2024 release that stabilized custom agents, introduced handoff workflows, and added the `target` field.

**[VS Code v1.107 Release Notes](https://code.visualstudio.com/updates/v1_107)** `[ğŸ“˜ Official]`
December 2024 release introducing Agent HQ, background agents, work tree isolation, and enhanced agent session management.

---

<!--
---
validations:
  grammar: {last_run: null, model: null, outcome: null, issues_found: 0}
  readability: {last_run: null, model: null, outcome: null, flesch_score: null, grade_level: null}
  understandability: {last_run: null, model: null, outcome: null, target_audience: null}
  structure: {last_run: null, model: null, outcome: null, has_toc: true, has_introduction: true, has_conclusion: true, has_references: true}
  facts: {last_run: null, model: null, outcome: null, claims_checked: 0, sources_verified: 0}
  logic: {last_run: null, model: null, outcome: null, flow_score: null}

article_metadata:
  filename: "01.04-understanding_agents_invocation_handoffs_and_subagents.md"
  created: "2026-03-01"
  last_updated: "2026-03-01"
  version: "1.0"
  status: "published"
  primary_topic: "Agents, invocation, handoffs, and subagents"

cross_references:
  related_articles:
    - "01.02-how_copilot_assembles_and_processes_prompts.md"
    - "04.00-how_to_structure_content_for_copilot_agent_files.md"
    - "10.00-how_to_design_orchestrator_prompts.md"
    - "11.00-how_to_design_subagent_orchestrations.md"
    - "01.05-understanding_skills_hooks_and_lifecycle_automation.md"
  series: "Prompt Engineering for GitHub Copilot"
  series_order: 5
  prerequisites:
    - "01.02-how_copilot_assembles_and_processes_prompts.md"
---
-->
