---
title: "Understanding MCP and the tool ecosystem"
author: "Dario Airoldi"
date: "2026-03-01"
categories: [tech, prompt-engineering, github-copilot, concepts, mcp]
description: "Understand the Model Context Protocol, how the two-level tool architecture works, what tool categories exist, and when to build an MCP server vs. use built-in tools or extensions."
---

# Understanding MCP and the tool ecosystem

An agent without tools can only *think*. It can reason about code, generate text, and answer questions â€” but it can't search your codebase, edit files, run terminal commands, or call external APIs. Tools are what transform a language model from a sophisticated text generator into a capable coding assistant.

GitHub Copilot's tool ecosystem has three layers: built-in tools that ship with VS Code, extension-contributed tools from the marketplace, and <mark>Model Context Protocol (MCP)</mark> servers that you build or install to add custom capabilities. This article explains how these layers work together, how the two-level tool architecture connects your YAML declarations to runtime execution, and when to reach for each type of tool.

## Table of contents

- [ğŸ¯ Why tools matter](#-why-tools-matter)
- [ğŸ—ï¸ The two-level tool architecture](#ï¸-the-two-level-tool-architecture)
- [ğŸ“‹ Level 1: YAML capability declarations](#-level-1-yaml-capability-declarations)
- [âš™ï¸ Level 2: Runtime tool calls](#ï¸-level-2-runtime-tool-calls)
- [ğŸ”Œ Tool sources: built-in, MCP, and extensions](#-tool-sources-built-in-mcp-and-extensions)
- [ğŸŒ Understanding the Model Context Protocol](#-understanding-the-model-context-protocol)
- [ğŸ“Š Tool categories: what tools can do](#-tool-categories-what-tools-can-do)
- [âœ… Decision framework: choosing the right tool source](#-decision-framework-choosing-the-right-tool-source)
- [âš ï¸ Tool restrictions and safety](#ï¸-tool-restrictions-and-safety)
- [ğŸ¯ Conclusion](#-conclusion)
- [ğŸ“š References](#-references)

---

## ğŸ¯ Why tools matter

Consider this prompt: "Find all usages of the `UserService` class and update them to use the new `AuthenticatedUserService` interface."

Without tools, Copilot can reason about what *should* happen â€” but it can't search your codebase, read the actual files, or make changes. With tools, it can:

1. **Search** â€” `semantic_search` and `grep_search` find every file that references `UserService`
2. **Read** â€” `read_file` loads each file to understand the usage context
3. **Edit** â€” `replace_string_in_file` makes the actual changes
4. **Validate** â€” `get_errors` checks for compile errors after each change
5. **Confirm** â€” `ask_questions` verifies ambiguous cases with you

Tools are the mechanism that closes the gap between "thinking about code" and "changing code."

---

## ğŸ—ï¸ The two-level tool architecture

GitHub Copilot's tool system operates at two distinct levels. Understanding this separation is essential â€” confusing Level 1 and Level 2 is the most common source of tool-related mistakes in prompt engineering.

```
You write (Level 1)                    The model calls (Level 2)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                     â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
tools: ['codebase']          â”€â”€â”€â”€â–º     semantic_search()
                                       grep_search()
                                       file_search()
                                       read_file()

tools: ['editor']            â”€â”€â”€â”€â–º     create_file()
                                       replace_string_in_file()
                                       multi_replace_string_in_file()
                                       read_file()

tools: ['filesystem']        â”€â”€â”€â”€â–º     list_dir()
                                       file_search()
                                       read_file()
```

| Level | What you write | What happens | Example |
|-------|----------------|-------------|---------|
| **Level 1** â€” YAML declarations | `tools:` field in frontmatter | Grants *permission* to use tool categories | `codebase`, `editor`, `fetch` |
| **Level 2** â€” Runtime tool calls | Model decides during execution | Actual operations on your workspace | `read_file()`, `grep_search()`, `create_file()` |

The relationship is hierarchical: Level 1 declarations **enable** groups of Level 2 runtime tools. When you write `tools: ['editor']` in YAML, you're granting permission to use `create_file`, `replace_string_in_file`, and `multi_replace_string_in_file`. You're not calling those tools directly â€” the model decides *which* runtime tools to call and *when*, based on the task.

### Why the separation matters

This two-level design serves different audiences:

- **Level 1 is for prompt authors** â€” you decide what *categories* of operations an agent can perform
- **Level 2 is for the model** â€” the model decides what *specific* operations to perform within those categories

This means you control the "safety perimeter" through Level 1 declarations (an agent with only `['codebase']` can't edit files), while the model handles the tactical decisions (which search tool is best for this specific query).

---

## ğŸ“‹ Level 1: YAML capability declarations

Level 1 tools are what you write in the `tools` field of prompt and agent YAML frontmatter. They control what categories of operations an agent can perform.

### Core built-in capabilities

| Capability | What it enables | Read-only? | Network? |
|------------|----------------|------------|----------|
| `codebase` | Semantic search across workspace | Yes | No |
| `editor` | File creation, modification, deletion | No | No |
| `filesystem` | Directory navigation, file metadata | Yes | No |
| `fetch` | Retrieve content from web URLs | Yes | Yes |
| `web_search` | Search the internet | Yes | Yes |
| `search` | Workspace text search (exact/regex) | Yes | No |
| `usages` | Code references, call hierarchies | Yes | No |
| `problems` | Compile errors, lint warnings | Yes | No |
| `changes` | Git changes and diffs | Yes | No |

### Tool sets (predefined groups)

VS Code provides predefined groups for convenience:

| Tool set | Includes | Use case |
|----------|----------|----------|
| `#edit` | `editor`, `filesystem` | Code modification workflows |
| `#search` | `codebase`, `search`, `usages` | Code discovery and analysis |
| `#reader` | `codebase`, `problems`, `changes`, `usages` | Context gathering without modification |

### MCP server tools in YAML

Tools from MCP servers use the `@server-name` prefix:

```yaml
tools: ['codebase', '@github/*']      # All tools from GitHub MCP server
tools: ['editor', '@azure/deploy']     # Specific Azure tool only
tools: ['#search', '@company-wiki/*']  # Search + custom MCP
```

### Common capability profiles

| Profile | Capabilities | Use case |
|---------|-------------|----------|
| **Read-only** | `['codebase', 'filesystem', 'search']` | Code review, planning, research |
| **Local edit** | `['codebase', 'editor', 'filesystem']` | Refactoring, code generation |
| **Research** | `['codebase', 'fetch', 'web_search']` | Documentation, best practices |
| **Full local** | `['codebase', 'editor', 'filesystem', 'search', 'usages', 'problems']` | Implementation agents |
| **Unrestricted** | `[]` or omit field | All available tools enabled |

---

## âš™ï¸ Level 2: Runtime tool calls

Level 2 is where tools actually *do* things. The model decides which runtime tools to call based on the task, your instructions, and the available capabilities. Here's the catalog organized by what they do.

### Always-available tools

Some runtime tools are **always available** regardless of your YAML `tools` field:

| Tool | Purpose |
|------|---------|
| `manage_todo_list` | Track task progress in structured lists |
| `ask_questions` | Present structured questions to the user |
| `runSubagent` | Delegate work to other agents |
| `tool_search_tool_regex` | Discover deferred tools from MCP/extensions |

This means even an agent restricted to `tools: ['codebase']` can still track progress, ask for clarification, delegate to subagents, and discover MCP tools. You can't create a truly passive agent.

### Key runtime tools by category

**Search tools:**

| Tool | What it does | Best for |
|------|-------------|----------|
| `semantic_search` | Natural language search using embeddings | Discovering conceptually related code |
| `grep_search` | Exact text/regex search across workspace | Finding specific strings, function names |
| `file_search` | Find files by glob pattern (paths only) | Locating files before reading them |
| `read_file` | Read file contents by line range | Loading specific sections of code |

**Edit tools:**

| Tool | What it does | Best for |
|------|-------------|----------|
| `create_file` | Create new files with content | Scaffolding new files |
| `replace_string_in_file` | Replace exact text in a file | Targeted edits with context |
| `multi_replace_string_in_file` | Batch replacements across files | Refactoring multiple locations |

**Execution tools:**

| Tool | What it does | Best for |
|------|-------------|----------|
| `run_in_terminal` | Execute shell commands | Building, testing, running scripts |
| `get_terminal_output` | Check output from background processes | Monitoring long-running tasks |

**Interaction tools:**

| Tool | What it does | Best for |
|------|-------------|----------|
| `ask_questions` | Present structured choices to users | Disambiguation, confirmation |
| `manage_todo_list` | Track multi-step task progress | Complex workflows with visibility |

**Delegation tools:**

| Tool | What it does | Best for |
|------|-------------|----------|
| `runSubagent` | Spawn a subagent for isolated work | Parallel research, complex subtasks |
| `search_subagent` | Launch a search-focused subagent | Deep codebase exploration |

### Tool token costs

Every tool call consumes tokens â€” both for the function signature in the system prompt and for the results returned. Here's a rough guide:

| Tool category | Signature cost | Typical result cost |
|---------------|---------------|-------------------|
| Search tools | ~200 tokens each | 500â€“2,000 tokens per call |
| Edit tools | ~300 tokens each | 100â€“500 tokens per call |
| Execution tools | ~200 tokens each | Variable (command output) |
| Interaction tools | ~150 tokens each | 200â€“500 tokens per call |

More tools enabled means a larger system prompt (more function signatures). This is why tool restriction in agents isn't just about safety â€” it's also about token efficiency.

---

## ğŸ”Œ Tool sources: built-in, MCP, and extensions

Tools come from three sources, each with different characteristics:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Copilot Chat (the client)                    â”‚
â”‚                                                                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  Built-in    â”‚  â”‚  Extension   â”‚  â”‚  MCP Server Tools    â”‚ â”‚
â”‚  â”‚  Tools       â”‚  â”‚  Tools       â”‚  â”‚                      â”‚ â”‚
â”‚  â”‚              â”‚  â”‚              â”‚  â”‚  @github (built-in)  â”‚ â”‚
â”‚  â”‚  read_file   â”‚  â”‚  From VS     â”‚  â”‚  @azure  (built-in)  â”‚ â”‚
â”‚  â”‚  grep_search â”‚  â”‚  Code        â”‚  â”‚  @your-server        â”‚ â”‚
â”‚  â”‚  create_file â”‚  â”‚  extensions  â”‚  â”‚  (custom)            â”‚ â”‚
â”‚  â”‚  run_in_     â”‚  â”‚  in the      â”‚  â”‚                      â”‚ â”‚
â”‚  â”‚  terminal    â”‚  â”‚  marketplace â”‚  â”‚  Runs as separate    â”‚ â”‚
â”‚  â”‚  ...         â”‚  â”‚              â”‚  â”‚  processes            â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Built-in tools

Ship with VS Code's Copilot integration. Always present, no configuration needed.

- **Advantages:** Zero setup, stable APIs, tightly integrated with the editor
- **Limitations:** Fixed capabilities â€” you can't add new built-in tools
- **Control:** YAML `tools` field enables/disables categories

### Extension-contributed tools

VS Code extensions can contribute tools to Copilot. These show up alongside built-in tools when the extension is installed.

- **Advantages:** Easy installation from marketplace, curated quality
- **Limitations:** Only available in VS Code (not CLI or coding agent), depend on extension activation
- **Control:** Extensions must be installed and enabled; some contribute tools automatically

### MCP server tools

External processes that communicate with Copilot through the Model Context Protocol. Run as separate processes, never loaded in-process.

- **Advantages:** Any language, any capability, cross-platform, shareable
- **Limitations:** Requires configuration (`mcp.json`), process management overhead
- **Control:** `@server-name` prefix in YAML tool declarations

---

## ğŸŒ Understanding the Model Context Protocol

<mark>MCP (Model Context Protocol)</mark> is an open standard that defines how AI assistants communicate with external tools and data sources. It's the "USB-C for AI tools" â€” rather than building custom integrations for each AI assistant, you build one MCP server that works with any MCP-compatible client.

### Core concepts

| Concept | What it is |
|---------|-----------|
| **MCP Server** | A process that provides tools, resources, and prompts to AI clients |
| **MCP Client** | An AI assistant (like Copilot) that connects to servers |
| **Tools** | Functions the AI can call to perform actions |
| **Resources** | Data sources the AI can read |
| **Transport** | Communication channel â€” stdio (local) or HTTP/SSE (remote) |

### How MCP servers work

```
1. DISCOVERY
   VS Code reads mcp.json â†’ finds server definitions
       â”‚
       â–¼
2. INITIALIZATION
   VS Code spawns server process â†’ exchanges capabilities
       â”‚
       â–¼
3. RUNTIME
   Model calls tool â†’ VS Code forwards to MCP server â†’
   Server executes â†’ Returns structured result
       â”‚
       â–¼
4. SHUTDOWN
   Session ends â†’ VS Code terminates server process
```

All MCP servers run as **separate processes** â€” they're never loaded in-process into VS Code. This provides language independence (write in TypeScript, C#, Python, or anything else), isolation (server crashes don't affect the editor), and security (servers run with their own permissions).

### Transport options

| Transport | Use case | How it works |
|-----------|----------|--------------|
| **stdio** | Local servers | VS Code spawns the server as a subprocess, communicates via stdin/stdout |
| **HTTP/SSE** | Remote servers | Server runs as an HTTP endpoint, accessible over the network |

For GitHub Copilot integration, **stdio is the default and recommended transport**. HTTP/SSE is used when the server runs remotely or needs to serve multiple clients.

### Configuration

MCP servers are configured in `.vscode/mcp.json` (workspace-level) or VS Code settings (user-level):

```json
{
  "servers": {
    "my-server": {
      "type": "stdio",
      "command": "node",
      "args": ["./path/to/server.js"]
    }
  }
}
```

### SDK implementations

MCP servers can be built in any language with an MCP SDK. All SDKs implement the same specification â€” the client doesn't know or care what language the server is written in:

| Aspect | TypeScript | C# (.NET) | Python |
|--------|-----------|-----------|--------|
| **Runtime** | Node.js | .NET 8.0+ | Python 3.10+ |
| **Style** | Functional | Attribute-based | Decorator-based |
| **Best for** | Web integrations, npm ecosystem | Enterprise, existing .NET apps | AI/ML, data science |

### MCP Registry and discovery

The <mark>MCP Registry</mark> provides a centralized catalog of available MCP servers:

- **GitHub MCP Server** (`@github`) â€” issues, pull requests, repository operations
- **Azure MCP Server** (`@azure`) â€” Azure resources, documentation, queries
- **Community servers** â€” Hundreds of community-built servers for databases, APIs, and services

VS Code includes a built-in gallery for discovering and installing MCP servers. The `tool_search_tool_regex` runtime tool also lets agents discover available MCP tools dynamically at runtime â€” this is how agents find and use "deferred" tools that aren't pre-loaded.

---

## ğŸ“Š Tool categories: what tools can do

Regardless of source (built-in, MCP, or extension), all tools fall into five functional categories:

| Category | Purpose | Examples |
|----------|---------|---------|
| **Search** | Find information in the workspace or web | `semantic_search`, `grep_search`, `file_search`, `fetch_webpage` |
| **Edit** | Modify files in the workspace | `create_file`, `replace_string_in_file`, `multi_replace_string_in_file` |
| **Execute** | Run commands and programs | `run_in_terminal`, `get_terminal_output` |
| **Interact** | Communicate with users | `ask_questions`, `manage_todo_list` |
| **Delegate** | Orchestrate other agents | `runSubagent`, `search_subagent` |

This categorization matters for two reasons:

1. **Safety design** â€” you control categories, not individual tools. An agent restricted to search tools can explore but can't change anything.
2. **Prompt strategy** â€” different categories have different token costs and reliability characteristics. Search tools return variable-size results; edit tools require precise input.

Understanding these categories helps you design agents with appropriate capability profiles. A code reviewer needs search + interact. A refactoring agent needs search + edit + execute. An orchestrator needs search + interact + delegate.

---

## âœ… Decision framework: choosing the right tool source

```
What capability do you need?
â”‚
â”œâ”€ Already available as a built-in tool?
â”‚   â””â”€ Yes â†’ Use built-in (no setup needed)
â”‚
â”œâ”€ Available as a VS Code extension?
â”‚   â””â”€ Yes â†’ Is it VS Code-only acceptable?
â”‚       â”œâ”€ Yes â†’ Install the extension
â”‚       â””â”€ No â†’ Continue to MCP
â”‚
â”œâ”€ Available as a community MCP server?
â”‚   â””â”€ Yes â†’ Install and configure in mcp.json
â”‚
â””â”€ None of the above
    â””â”€ Build your own MCP server
```

### When to build a custom MCP server

Build an MCP server when you need to:

- **Query external systems** â€” databases, APIs, internal services
- **Perform complex computations** â€” data processing, analysis, transformations
- **Access live data** â€” real-time metrics, monitoring, dashboards
- **Enforce business logic** â€” validation rules, compliance checks
- **Share capabilities across projects** â€” reusable tooling for teams
- **Work cross-platform** â€” tools that work in VS Code, CLI, and the coding agent

### When NOT to build an MCP server

- A **prompt file** can accomplish the task through existing tools
- You only need **coding standards** â†’ use instruction files
- You only need **templates alongside instructions** â†’ use skills
- **Existing tools** (built-in or community) already provide the capability
- The task is **one-off** and doesn't justify the development overhead

---

## âš ï¸ Tool restrictions and safety

### Default behavior

When you **omit** the `tools` field in a prompt or agent file, all available tools are enabled â€” including built-in tools, extension tools, and all configured MCP servers. This is the maximum capability (and maximum token cost) configuration.

When you **provide an empty array** (`tools: []`), you get only the always-available tools (`manage_todo_list`, `ask_questions`, `runSubagent`, `tool_search_tool_regex`).

### Safety through restriction

Tool restriction is your primary safety mechanism. It's more reliable than natural language instructions because it's enforced at the system level:

| Instruction | Reliability |
|-------------|------------|
| "Don't modify any files" (in agent instructions) | Medium â€” model might ignore it |
| `tools: ['codebase', 'search']` (no `editor` capability) | High â€” edit tools aren't available |
| Hook blocking `PreToolUse` | Highest â€” code runs deterministically |

For the strongest enforcement, combine tool restrictions (Level 1 YAML) with agent hooks (`PreToolUse` event). Tool restrictions remove the capability entirely; hooks provide programmatic validation of individual operations.

---

## ğŸ¯ Conclusion

The tool ecosystem is what transforms GitHub Copilot from a text generator into a capable coding assistant. Built-in tools handle the common operations (search, edit, execute), extensions add specialized capabilities from the marketplace, and MCP servers let you build custom integrations that work across any MCP-compatible client.

### Key takeaways

- The **two-level architecture** separates your intent (Level 1 YAML declarations) from the model's decisions (Level 2 runtime calls)
- Level 1 capabilities **enable groups** of Level 2 runtime tools â€” writing `tools: ['editor']` enables `create_file`, `replace_string_in_file`, and others
- **Four tools are always available** regardless of restrictions: `manage_todo_list`, `ask_questions`, `runSubagent`, `tool_search_tool_regex`
- **MCP is the universal adapter** â€” build once, use with any MCP-compatible AI client
- All MCP servers run as **separate processes** (out-of-process), providing language independence and isolation
- **Tool restriction** through YAML declarations is more reliable than natural language instructions for controlling agent behavior
- Every tool adds **token cost** â€” both for its signature in the system prompt and its results in the conversation

### Next steps

- [How to leverage tools in prompt orchestrations](../04-howto/09.50-how_to_leverage_tools_in_prompt_orchestrations.md) â€” the complete runtime tool catalog with selection strategies
- [How to create MCP servers for Copilot](../04-howto/07.00-how_to_create_mcp_servers_for_copilot.md) â€” building custom MCP servers in TypeScript, C#, and Python
- [Understanding skills, hooks, and lifecycle automation](./01.05-understanding_skills_hooks_and_lifecycle_automation.md) â€” complementary customization mechanisms

---

## ğŸ“š References

**[Model Context Protocol Specification](https://modelcontextprotocol.io/)** `[ğŸ“˜ Official]`
The open standard defining MCP. Covers the complete protocol specification including tool definitions, resource access, transport mechanisms, and JSON-RPC 2.0 message format.

**[VS Code Copilot Custom Tools Documentation](https://code.visualstudio.com/docs/copilot/customization/tools)** `[ğŸ“˜ Official]`
Microsoft's documentation for tool capability declarations, MCP server configuration, and the built-in tool catalog. Covers both Level 1 YAML declarations and Level 2 runtime tools.

**[VS Code MCP Server Configuration](https://code.visualstudio.com/docs/copilot/chat/mcp-servers)** `[ğŸ“˜ Official]`
Official guide for configuring MCP servers in VS Code â€” `mcp.json` format, transport options, environment variables, and the built-in MCP server gallery.

**[MCP Registry (mcp.so)](https://mcp.so/)** `[ğŸ“— Verified Community]`
Community-maintained catalog of available MCP servers across categories â€” search providers, databases, cloud services, development tools, and more.

---

<!--
---
validations:
  grammar: {last_run: null, model: null, outcome: null, issues_found: 0}
  readability: {last_run: null, model: null, outcome: null, flesch_score: null, grade_level: null}
  understandability: {last_run: null, model: null, outcome: null, target_audience: null}
  structure: {last_run: null, model: null, outcome: null, has_toc: true, has_introduction: true, has_conclusion: true, has_references: true}
  facts: {last_run: null, model: null, outcome: null, claims_checked: 0, sources_verified: 0}
  logic: {last_run: null, model: null, outcome: null, flow_score: null}

article_metadata:
  filename: "01.06-understanding_mcp_and_the_tool_ecosystem.md"
  created: "2026-03-01"
  last_updated: "2026-03-01"
  version: "1.0"
  status: "published"
  primary_topic: "MCP and the tool ecosystem"

cross_references:
  related_articles:
    - "09.50-how_to_leverage_tools_in_prompt_orchestrations.md"
    - "07.00-how_to_create_mcp_servers_for_copilot.md"
    - "01.05-understanding_skills_hooks_and_lifecycle_automation.md"
  series: "Prompt Engineering for GitHub Copilot"
  series_order: 7
  prerequisites:
    - "01.02-how_copilot_assembles_and_processes_prompts.md"
---
-->
